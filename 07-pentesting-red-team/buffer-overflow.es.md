---
title: "Qu√© es el desbordamiento de b√∫fer y como explotar esta vulnerabilidad"
subtitle: "Aprende todo sobre el desbordamiento de b√∫fer y c√≥mo explotarlo"
tags: ["pentesting", "ciberseguridad", "red-team"]
authors: ["blindma1den", "lorenagubaira"]

---

## ¬øQu√© es el desbordamiento del b√∫fer?

Los buffers son regiones de almacenamiento de memoria que contienen datos temporalmente mientras se transfieren de una ubicaci√≥n a otra. Un desbordamiento del b√∫fer (o desbordamiento del b√∫fer) ocurre cuando el volumen de datos excede la capacidad de almacenamiento del b√∫fer de memoria. Como resultado, el programa que intenta escribir los datos en el b√∫fer sobrescribe las ubicaciones de memoria adyacentes .

Por ejemplo, se puede dise√±ar un b√∫fer para las credenciales de inicio de sesi√≥n para que espere entradas de nombre de usuario y contrase√±a de 8 bytes, de modo que si una transacci√≥n implica una entrada de 10 bytes (es decir, 2 bytes m√°s de lo esperado), el programa puede escribir el exceso. datos m√°s all√° del l√≠mite del buffer.

Los desbordamientos de b√∫fer pueden afectar a todo tipo de software. Por lo general, son el resultado de entradas con formato incorrecto o de no asignar suficiente espacio para el b√∫fer. Si la transacci√≥n sobrescribe el c√≥digo ejecutable, puede hacer que el programa se comporte de manera impredecible y genere resultados incorrectos, errores de acceso a la memoria o fallas.

![Buffer1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer1.png?raw=true)

Se produce un desbordamiento del b√∫fer cuando un programa intenta escribir demasiados datos en el b√∫fer. Esto puede hacer que el programa falle o ejecute c√≥digo arbitrario. Las vulnerabilidades de desbordamiento de b√∫fer existen s√≥lo en lenguajes de programaci√≥n de bajo nivel como C con acceso directo a la memoria. Sin embargo, tambi√©n afectan a los usuarios de lenguajes web de alto nivel porque los marcos suelen estar escritos en lenguajes de bajo nivel. El siguiente es el c√≥digo fuente de un programa en C que tiene una vulnerabilidad de desbordamiento del b√∫fer:

```c
char greeting[5];

memcpy(greeting, "Hello, world!\n", 15);

printf(greeting);
```

**¬øQu√© crees que pasar√° cuando compilamos y ejecutamos este programa vulnerable?** La respuesta puede resultar sorprendente: cualquier cosa puede pasar. Cuando se ejecuta este fragmento de c√≥digo, intentar√° colocar quince bytes en un b√∫fer de destino que tiene solo cinco bytes de longitud. Esto significa que se escribir√°n diez bytes en direcciones de memoria fuera de la matriz. Lo que suceda despu√©s depende del contenido original de los diez bytes de memoria sobrescritos.

¬øQuiz√°s se almacenaron variables importantes all√≠ y acabamos de cambiar sus valores? El ejemplo anterior est√° roto de una manera tan obvia que ning√∫n programador en su sano juicio cometer√≠a tal error. Entonces consideremos otro ejemplo. Supongamos que necesitamos leer una direcci√≥n IP de un archivo. Podemos hacerlo usando el siguiente c√≥digo C:

```c
#include <stdio.h>

#define MAX_IP_LENGTH 15

int main(void) {
    char file_name[] = "ip.txt";
    FILE *fp;
    fp = fopen(file_name, "r");

    char ch;
    int counter = 0;
    char buf[MAX_IP_LENGTH];

    while ((ch = fgetc(fp)) != EOF) {
        buf[counter++] = ch;
    }

    buf[counter] = '\0';
    printf("%s\n", buf);
    
    fclose(fp);
    return 0;
}
```

El error en el ejemplo anterior no es tan obvio. Suponemos que la direcci√≥n IP que queremos leer de un archivo nunca exceder√° los 15 bytes. Las direcciones IP adecuadas (por ejemplo, 255.255.255.255) no pueden tener m√°s de 15 bytes. Sin embargo, un usuario malintencionado puede preparar un archivo que contenga una cadena falsa muy larga en lugar de una direcci√≥n IP (por ejemplo, 19222222222.16888888.0.1). Esta cadena har√° que nuestro programa desborde el b√∫fer de destino.

## ¬øQu√© es un ataque de desbordamiento de b√∫fer?

Los atacantes aprovechan los problemas de desbordamiento del b√∫fer sobrescribiendo la memoria de una aplicaci√≥n. Esto cambia la ruta de ejecuci√≥n del programa, desencadenando una respuesta que da√±a archivos o expone informaci√≥n privada. Por ejemplo, un atacante puede introducir c√≥digo adicional y enviar nuevas instrucciones a la aplicaci√≥n para obtener acceso a los sistemas de TI.

Si los atacantes conocen el dise√±o de la memoria de un programa, pueden alimentar intencionalmente entradas que el b√∫fer no puede almacenar y sobrescribir √°reas que contienen c√≥digo ejecutable, reemplaz√°ndolo con su propio c√≥digo. Por ejemplo, un atacante puede sobrescribir un puntero (un objeto que apunta a otra √°rea de la memoria) y apuntarlo a una carga √∫til de explotaci√≥n para obtener control sobre el programa.

- **Ejemplo de ataque de desbordamiento del buffer de pila**.

Ahora que sabemos que un programa puede desbordar una matriz y sobrescribir un fragmento de memoria que no deber√≠a sobrescribir, veamos c√≥mo se puede utilizar esto para montar un ataque de desbordamiento de b√∫fer. En un escenario t√≠pico (llamado *desbordamiento del b√∫fer de pila*), el problema se debe (como tantos problemas en la seguridad de la informaci√≥n) a la mezcla de datos (destinados a ser procesados ‚Äã‚Äão mostrados) con comandos que controlan la ejecuci√≥n del programa. En C, como en la mayor√≠a de los lenguajes de programaci√≥n, los programas se crean utilizando funciones.

Las funciones se llaman entre s√≠, se pasan argumentos entre s√≠ y devuelven valores. Por ejemplo, nuestro c√≥digo, que lee una direcci√≥n IP de un archivo, podr√≠a ser parte de una funci√≥n llamada readIpAddress, que lee una direcci√≥n IP de un archivo y la analiza. Esta funci√≥n podr√≠a ser llamada por alguna otra funci√≥n, por ejemplo readConfiguration. Cuando readConfigurationllama readIpAddress, le pasa un nombre de archivo y luego la readIpAddressfunci√≥n devuelve una direcci√≥n IP como una matriz de cuatro bytes. Fig. 1. Los argumentos y el valor de retorno de la funci√≥n readIpAddress.

![Buffer2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer2.es.png?raw=true)

Durante esta llamada a funci√≥n, se almacenan tres piezas diferentes de informaci√≥n, una al lado de la otra, en la memoria de la computadora. Para cada programa, el sistema operativo mantiene una regi√≥n de memoria que incluye una parte llamada *pila* o *pila de llamadas* (de ah√≠ el nombre *de desbordamiento del b√∫fer de pila*). Cuando se llama a una funci√≥n, se le asigna un fragmento de la pila. Esta pieza de la pila (llamada *marco*) se utiliza para:

- Recuerde la l√≠nea de c√≥digo desde la cual se debe reanudar la ejecuci√≥n del programa cuando se complete la ejecuci√≥n de la funci√≥n (en nuestro caso, ser√° una l√≠nea espec√≠fica de la readConfigurationfunci√≥n).
- Almacene los argumentos pasados ‚Äã‚Äãa la funci√≥n por su llamador (en nuestro caso, supongamos /home/someuser/myconfiguration/ip.txt).
- Almacene el valor de retorno que la funci√≥n devuelve a su llamador (en nuestro caso, es una matriz de cuatro bytes, digamos (192, 168, 0, 1)).
- Almacenar variables locales de la funci√≥n llamada mientras se ejecuta esta funci√≥n (en nuestro caso, la variable char[MAX_IP_LENGTH] buf).

> üëâ Entonces, si un programa tiene un b√∫fer asignado en el marco de la pila e intenta insertar m√°s datos de los que caben all√≠, los datos ingresados ‚Äã‚Äãpor el usuario pueden desbordarse y sobrescribir la ubicaci√≥n de la memoria donde se almacena la direcci√≥n del remitente. Contenido del marco de la pila cuando se llama a la funci√≥n readIPAddress:

![Buffer3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer3.es.png?raw=true)

Si el problema fue causado por datos de entrada aleatorios mal formados del usuario, lo m√°s probable es que la nueva direcci√≥n de retorno no apunte a una ubicaci√≥n de memoria donde est√© almacenado ning√∫n otro programa, por lo que el programa original simplemente fallar√°. Sin embargo, si los datos se preparan cuidadosamente, pueden provocar la ejecuci√≥n de c√≥digo no deseada.

El primer paso para el atacante es preparar datos especiales que puedan interpretarse como c√≥digo ejecutable y que funcionen en beneficio del atacante (esto se denomina c√≥digo¬† *shell* ). El segundo paso es colocar la direcci√≥n de estos datos maliciosos en la ubicaci√≥n exacta donde deber√≠a estar la direcci√≥n del remitente. El contenido de ip.txt sobrescribe la direcci√≥n del remitente:

![Buffer4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer4-es.png?raw=true)

De hecho, cuando la funci√≥n lee la cadena de caracteres IP y la coloca en el b√∫fer de destino, la direcci√≥n de retorno se reemplaza por la direcci√≥n del c√≥digo malicioso. Cuando finaliza la funci√≥n, la ejecuci√≥n del programa salta al c√≥digo malicioso.

## Tipos de ataques de desbordamiento de b√∫fer

Los desbordamientos del b√∫fer basados ‚Äã‚Äãen pilas son m√°s comunes y aprovechan la memoria de la pila que solo existe durante el tiempo de ejecuci√≥n de una funci√≥n.

**Los ataques basados ‚Äã‚Äãen mont√≥n** son m√°s dif√≠ciles de llevar a cabo e implican inundar el espacio de memoria asignado para un programa m√°s all√° de la memoria utilizada para las operaciones actuales en tiempo de ejecuci√≥n.

### ¬øQu√© lenguajes de programaci√≥n son m√°s vulnerables?

C y C++ son dos lenguajes muy susceptibles a ataques de desbordamiento de b√∫fer, ya que no tienen protecciones integradas contra la sobrescritura o el acceso a datos en su memoria. Mac OSX, Windows y Linux utilizan c√≥digo escrito en C y C++.

Lenguajes como PERL, Java, JavaScript y C# utilizan mecanismos de seguridad integrados que minimizan la probabilidad de desbordamiento del b√∫fer.

### C√≥mo prevenir los desbordamientos del b√∫fer

Los desarrolladores pueden protegerse contra las vulnerabilidades de desbordamiento del b√∫fer mediante medidas de seguridad en su c√≥digo o utilizando lenguajes que ofrecen protecci√≥n integrada.

Adem√°s, los sistemas operativos modernos tienen protecci√≥n en tiempo de ejecuci√≥n. Tres protecciones comunes son:

- **Aleatorizaci√≥n del espacio de direcciones (ASLR)**: se mueve aleatoriamente por las ubicaciones del espacio de direcciones de las regiones de datos. Normalmente, los ataques de desbordamiento de b√∫fer necesitan conocer la localidad del c√≥digo ejecutable, y la aleatorizaci√≥n de los espacios de direcciones hace que esto sea pr√°cticamente imposible.
- **Prevenci√≥n de ejecuci√≥n de datos:** marca ciertas √°reas de la memoria como no ejecutables o ejecutables, lo que impide que un ataque ejecute c√≥digo en una regi√≥n no ejecutable.
- **Protecci√≥n de sobrescritura del controlador de excepciones estructurado (SEHOP)**: ayuda a evitar que el c√≥digo malicioso ataque el manejo de excepciones estructurado (SEH), un sistema integrado para administrar excepciones de hardware y software. De este modo, evita que un atacante pueda hacer uso de la t√©cnica de explotaci√≥n de sobrescritura SEH. A nivel funcional, una sobrescritura de SEH se logra utilizando un desbordamiento de b√∫fer basado en pila para sobrescribir un registro de registro de excepci√≥n, almacenado en la pila de un subproceso.

Mant√©ngase al d√≠a con los √∫ltimos informes de errores para sus productos de servidor web y de aplicaciones y otros productos en su infraestructura de Internet. Aplique los parches m√°s recientes a estos productos. Escanee peri√≥dicamente su sitio web con uno o m√°s de los esc√°neres com√∫nmente disponibles que buscan fallas de desbordamiento del b√∫fer en sus productos de servidor y sus aplicaciones web personalizadas.

Para el c√≥digo de su aplicaci√≥n personalizada, debe revisar todo el c√≥digo que acepta entradas de los usuarios a trav√©s de la solicitud HTTP y asegurarse de que proporciona una verificaci√≥n del tama√±o adecuado en todas esas entradas. Esto se debe hacer incluso en entornos que no son susceptibles a este tipo de ataques, ya que entradas demasiado grandes que no se detectan a√∫n pueden causar denegaci√≥n de servicio u otros problemas operativos.

Las medidas de seguridad en el c√≥digo y la protecci√≥n del sistema operativo no son suficientes. Cuando una organizaci√≥n descubre una vulnerabilidad de desbordamiento del b√∫fer, debe reaccionar r√°pidamente para parchear el software afectado y asegurarse de que los usuarios del software puedan acceder al parche.

Los programadores pueden mitigar el riesgo de ataques de desbordamiento del b√∫fer validando siempre la longitud de la entrada del usuario. Sin embargo, una buena forma general de evitar las vulnerabilidades de desbordamiento del b√∫fer es seguir utilizando funciones seguras que incluyan protecci√≥n contra desbordamiento del b√∫fer (que¬† memcpy no la incluye). Estas funciones est√°n disponibles en diferentes plataformas, por ejemplo, strlcpy, strlcat, snprintf(OpenBSD) o strcpy_s, strcat_s, sprintf_s(Windows).

### Categorizaci√≥n de NVD

> CWE-788: Acceso a la ubicaci√≥n de la memoria despu√©s del final del b√∫fer : esto suele ocurrir cuando un puntero o su √≠ndice se incrementa a una posici√≥n despu√©s del b√∫fer; o cuando la aritm√©tica de punteros da como resultado una posici√≥n despu√©s del b√∫fer.

El desbordamiento de b√∫fer es probablemente la forma m√°s conocida de vulnerabilidad de seguridad del software. La mayor√≠a de los desarrolladores de software saben qu√© es una vulnerabilidad de desbordamiento de b√∫fer, pero los ataques de desbordamiento de b√∫fer contra aplicaciones heredadas y recientemente desarrolladas siguen siendo bastante comunes. Parte del problema se debe a la amplia variedad de formas en que pueden ocurrir los desbordamientos del b√∫fer, y parte se debe a las t√©cnicas propensas a errores que se utilizan a menudo para evitarlos.

Los desbordamientos de b√∫fer no son f√°ciles de descubrir e incluso cuando se descubre uno, generalmente es extremadamente dif√≠cil de explotar. Sin embargo, los atacantes han logrado identificar desbordamientos de b√∫fer en una asombrosa variedad de productos y componentes.

En un exploit cl√°sico de desbordamiento de b√∫fer, el atacante env√≠a datos a un programa, que los almacena en un b√∫fer de pila de tama√±o insuficiente. El resultado es que se sobrescribe la informaci√≥n de la pila de llamadas, incluido el puntero de retorno de la funci√≥n. Los datos establecen el valor del puntero de retorno para que cuando la funci√≥n regrese, transfiera el control al c√≥digo malicioso contenido en los datos del atacante.

Aunque este tipo de desbordamiento del b√∫fer de pila sigue siendo com√∫n en algunas plataformas y en algunas comunidades de desarrollo, existe una variedad de otros tipos de desbordamiento del b√∫fer, incluido el desbordamiento del b√∫fer de mont√≥n y el error de uno por uno, entre otros. Otra clase de falla muy similar se conoce como [ataque de cadena de formato](https://owasp.org/www-community/attacks/Format_string_attack) . Hay varios libros excelentes que brindan informaci√≥n detallada sobre c√≥mo funcionan los ataques de desbordamiento de b√∫fer, incluidos Building Secure Software, Writing Secure Code y The Shellcoder's Handbook.

A nivel de c√≥digo, las vulnerabilidades de desbordamiento del b√∫fer generalmente implican la violaci√≥n de las suposiciones del programador. Muchas funciones de manipulaci√≥n de memoria en C y C++ no realizan verificaci√≥n de l√≠mites y pueden sobrescribir f√°cilmente los l√≠mites asignados de los b√∫feres sobre los que operan. Incluso las funciones limitadas, como strncpy(), pueden causar vulnerabilidades cuando se usan incorrectamente. La combinaci√≥n de manipulaci√≥n de la memoria y suposiciones err√≥neas sobre el tama√±o o la composici√≥n de un dato es la causa principal de la mayor√≠a de los desbordamientos del b√∫fer.

Las vulnerabilidades de desbordamiento del b√∫fer suelen ocurrir en c√≥digo que:

- Se basa en datos externos para controlar su comportamiento.
- Depende de las propiedades de los datos que se aplican fuera del alcance inmediato del c√≥digo.
- Es tan complejo que un programador no puede predecir con precisi√≥n su comportamiento.

Desde el descubrimiento de la t√©cnica de ataque de desbordamiento del b√∫fer de pila, los autores de sistemas operativos (Linux, Microsoft Windows, macOS y otros) han intentado encontrar t√©cnicas de prevenci√≥n:

- La pila se puede hacer no ejecutable, por lo que incluso si se coloca c√≥digo malicioso en el b√∫fer, no se puede ejecutar.
- El sistema operativo puede aleatorizar el dise√±o de la memoria del espacio de direcciones (espacio de memoria). Cuando el c√≥digo malicioso se coloca en un b√∫fer, el atacante no puede predecir su direcci√≥n.
- Otras t√©cnicas de protecci√≥n (por ejemplo, StackGuard) modifican un compilador de tal manera que cada funci√≥n llama a un fragmento de c√≥digo que garantiza que la direcci√≥n del remitente no haya cambiado.

En la pr√°ctica, incluso si dichos mecanismos de protecci√≥n dificultan los ataques de desbordamiento del b√∫fer de pila, no los hacen imposibles. Algunas de estas medidas tambi√©n pueden afectar el rendimiento. Las vulnerabilidades de desbordamiento de b√∫fer existen en lenguajes de programaci√≥n que, como C, intercambian seguridad por eficiencia y no verifican el acceso a la memoria. En los lenguajes de programaci√≥n de nivel superior (por ejemplo, Python, Java, PHP, JavaScript o Perl), que se utilizan a menudo para crear aplicaciones web, las vulnerabilidades de desbordamiento del b√∫fer no pueden existir. En estos idiomas, simplemente no se pueden colocar datos sobrantes en el b√∫fer de destino. Por ejemplo, intente compilar y ejecutar el siguiente c√≥digo Java:

```java
int[] buffer = new int[5];

buffer[100] = 44;
```

El compilador de Java no le avisar√°, pero la m√°quina virtual Java en tiempo de ejecuci√≥n detectar√° el problema y, en lugar de sobrescribir la memoria aleatoria, interrumpir√° la ejecuci√≥n del programa.

### Desbordamiento de b√∫fer y aplicaciones web

Los atacantes utilizan desbordamientos de b√∫fer para corromper la pila de ejecuci√≥n de una aplicaci√≥n web. Al enviar informaci√≥n cuidadosamente dise√±ada a una aplicaci√≥n web, un atacante puede hacer que la aplicaci√≥n web ejecute c√≥digo arbitrario, apoder√°ndose efectivamente de la m√°quina.

Las fallas de desbordamiento de b√∫fer pueden estar presentes tanto en el servidor web como en los productos del servidor de aplicaciones que atienden los aspectos est√°ticos y din√°micos del sitio, o en la aplicaci√≥n web misma. Es probable que los desbordamientos de b√∫fer que se encuentran en productos de servidor ampliamente utilizados se vuelvan ampliamente conocidos y puedan representar un riesgo significativo para los usuarios de estos productos. Cuando las aplicaciones web utilizan bibliotecas, como una biblioteca de gr√°ficos para generar im√°genes, se exponen a posibles ataques de desbordamiento del b√∫fer.

Los desbordamientos de b√∫fer tambi√©n se pueden encontrar en el c√≥digo de aplicaciones web personalizadas, e incluso pueden ser m√°s probables dada la falta de escrutinio por el que suelen pasar las aplicaciones web. Es menos probable que se detecten fallas de desbordamiento de b√∫fer en aplicaciones web personalizadas porque normalmente habr√° muchos menos piratas inform√°ticos que intenten encontrar y explotar dichas fallas en una aplicaci√≥n espec√≠fica. Si se descubre en una aplicaci√≥n personalizada, la capacidad de explotar la falla (aparte de bloquear la aplicaci√≥n) se reduce significativamente por el hecho de que el c√≥digo fuente y los mensajes de error detallados de la aplicaci√≥n normalmente no est√°n disponibles para el pirata inform√°tico.

Sin embargo, incluso los programadores que utilizan lenguajes de alto nivel deber√≠an conocer y preocuparse por los ataques de desbordamiento del b√∫fer. Sus programas a menudo se ejecutan dentro de sistemas operativos escritos en C o utilizan entornos de ejecuci√≥n escritos en C, y este c√≥digo C puede ser vulnerable a tales ataques.

Para ver c√≥mo una vulnerabilidad de desbordamiento de b√∫fer puede afectar a un programador que utiliza un lenguaje de programaci√≥n de tan alto nivel, analicemos [CVE-2015-3329](https://nvd.nist.gov/vuln/detail/CVE-2015-3329), una vulnerabilidad de seguridad de la vida real descubierta en la biblioteca est√°ndar PHP en 2015. Una aplicaci√≥n PHP es una colecci√≥n de archivos **.php*. Para facilitar la distribuci√≥n de dicha aplicaci√≥n, se puede empaquetar en un √∫nico archivo, como un archivo *zip* , un archivo *tar* o utilizando un formato PHP personalizado llamado *phar*.

Una extensi√≥n PHP llamada *phar* contiene una clase que puede utilizar para trabajar con dichos archivos. Con esta clase, puede analizar un archivo, enumerar sus archivos, extraerlos, etc. Usar esta clase es bastante simple. Por ejemplo, para extraer todos los archivos de un archivo, utilice el siguiente c√≥digo:

```php
$phar = new Phar('phar-file.phar');

$phar->extractTo('./directory');
```

Cuando la clase Phar analiza un archivo (es decir¬† new Phar('phar-file.phar')), lee todos los nombres de archivo del archivo, concatena cada nombre de archivo con el nombre del archivo y luego calcula la suma de verificaci√≥n. Por ejemplo, para un archivo llamado *myarchive.phar* que contiene archivos *index.php* y *componentes/hello.php*, la clase Phar calcula sumas de verificaci√≥n de dos cadenas: *myarchive.pharindex.php* y *myarchive.pharcomponents/hello.php*.

La raz√≥n por la que los autores lo implementaron de esta manera no es importante aqu√≠; lo importante es *c√≥mo* lo implementaron. Hasta 2015, esta operaci√≥n se realizaba mediante la siguiente funci√≥n (ver el antiguo [c√≥digo fuente PHP](https://git.php.net/?p=php-src.git;a=blob;f=ext/phar/phar_internal.h;h=fcfc86457d623350b93e88ab2438a07093bdde86) ):

```c
void phar_set_inode(phar_entry_info *entry TSRMLS_DC) 
{
    char tmp[MAXPATHLEN];
    int tmp_len;

    tmp_len = entry->filename_len + entry->phar->fname_len;

    memcpy(tmp, entry->phar->fname, entry->phar->fname_len);
    memcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);

    entry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len);
}
```

Como puede ver, esta funci√≥n crea una matriz char de llamados tmp. Primero, el nombre del archivo phar (en nuestro ejemplo, *myarchive.phar* ) se copia en esta matriz usando el siguiente comando:

```c
memcpy(tmp,entry->phar->fname,entry->phar->fname_len);
```

En este comando:

- El primer argumento, tmpes un destino donde se deben copiar los bytes.
- El segundo argumento, entry->phar->fname, es una fuente desde donde se deben copiar los bytes; en nuestro caso, el nombre del archivo ( *myarchive.phar* ).
- El tercer argumento, entry->phar->fname_lenes una cantidad de bytes que deben copiarse; en nuestro caso, es la longitud (en bytes) del nombre del archivo comprimido.

La funci√≥n copia el nombre del archivo (en nuestro ejemplo, *index.php* o *componentes/hello.php* ) en la tmpmatriz de caracteres usando el siguiente comando:

```c
memcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);
```

En este comando:

- El primer argumento, tmp + entry->phar->fname_lenes un destino donde se deben copiar los bytes; en nuestro caso, es una ubicaci√≥n en la tmpmatriz justo despu√©s del final del nombre del archivo.
- El segundo argumento, entry->filenamees una fuente desde donde se deben copiar los bytes.
- El tercer argumento, entry->filename_lenes una cantidad de bytes que deben copiarse.

Luego zend_get_hash_valuese llama a la funci√≥n para calcular el c√≥digo hash. Observe c√≥mo se declara el tama√±o del b√∫fer:

`char tmp[MAXPATHLEN];`

Tiene un tama√±o de MAXPATHLEN, que es una constante definida como la longitud m√°xima de una ruta del sistema de archivos en la plataforma actual. Los autores asumieron que si concatenan el nombre del archivo con el nombre de un archivo dentro del archivo, nunca exceder√°n la longitud de ruta m√°xima permitida. En situaciones normales, este supuesto se cumple. Sin embargo, si el atacante prepara un archivo con nombres inusualmente largos, es inminente un desbordamiento del b√∫fer.

La funci√≥n phar_set_inode provocar√° un desbordamiento en la matriz tmp. Un atacante puede usar esto para bloquear PHP (provocando una denegaci√≥n de servicio) o incluso hacer que ejecute c√≥digo malicioso. El problema es similar a nuestro ejemplo simple de arriba: el programador cometi√≥ un simple error, confi√≥ demasiado en la entrada del usuario y asumi√≥ que los datos siempre cabr√≠an en un b√∫fer de tama√±o fijo. Afortunadamente, esta vulnerabilidad fue [descubierta en 2015 y solucionada](https://git.php.net/?p=php-src.git;a=commitdiff;h=f59b67ae50064560d7bfcdb0d6a8ab284179053c) .

### Consecuencias

- Categor√≠a: Disponibilidad: los desbordamientos del b√∫fer generalmente provocan fallos. Son posibles otros ataques que provoquen falta de disponibilidad, incluido poner el programa en un bucle infinito.
- Control de acceso (procesamiento de instrucciones): los desbordamientos del b√∫fer a menudo se pueden utilizar para ejecutar c√≥digo arbitrario, que generalmente est√° fuera del alcance de la pol√≠tica de seguridad impl√≠cita de un programa.
- Otro: cuando la consecuencia es la ejecuci√≥n de c√≥digo arbitrario, esto a menudo puede usarse para subvertir cualquier otro servicio de seguridad.

### Periodo de exposici√≥n

- Especificaci√≥n de requisitos: Se podr√≠a optar por utilizar un lenguaje que no sea susceptible a estos problemas.
- Dise√±o: Se podr√≠an introducir tecnolog√≠as de mitigaci√≥n, como bibliotecas de cadenas seguras y abstracciones de contenedores.
- Implementaci√≥n: muchos errores l√≥gicos pueden provocar esta condici√≥n. Puede verse exacerbado por la falta o el mal uso de tecnolog√≠as de mitigaci√≥n.

### Ambientes afectados

Casi todos los servidores web, servidores de aplicaciones y entornos de aplicaciones web conocidos son susceptibles a desbordamientos de b√∫fer, con la excepci√≥n notable de los entornos escritos en lenguajes interpretados como Java o Python, que son inmunes a estos ataques (excepto los desbordamientos en el propio Interpretor).

### Plataforma

- Idiomas: C, C++, Fortran, Ensamblador
- Plataformas operativas: Todas, aunque se podr√°n implementar medidas preventivas parciales, dependiendo del entorno.

**C√≥mo determinar si eres vulnerable**

Para productos de servidor y bibliotecas, mant√©ngase actualizado con los √∫ltimos informes de errores de los productos que est√° utilizando. Para el software de aplicaci√≥n personalizado, todo el c√≥digo que acepta entradas de los usuarios a trav√©s de la solicitud HTTP debe revisarse para garantizar que pueda manejar adecuadamente entradas arbitrariamente grandes.

- **Ejemplo 1**

El siguiente c√≥digo de ejemplo demuestra un desbordamiento de b√∫fer simple que a menudo es causado por el primer escenario en el que el c√≥digo depende de datos externos para controlar su comportamiento. El c√≥digo utiliza la funci√≥n get() para leer una cantidad arbitraria de datos en un b√∫fer de pila. Debido a que no hay forma de limitar la cantidad de datos le√≠dos por esta funci√≥n, la seguridad del c√≥digo depende de que el usuario ingrese siempre menos de caracteres BUFSIZE.

```c
...

char buf[BUFSIZE];

gets(buf);

...
```

Este ejemplo muestra lo f√°cil que es imitar el comportamiento inseguro de la funci√≥n `gets()` en C++ utilizando el >>operador para leer la entrada en una cadena char[].

```c
...

char buf[BUFSIZE];

cin >> (buf);

...
```

- **Ejemplo 2**

El c√≥digo de este ejemplo tambi√©n se basa en la entrada del usuario para controlar su comportamiento, pero agrega un nivel de direccionamiento indirecto con el uso de la funci√≥n de copia de memoria limitada `memcpy()`. Esta funci√≥n acepta un b√∫fer de destino, un b√∫fer de origen y la cantidad de bytes para copiar. El b√∫fer de entrada se llena mediante una llamada limitada a `read()`, pero el usuario especifica el n√∫mero de bytes que copia `memcpy()`.

```c
...

char buf[64], in[MAX_SIZE];

printf("Enter buffer contents:\n");

read(0, in, MAX_SIZE - 1);

printf("Bytes to copy:\n");

scanf("%d", &bytes);

memcpy(buf, in, bytes);

...
```

> **Nota:** Este tipo de vulnerabilidad de desbordamiento del b√∫fer (donde un programa lee datos y luego conf√≠a en un valor de los datos en operaciones de memoria posteriores sobre los datos restantes) ha aparecido con cierta frecuencia en bibliotecas de procesamiento de im√°genes, audio y otros archivos.

- **Ejemplo 3**

Este es un ejemplo del segundo escenario en el que el c√≥digo depende de propiedades de los datos que no se verifican localmente. En este ejemplo, una funci√≥n denominada `lccopy()` toma una cadena como argumento y devuelve una copia de la cadena asignada al mont√≥n con todas las letras may√∫sculas convertidas a min√∫sculas. La funci√≥n realiza una verificaci√≥n sin l√≠mites en su entrada porque espera que str siempre sea menor que BUFSIZE. Si un atacante pasa por alto las comprobaciones en el c√≥digo que llama a `lccopy()`, o si un cambio en ese c√≥digo hace que la suposici√≥n sobre el tama√±o de str sea falsa, entonces `lccopy()` se desbordar√° buf con la llamada ilimitada a `strcpy()`.

```c
char *lccopy(const char *str) {
    char buf[BUFSIZE];
    char *p;

    strcpy(buf, str);

    for (p = buf; *p; p++) {
        if (isupper(*p)) {
            *p = tolower(*p);
        }
    }

    return strdup(buf);
}
```

- **Ejemplo 4**

El siguiente c√≥digo demuestra el tercer escenario en el que el c√≥digo es tan complejo que su comportamiento no se puede predecir f√°cilmente. Este c√≥digo proviene del popular decodificador de im√°genes libPNG, que es utilizado por una amplia gama de aplicaciones, incluidas Mozilla y algunas versiones de Internet Explorer.

El c√≥digo parece realizar la verificaci√≥n de l√≠mites de manera segura porque verifica el tama√±o de la longitud variable, que luego usa para controlar la cantidad de datos copiados por `png_crc_read()`. Sin embargo, inmediatamente antes de probar la longitud, el c√≥digo realiza una verificaci√≥n png_ptr->modey, si esta verificaci√≥n falla, se emite una advertencia y el procesamiento contin√∫a. Debido a que la longitud se prueba en un bloque else if, la longitud no se probar√° si la primera verificaci√≥n falla y se usa ciegamente en la llamada a `png_crc_read()`, lo que potencialmente permite un desbordamiento del b√∫fer de pila.

Aunque el c√≥digo de este ejemplo no es el m√°s complejo que hemos visto, demuestra por qu√© se debe minimizar la complejidad en el c√≥digo que realiza operaciones de memoria.

```c
if (!(png_ptr->mode & PNG_HAVE_PLTE)) {
    /* Deber√≠a ser un error, pero podemos solucionarlo. */
    png_warning(png_ptr, "Missing PLTE before tRNS");
} else if (length > (png_uint_32)png_ptr->num_palette) {
    png_warning(png_ptr, "Incorrect tRNS chunk length");
    png_crc_finish(png_ptr, length);
    return;
}

...

png_crc_read(png_ptr, readbuf, (png_size_t)length);
```

- **Ejemplo 5**

Este ejemplo tambi√©n demuestra el tercer escenario en el que la complejidad del programa lo expone a desbordamientos del b√∫fer. En este caso, la exposici√≥n se debe a la interfaz ambigua de una de las funciones y no a la estructura del c√≥digo (como fue el caso en el ejemplo anterior).

La `getUserInfo()` funci√≥n toma un nombre de usuario especificado como una cadena multibyte y un puntero a una estructura para informaci√≥n del usuario, y completa la estructura con informaci√≥n sobre el usuario. Dado que la autenticaci√≥n de Windows utiliza Unicode para los nombres de usuario, el argumento del nombre de usuario primero se convierte de una cadena multibyte a una cadena Unicode. Luego, esta funci√≥n pasa incorrectamente el tama√±o en unicodeUser bytes en lugar de caracteres.

Por lo tanto, la llamada a `MultiByteToWideChar()` puede escribir hasta (UNLEN+1)*sizeof(WCHAR)caracteres anchos, o (UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR)bytes, en la matriz unicodeUser, que solo tiene (UNLEN+1)*sizeof(WCHAR)bytes asignados. Si la cadena del nombre de usuario contiene m√°s de UNLENcaracteres, la llamada a `MultiByteToWideChar()` desbordar√° el b√∫fer unicodeUser.

Claro, aqu√≠ tienes el fragmento de c√≥digo ordenado en Markdown:

```c
void getUserInfo(char *username, struct _USER_INFO_2 info) {

    WCHAR unicodeUser[UNLEN+1];

    MultiByteToWideChar(CP_ACP, 0, username, -1, unicodeUser, sizeof(unicodeUser));

    NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&info);

}
```

## Ataque de desbordamiento de b√∫fer

Los errores de desbordamiento de b√∫fer se caracterizan por la sobrescritura de fragmentos de memoria del proceso, que nunca debieron haber sido modificados de forma intencionada o no. La sobrescritura de valores de IP (puntero de instrucci√≥n), BP (puntero base) y otros registros provoca excepciones, fallas de segmentaci√≥n y otros errores. Generalmente estos errores finalizan la ejecuci√≥n de la aplicaci√≥n de forma inesperada. Los errores de desbordamiento del b√∫fer ocurren cuando operamos con b√∫feres de tipo char.

Los desbordamientos del b√∫fer pueden consistir en desbordar la pila [Stack overflow] o desbordar el mont√≥n [Heap overflow]. No distinguimos entre estos dos en este art√≠culo para evitar confusiones. Los siguientes ejemplos est√°n escritos en lenguaje C bajo el sistema GNU/Linux en arquitectura x86.

- **Ejemplo 1**

```c
#include <stdio.h>

int main(int argc, char **argv) {
    char buf[8]; // buffer para ocho caracteres

    gets(buf); // lee de stdio (¬°funci√≥n sensible!)

    printf("%s", buf); // imprime los datos almacenados en buf

    return 0; // 0 como valor de retorno
}
```

Esta aplicaci√≥n muy simple lee de la entrada est√°ndar una matriz de caracteres y la copia en el b√∫fer del tipo char. El tama√±o de este b√∫fer es de ocho caracteres. Despu√©s de eso, se muestra el contenido del b√∫fer y la aplicaci√≥n se cierra.

**Compilaci√≥n del programa:**

```c
user@spin ~/inzynieria $ gcc bo-simple.c -o bo-simple

/tmp/ccECXQAX.o: In function `main':
bo-simple.c:(.text+0x17): warning: the `gets' function is dangerous and should not be used.

At this stage, even the compiler suggests that the gets() function is not safe.
```

**Ejemplo de uso:**

```c
user@spin ~/inzynieria $ ./bo-simple // inicio del programa

1234 // introducimos la cadena "1234" desde el teclado

1234 // el programa imprime el contenido del buffer

user@spin ~/inzynieria $ ./bo-simple // inicio del programa

123456789012 // introducimos "123456789012"

123456789012 // contenido del buffer "buf" ?!?!!

Fallo de segmentaci√≥n // informaci√≥n sobre el fallo de segmentaci√≥n de memoria
```

Logramos (des)afortunadamente ejecutar la operaci√≥n defectuosa del programa y provocamos que salga de manera anormal.

### An√°lisis del problema

El programa llama a una funci√≥n que opera en el b√∫fer de tipo char y no realiza comprobaciones para evitar que se desborde el tama√±o asignado a este b√∫fer. Como resultado, es posible almacenar intencionalmente o no m√°s datos en el b√∫fer, lo que provocar√° un error. Surge la siguiente pregunta: El buffer almacena s√≥lo ocho caracteres, entonces ¬øpor qu√© la funci√≥n `printf()` muestra doce? La respuesta proviene de la organizaci√≥n de la memoria de procesos. Cuatro caracteres que desbordaron el b√∫fer tambi√©n sobrescriben el valor almacenado en uno de los registros, que era necesario para el retorno correcto de la funci√≥n. La continuidad de la memoria result√≥ en la impresi√≥n de los datos almacenados en esta √°rea de la memoria.

- **Ejemplo 2**

```c
#include <stdio.h>
#include <string.h>

void doit(void) {
    char buf[8];
    gets(buf);
    printf("%s", buf);
}

int main(void) {
    printf("So... The End...\n");
    doit();
    printf("or... maybe not?\n");
    return 0;
}
```

Este ejemplo es an√°logo al primero. Adem√°s, antes y despu√©s de la funci√≥n `doit()`, tenemos dos llamadas a la funci√≥n `printf()`.

### Compilaci√≥n:

```bash
user@dojo-labs ~/owasp/buffer_overflow $ gcc example02.c -o example02 -ggdb
```

Advertencia:

```bash
/tmp/cccbMjcN.o: In function `doit':
/home/user/owasp/buffer_overflow/example02.c:8: warning: the `gets' function is dangerous and should not be used.
```

### Ejemplo de Uso:

```bash
user@dojo-labs ~/owasp/buffer_overflow $ ./example02
```

Salida:

```bash
So... The End...
TEST  // user data on input
TEST  // print out stored user data
or... maybe not?
```

El programa entre las dos llamadas `printf()` definidas muestra el contenido del b√∫fer, que se llena con los datos ingresados ‚Äã‚Äãpor el usuario.

```bash
user@dojo-labs ~/owasp/buffer_overflow $ ./example02

So... The End...

TEST123456789

TEST123456789

Segmentation fault
```

Debido a que se defini√≥ el tama√±o del buffer (char buf[8]) y se llen√≥ con trece caracteres de tipo char, el buffer se desbord√≥. Si nuestra aplicaci√≥n binaria est√° en formato ELF, entonces podemos usar un programa objdump para analizarla y encontrar la informaci√≥n necesaria para explotar el error de desbordamiento del b√∫fer. A continuaci√≥n se muestra el resultado producido por objdump. A partir de esa salida podemos encontrar direcciones, donde se llama a `printf()` (0x80483d6 y 0x80483e7).

```bash
user@dojo-labs ~/owasp/buffer_overflow $ objdump -d ./example02
```

Salida:

```
080483be <main>:
 80483be: 8d 4c 24 04 lea 0x4(%esp),%ecx
 80483c2: 83 e4 f0 and $0xfffffffff0,%esp
 80483c5: ff 71 fc pushl 0xfffffffffc(%ecx)
 80483c8: 55 push %ebp
 80483c9: 89 e5 mov %esp,%ebp
 80483cb: 51 push %ecx
 80483cc: 83 ec 04 sub $0x4,%esp
 80483cf: c7 04 24 bc 84 04 08 movl $0x80484bc,(%esp)
 80483d6: e8 f5 f5 fe ff ff ff call 80482d0 <puts@plt>
 80483db: e8 c0 f0 ff ff ff ff call 80483a0 <doit>
 80483e0: c7 04 24 cd 84 04 08 movl $0x80484cd,(%esp)
 80483e7: e8 e4 fe ff ff ff call 80482d0 <puts@plt>
 80483ec: b8 00 00 00 00 00 00 mov $0x0,%eax
 80483f1: 83 c4 04 add $0x4,%esp
 80483f4: 59 pop %ecx
 80483f5: 5d pop %ebp
 80483f6: 8d 61 fc lea 0xfffffffffc(%ecx),%esp
 80483f9: c3 ret
 80483fa: 90 nop
 80483fb: 90 nop
```

Si la segunda llamada a `printf()` informar√≠a al administrador sobre el cierre de sesi√≥n del usuario (por ejemplo, sesi√≥n cerrada), entonces podemos intentar omitir este paso y finalizar sin la llamada a `printf()`.

```bash
user@dojo-labs ~/owasp/buffer_overflow $ perl -e 'print "A "x12 . "\xf9\x83\x04\x08"' | ./example02
```

Salida:

```
So... The End...
AAAAAAAAAAAAAAAAAAu*.
Segmentation fault
```

La aplicaci√≥n finaliz√≥ su ejecuci√≥n con fallo de segmentaci√≥n, pero la segunda llamada a `printf()` no tuvo cabida. Algunas palabras de explicaci√≥n:

perl -e 'print ‚ÄúA‚Äùx12 .‚Äù\xf9\x83\x04\x08‚Äù' - imprimir√° doce caracteres ‚ÄúA‚Äù y luego cuatro caracteres, que de hecho son una direcci√≥n de la instrucci√≥n que queremos ejecutar. ¬øPor qu√© doce?

```bash
8 // Size of buf (char buf[8])

+ 4 // Four additional bytes for overwriting stack stack frame pointer

----

12
```

### An√°lisis del problema:

La cuesti√≥n es la misma que en el primer ejemplo. No hay control sobre el tama√±o del buffer copiado en el previamente declarado. En este ejemplo, sobrescribimos el registro EIP con la direcci√≥n 0x080483f9, que de hecho es una llamada a ret en la √∫ltima fase de la ejecuci√≥n del programa.

### ¬øC√≥mo utilizar los errores de desbordamiento del b√∫fer de una forma diferente?

Generalmente, la explotaci√≥n de estos errores puede conducir a:

- aplicaci√≥n DoS
- reordenar la ejecuci√≥n de funciones
- ejecuci√≥n de c√≥digo (si podemos inyectar el c√≥digo shell, descrito en el documento separado)

### ¬øC√≥mo se cometen los errores de desbordamiento del b√∫fer?

Este tipo de errores son muy f√°ciles de cometer. Durante a√±os fueron la pesadilla de un programador. El problema radica en las funciones nativas de C, a las que no les importa realizar comprobaciones adecuadas de la longitud del b√∫fer. A continuaci√≥n se muestra la lista de dichas funciones y, si existen, sus equivalentes seguros:

Claro, aqu√≠ est√° la traducci√≥n al espa√±ol:

- `gets()` -> `fgets()` - leer caracteres
- `strcpy()` -> `strncpy()` - copiar el contenido del buffer
- `strcat()` -> `strncat()` - concatenaci√≥n de buffer
- `sprintf()` -> `snprintf()` - llenar el b√∫fer con datos de diferentes tipos
- `(f)scanf()` - leer desde STDIN
- `getwd()` - volver al directorio de trabajo
- `realpath()` - devolver la ruta absoluta (completa)

Utilice funciones equivalentes seguras, que verifiquen la longitud de los buffers, siempre que sea posible. A saber:

1. gets() -\> fgets()
2. strcpy() -\> strncpy()
3. strcat() -\> strncat()
4. sprintf() -\> snprintf()

Aquellas funciones que no tienen equivalentes seguros deben reescribirse implementando comprobaciones seguras. El tiempo dedicado a ello se beneficiar√° en el futuro. Recuerda que tienes que hacerlo s√≥lo una vez. Utilice compiladores, que sean capaces de identificar funciones inseguras, errores l√≥gicos y comprobar si la memoria se sobrescribe cuando y donde no deber√≠a estar.

### Explotaciones de aplicaciones web: c√≥mo los piratas inform√°ticos aprovechan las vulnerabilidades de desbordamiento del b√∫fer

En el navegador web **Firefox**, busque la siguiente URL:

[https://demo.testfire.net](https://demo.testfire.net/)

Esta es una aplicaci√≥n web deliberadamente vulnerable que se utiliza con fines educativos y de prueba. Seleccione Iniciar sesi√≥n e inicie sesi√≥n en la aplicaci√≥n utilizando las siguientes credenciales:

Nombre de usuario ‚Üí admin

Contrase√±a ‚Üí admin

Haga clic en el enlace **Feedback** junto a la barra de b√∫squeda en la esquina superior derecha.

![Buffer 5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer5.png?raw=true)

La aplicaci√≥n no realiza una verificaci√≥n de longitud y es vulnerable a ataques de desbordamiento.

Si un atacante env√≠a m√°s datos de los que el b√∫fer puede contener, el exceso de datos se desbordar√° hacia √°reas de memoria adyacentes, sobrescribiendo potencialmente datos cr√≠ticos o el c√≥digo de la aplicaci√≥n. Esto puede provocar un comportamiento impredecible y potencialmente malicioso.

Scripting para Red Team.

# LOLBAS: colecci√≥n de scripts para ataques en Red Team

Distintos investigadores y hackers se han propuesto construir una lista de **[LOLBins](https://lolbas-project.github.io/)**, programas leg√≠timos de los cuales se puede abusar para evitar la seguridad y evadir la detecci√≥n. Estos programas pueden serr utilizados por equipos de Red Team o directamente por atacantes en malware, APTs y en situaciones de escalamiento de privilegios y ataques laterales.

La confianza es uno de los pilares clave en los que se basa la seguridad de la informaci√≥n. En √∫ltima instancia, lo que determina qui√©n tiene acceso a qu√©, qu√© aplicaciones pueden ejecutarse y cu√°les no. ¬øPero qu√© pasa cuando se abusa de esa confianza? Por ejemplo, cuando aplicaciones autorizadas y confiables son utilizadas por atacantes.

Los LOLBins son un buen ejemplo de la explotaci√≥n de confianza: son binarios "confiables" que un atacante puede usar para realizar acciones distintas de aquellas para las que originalmente fueron dise√±ados. Como tal, los LOLBins hacen posible que los atacantes eviten las contramedidas defensivas, como la inclusi√≥n en la lista blanca de aplicaciones, el monitoreo de seguridad y el software antivirus con una menor posibilidad de ser detectados. Un ejemplo, se puede [usar el comando print.exe](https://www.youtube.com/watch?v=nPBcSP8M7KE) para copiar un archivo a un Alternate Data Stream (ADS) y luego ejecutarlo.

![Buffer 6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer6.png?raw=true)

## [LOLBAS](https://github.com/LOLBAS-Project/LOLBAS) ("Living Off the Land Binaries and Scripts").

Actualmente, hay m√°s de 130 LOLBins, LOLLibs y LOLScripts en la lista, que van desde la herramienta de transferencia de datos leg√≠tima de Microsoft *Bitsadmin.exe* hasta *print.exe*. La lista incluye programas que han documentado un potencial de abuso, as√≠ como una variedad de programas que ya se han convertido en herramientas favoritas para recuperar cargas √∫tiles de malware durante ataques del mundo real, incluidos *mshta.exe, certutil.exe* y *regsvr32.exe*.

*Tener una buena documentaci√≥n sobre estos binarios y scripts puede ayudar a todos a prevenir ataques al bloquear activamente su ejecuci√≥n. Si sabes que algo puede ser usado para el mal, hace que el trabajo sea mucho m√°s f√°cil cuando buscas ataques e intentas prevenirlos. Despu√©s de todo, los actores de amenaza de persistencia avanzada (APT) ya est√°n usando estos binarios / scripts como parte de sus ataques. Por lo tanto, debemos profundizar en todos los archivos y descubrir formas inteligentes en que podamos usar esta lista antes de que lo hagan los atacantes.*

LOLBAS funciona como una lista din√°mica mantenida por la comunidad. Cualquier persona interesada en realizar una investigaci√≥n de seguridad para enviar nuevos LOLBins es alentada a hacerlo y ser reconocida por ello. La lista actual es solo el comienzo y se espera poder proporcionar una lista de b√∫squeda en un formato de base de datos para el servicio, asignarla al marco [MITRE ATT & CK](https://attack.mitre.org/wiki/Main_Page) y agregar m√°s datos en cada registro de LOLBin y LOLScript, incluida la informaci√≥n sobre su detecci√≥n y las t√©cnicas de bloqueo relevantes.

### GTFOBins

[GTFOBins](https://gtfobins.github.io/) es una lista inspirada en LOBAS pero con binarios de Unix/Linux que pueden ser explotados por un atacantes para saltear restricciones de seguridad locales.

### Offensive-PowerShell

[Offensive-PowerShell](https://github.com/1RicardoTavares/Offensive-PowerShell) es un repositorio de Github contiene un recopilatorio de *scripts* en Powershell para operaciones ofensivas relacionadas con tareas de Red Teaming. Se describen c√≥mo funciona cada uno y dan un peque√±o tutorial en ingl√©s sobre c√≥mo usarlos, adem√°s de decir con qu√© versiones de Windows son compatibles.

## Automatizando el Reconocimiento de un Red Team con Discover Scripts

Cuando hablamos de Red Team el alcance del mismo, no s√≥lo abarca a las tecnolog√≠as sino tambi√©n a las personas y procesos. Otra cosa que ya hemos mencionado m√°s de una vez es que, a diferencia de un pentest tradicional, el cual mucho m√°s acotado en tiempo y alcance, un servicio de red team justamente es much√≠simo m√°s amplio tanto en su ventana de tiempo de ejecuci√≥n como en su alcance ya que, entre otras cosas se trata de generar la mayor cantidad de escenarios posibles o incluso replicar campa√±as de APT conocidas, lo cual brinda como resultado un resultado mucho m√°s hol√≠stico en relaci√≥n a la postura de seguridad de una determinada compa√±√≠a o entidad.

Aclarado el contexto, est√° claro que la fase de reconocimiento en el mundo del Red Team, a diferencia justamente de un pentest tradicional, es de vital importancia. Justamente, cuando hablamos de reconocimiento, hablamos de OSINT en todos sus aspectos o lo que se suele llamar tradicionalmente como information gathering pasivo y activo. Dado que justamente en un ejercicio de red team se suele modelar con much√≠simo m√°s tiempo un escenario de ataque.

Mientras m√°s tiempo le dediquemos a esta fase m√°s van a ser los vectores de ataque que se puedan utilizar para realizar un ataque exitoso, desde bucket de AWS, servicios que no necesariamente deber√≠an estar expuestos (RDP por ejemplo), paneles de gesti√≥n web, posibles cuentas de github en donde los desarrolladores de la compa√±√≠a guardan c√≥digo de la misma, etc. En un ejercicio de Red Team todo y absolutamente todo lo que se encuentre puede ser un expuesto a vulnerar.

Veremos una herramienta de tipo ¬´all in one¬ª que no suele realmente ser muy conocida pero que lleva varios a√±os La herramienta se llama ¬´Discover Scripts¬ª de Lee Baird @discoverscripts ([https://github.com/leebaird/discover](https://github.com/leebaird/discover)) y antes era conocida c√≥mo Backtrack Scripts, se imaginar√°n porque la misma era parte de la suite de herramientas de Backtrack Kali Linux antes de convertirse en Kali Linux.

Esta herramienta o conjunto de scripts, yo la uso mucho en lo particular y lo interesante es que tambi√©n se puede usarse para otras cuestiones no tan relativas a OSINT sino que a trav√©s de la misma se pueden disparar otras tools como Recon-NG o por ejemplo Nikto para un escaneo web.

Discover Scripts, c√≥mo su nombre indica, es un conjunto de scripts que disparan acciones o herramientas. Utiliza herramientas c√≥mo ¬´dnsrecon, goofile, goog-mail, goohost, theharvester, metasploit, urlcrazy, whois, wikto y varias otras.

## Instalaci√≥n

Para instalarla solo deberemos clonar el repositorio desde su sitio oficial git clone.

![Buffer 7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer7.png?raw=true)

Una vez finalizada la instalaci√≥n deberemos movernos al directorio /opt/discover que es d√≥nde se instala por default. Lo primero que deberemos hacer ahora es correr el script bash de actualizaci√≥n de la herramienta el cual ./update.sh.

![Buffer 8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer8.png?raw=true)

Al disparar el script la herramienta empezar√° a instalar no solamente los componentes necesarios, sino que, adem√°s, la misma instalar√° muchas otras herramientas de las que se vale para hacer las diferentes b√∫squedas que hace e incluso herramientas ofensivas como impacket y muchas otras. El proceso de instalaci√≥n lleva un tiempo largo con lo cual sugerimos un poco de paciencia e ir siguiendo el paso a paso de la instalaci√≥n con un caf√©.

## Ejecuci√≥n de la herramienta

Una vez finalizada 100% la instalaci√≥n y actualizaci√≥n de todos los componentes, y est√°ndo parados en el directorio de la misma ya podemos empezar a utilizar la herramienta, para hacerlo s√≥lo debemos correr el script ./discover.sh con el comando sudo por delante, excepto que estemos trabajando con la cuenta de root en forma directa.

![Buffer 9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer9.png?raw=true)

Al disparar el script nos aparecer√° la siguiente pantalla:

![Buffer 10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer10.png?raw=true)

C√≥mo podemos ver la herramienta tiene varias opciones que no solamente est√°n limitadas al ¬´Reconocimiento¬ª sino que puede invocar escaneos de puertos (port scanning) con nmap o incluso escaneos web con Nikto, por s√≥lo mencionar algunas de las opciones.

Recomendados mirar el sitio web de github de Lee Baird para ver la documentaci√≥n del uso ya que es bastante extensivo todo lo que se puede realizar con la herramienta. En nuestro caso, y dado que estamos hablando de ¬´Reconocimiento¬ª en el marco de un Red Team Engagement, trabajaremos solamente con la opci√≥n de ¬´RECON¬ª.

Entonces vamos a marcar dentro de RECON la opci√≥n 1 llamada Domain, para eso solo tipeamos el n√∫mero 1 en la consola y le damos enter y nos aparecer√° el siguiente men√∫ que se observa:

![Buffer 11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer11.png?raw=true)

En este caso, vamos a trabajar con la opci√≥n 1 llamada ¬´Passive¬ª dado que queremos recolectar la mayor cantidad de informaci√≥n en forma 100% pasiva sin que la actividad en s√≠, pueda ser detectada de alguna forma u otra.

> **NOTA**: Si tipeamos la opci√≥n ¬´Active¬ª la b√∫squeda utilizar√° m√≥dulos de herramientas c√≥mo dnsrecon, WAF00W, traceroute, Whatweb, and recon-ng, los cuales no son pasivos y podr√≠an detectar nuestra actividad y que nuestra IP sea baneada. Vamos a tomar un dominio v√°lido ya que, en principio, no estamos haciendo absolutamente nada m√°s que recolectar informaci√≥n. Para ellos voy a usar el dominio de [https://www.nintendo.com/](https://www.nintendo.com/).

Para ello entonces, luego de seleccionar la opci√≥n 1 de ¬´Passive¬ª como ya dijimos antes, nos va a pedir que ingresemos el nombre de la compa√±√≠a (Esto sirve para el nombre del reporte que la herramienta va a crear una vez que termine) y por otro lado el nombre del domino, el cual deber√° ingresarse con el formato ¬´dominio.com¬ª es decir sin www ni http. En nuestro caso ¬´Nintendo.com¬ª.

![Buffer 12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer12.png?raw=true)

Si prestamos atenci√≥n podemos ver la imagen que la herramienta nos dice que va a utilizar entre otras herramientas ARIN, DNSRecon, dnstwist, TheHarvester, recon-ng, y varias m√°s e inclusive nos indica que si queremos generar APIs para maximizar el resultado lo hagamos, lo cual recomendamos tanto para BING, Google CSE, Shodan, Censys, etc.

Las APIs que hayamos generado se pueden cargar en las diferentes herramientas que se utilizan, en este caso por sobre todo recon-ng y theharvester, con lo cual las APIs se cargar√≠an de la siguiente manera:

> En recon-ng se puede usar el comando ¬´show keys¬ª y luego ingresar las APIs con el comando ¬´keys add¬ª, ejemplo: ¬´keys add bing_api <valor de api>¬ª.

Una vez que le damos ¬´enter¬ª la herramienta empieza a correr con lo cual ac√° recomendamos otro cafecito. Veremos que arranca corriendo y haciendo diferentes querys a trav√©s de variadas tools:

![Buffer 13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer13.png?raw=true)

Una vez que la herramienta termina de trabajar nos va a decir ¬´Scan Complete¬ª y nos va a mostrar en que ruta se guarda el archivo, en este caso dentro de /root/data/Nintendo.com que es el dominio que especificamos.

![Buffer 14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer14.png?raw=true)

Desde una consola como root entonces disparamos el Firefox al archivo index.html generado dentro de /root/data/Nintendo.com/ y veremos en el navegador lo siguiente:

![Buffer 15](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer15.png?raw=true)

Podemos observar en la pantalla que se nos generan varios tabs en d√≥nde tenemos el de ¬´Home¬ª, ¬´General¬ª, ¬´DNS¬ª, ¬´Domain¬ª, ¬´File¬ª, ¬´Reports¬ª y ¬´Web¬ª. En general vamos a poder encontrar listado de usuarios y correos electr√≥nicos que despu√©s se puede usar dicho listado para crear un diccionario customizado aunque hay que validar mucha de esta informaci√≥n.

Sugerimos que esto se haga directamente buscando informaci√≥n en el sitio oficial de la empresa u entidad que se est√© mirando en ese momento como a trav√©s de t√©cnicas de scrapping por ejemplo de Linkedin de los usuarios de dicha compa√±√≠a (Cosa que veremos m√°s adelante en otra entrada). En el caso de DNS es d√≥nde empezamos a ver los mapas y registros de DNS perteneciente a la empresa o entidad, c√≥mo por ejemplo se puede ver a continuaci√≥n.

![Buffer 16](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer16.png?raw=true)

![Buffer 17](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer17.png?raw=true)

Tambi√©n podremos ver dentro de este contexto otros dominios DNS registrados por la compa√±√≠a, en este caso utilizados como mail corporativo.

![Buffer 18](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer18.png?raw=true)

Tambi√©n los sub dominios, que en este caso particular podemos ver que son muchos dados que es una empresa o compa√±√≠a extremadamente grande.

En el tab de ¬´Files¬ª podemos ver que la herramienta nos muestra todos los archivos que est√°n p√∫blicos, en este caso seleccionamos la opci√≥n PDF de entre todos los que nos brinda. Esto es extremadamente √∫til ya que podr√≠amos complementariamente bajar muchos de estos archivos con herramientas c√≥mo Foca o metagoofil para poder extraer adicionalmente otros datos de utilidad a trav√©s de la metadata de los mismos.

![Buffer 19](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer19.png?raw=true)

Por √∫ltimo (Al menos en lo que este post se refiere) podemos ver tambi√©n que, cuando nos dirigimos al tab ¬´Reports¬ª se nos despliegan muchas dos opciones de las cuales una es la de ¬´Active Recon¬ª y la segunda la de ¬´Passive Recon¬ª. En este caso y dado que desde el principio s√≥lo corrimos un Passive Recon para la opci√≥n ¬´Domain¬ª, est√° ser√° la opci√≥n que se seleccionaremos. Al hacerlo veremos que nos muestra un res√∫men pormenorizado de todo lo que encontr√≥ en una forma s√∫per √∫til para seguir.

![Buffer 20](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer20.png?raw=true)

![Buffer 21](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/buffer21.png?raw=true)

## Conclusiones

Esta herramienta junto con el uso de recon-ng en forma automatizada, yo la uso mucho para recolectar informaci√≥n. C√≥mo toda herramienta de ¬´bot√≥n gordo¬ª ayuda mucho a automatizar y recolectar mucha informaci√≥n en un lapso mucho menor que la b√∫squeda meramente manual, no obst√°nte hay que recordar que:

- Muchos de los datos se deben Re validar manualmente
- Que la parte de datos de casillas de correo y de personas conviene sacarlos por otro medio o por algunos m√≥dulos espec√≠ficos de recon-ng que ya veremos m√°s adelante o mismo por scrapping.
- Que se debe utilizar si o si tanto en recon-ng c√≥mo en la herramienta de ¬´TheHarvester¬ª las APIs que ya previamente tengamos registradas (Shodan, Censys, Bing, GoogleCSE, Virustotal, etc.) ya que va a ser mucho m√°s rica la b√∫squeda que nos genere la herramienta.

Recordemos adem√°s que la herramienta puede automatizar escaneos activos, automatizar el uso de metasploit a trav√©s de m√≥dulos que invoca, automatizar escaneos web con nikto y muchas cosas m√°s ya que, adem√°s de la automatizaci√≥n de muchas de las herramientas que ya mencionamos al principio tambi√©n en el caso de su uso en Kali Linux utiliza y automatiza el ¬´Penetration Tester Framework¬ª (PTF).

Espero que les haya gustado la nota. Happy hacking!

### Recurso Bibliogr√°fico

[https://github.com/leebaird/discover](https://github.com/leebaird/discover)
