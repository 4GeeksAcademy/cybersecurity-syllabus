# SQL Injection

La inyecciÃ³n SQL es un tipo de ataque de inyecciÃ³n en el cual un atacante inserta cÃ³digo malicioso en una consulta SQL para ejecutar comandos no deseados en la base de datos. Los atacantes pueden utilizar la inyecciÃ³n de comandos para ejecutar comandos arbitrarios en el sistema, lo que podrÃ­a permitirles obtener acceso no autorizado, modificar o eliminar datos, o incluso tomar el control total del sistema. Las inyecciones a menudo se realizan a travÃ©s de campos de entrada, como formularios web, parÃ¡metros de URL o encabezados HTTP.

Los complementos de WordPress mÃ¡s Ãºtiles tienen algÃºn tipo de interacciÃ³n con la base de datos. La entrada del usuario se envÃ­a con frecuencia a la base de datos, ya sea porque necesita almacenarse en la base de datos, necesita modificar algo en la base de datos o porque se utiliza como parte de una declaraciÃ³n SELECT. Si la entrada del usuario no se valida ni se escapa correctamente, un atacante puede reemplazar esa entrada del usuario con comandos que puede enviar directamente a la base de datos.

Hay dos tipos de inyecciÃ³n SQL. Una vulnerabilidad de inyecciÃ³n SQL "clÃ¡sica" es aquella en la que la entrada del usuario sin filtrar permite a un atacante enviar comandos a la base de datos y la salida se envÃ­a de vuelta al atacante. Una vulnerabilidad de inyecciÃ³n SQL "ciega" se produce cuando el atacante puede enviar comandos a la base de datos pero en realidad no ve la salida de la base de datos.

SegÃºn el anÃ¡lisis de Wordfence las vulnerabilidades de inyecciÃ³n SQL son la segunda vulnerabilidad mÃ¡s comÃºn que se encuentra en los complementos de WordPress.

![SQL 1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql1.png?raw=true)

[https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)

CÃ³mo funciona una vulnerabilidad de inyecciÃ³n SQL clÃ¡sica

Para comprender cÃ³mo funciona una vulnerabilidad de inyecciÃ³n SQL clÃ¡sica, veamos un ejemplo de WordPress:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var("select post_title from " . $wpdb->posts . " where ID=" . $_GET['id']);
echo $title;
 |
| --- | --- |

El cÃ³digo anterior es un ejemplo de una vulnerabilidad de inyecciÃ³n SQL (SQLi). Es una vulnerabilidad de SQLi porque la entrada del usuario en $_GET['id'] se envÃ­a directamente a la base de datos sin desinfecciÃ³n ni escape. Esto permite a un atacante enviar comandos directamente a la base de datos.

Luego, la salida de la base de datos se envÃ­a directamente al navegador del usuario. Debido a que el resultado se envÃ­a al navegador, esto convierte a la vulnerabilidad en una vulnerabilidad SQLi clÃ¡sica, a diferencia de una vulnerabilidad de inyecciÃ³n SQL ciega, que se analiza a continuaciÃ³n.

Al utilizar esta vulnerabilidad, un atacante puede enviar comandos directamente a la base de datos. Estos incluyen comandos SELECT para descargar su base de datos completa, incluida la informaciÃ³n de identificaciÃ³n personal (PII) del usuario. En algunos casos, tambiÃ©n incluye comandos INSERTAR y ACTUALIZAR para crear nuevas cuentas de usuario o modificar cuentas de usuario existentes.

Corregir la vulnerabilidad anterior es relativamente fÃ¡cil. En WordPress simplemente necesita usar el mÃ©todo de preparaciÃ³n que desinfectarÃ¡ y escaparÃ¡ automÃ¡ticamente cualquier dato que envÃ­e a la base de datos. El cÃ³digo anterior se puede modificar de la siguiente manera para eliminar la vulnerabilidad SQLi:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var($wpdb->prepare("select post_title from " . $wpdb->posts . " where ID=%d", $_GET['id']));
echo $title;
 |
| --- | --- |

Tenga en cuenta que utilizamos el mÃ©todo $wpdb->prepare() para escapar de los datos que estamos enviando a la base de datos. Tiene una sintaxis similar a la funciÃ³n sprintf() que le permite utilizar marcadores de posiciÃ³n. %d es un nÃºmero entero, %f es un flotante (o decimal) y %s es una cadena (o texto). Si utiliza %s como marcador de posiciÃ³n, no necesita incluir comillas, ya que se agregan automÃ¡ticamente.

### Â¿CÃ³mo funciona una inyecciÃ³n SQL ciega?

Una vulnerabilidad de inyecciÃ³n SQL ciega se parece a la siguiente:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var("select post_title from " . $wpdb->posts . " where ID=" . $_GET['id']);
//Do something with title, but don't echo.
 |
| --- | --- |

En el ejemplo anterior, la entrada del usuario sin procesar y no desinfectada se envÃ­a directamente a la base de datos concatenando la variable $_GET['id'] directamente a la consulta SQL. Para corregir esta vulnerabilidad, simplemente usarÃ­a el mÃ©todo prepare() como se indicÃ³ anteriormente para desinfectar y escapar de cualquier entrada de la base de datos.

La diferencia aquÃ­ es que el resultado nunca se envÃ­a al navegador. Una vulnerabilidad SQLi ciega es tan grave como una vulnerabilidad SQLi normal porque, en algunos casos, un atacante puede insertar o actualizar datos fÃ¡cilmente en su base de datos. La diferencia es que resulta mÃ¡s difÃ­cil extraer datos de la base de datos porque el atacante no puede ver el resultado de la base de datos porque no estÃ¡ escrito en el navegador web.

## Ataques SQL ciegos basados â€‹â€‹en el tiempo

Generalmente, hay dos formas en que un atacante extrae datos de una base de datos mediante un ataque de inyecciÃ³n SQL ciega. El primero es utilizar un ataque basado en el tiempo. Supongamos que, utilizando la vulnerabilidad SQLi anterior, un atacante puede enviar cualquier comando a la base de datos, pero no puede ver el resultado. SÃ³lo pueden ver la pÃ¡gina web resultante.

Un atacante podrÃ­a hacerle a la base de datos una pregunta como â€œÂ¿La primera letra de la primera cuenta de administrador comienza con 'a'? Si es asÃ­, duerme 5 segundos y si no es asÃ­, no duermas nada. Si la pÃ¡gina web tarda menos de 5 segundos en generarse y regresar al navegador web, saben que la cuenta de administrador no comienza con la letra 'a' y pasan a la siguiente letra, 'b', y preguntan. la misma pregunta.

Con esta tÃ©cnica, un atacante puede lanzar un ataque basado en el tiempo en un sitio web y determinar los nombres de las cuentas de administrador y puede extraer contraseÃ±as de usuario con hash.

El SQL real enviado a la base de datos podrÃ­a verse similar al siguiente:

| 1
2
3
4
5
6 | select post_title from wp_posts where ID=1
Â Â union select IF(
Â Â Â Â substring(wp_users.user_login,1,1)='a',
Â Â Â Â BENCHMARK(5000000,ENCODE('blah','asdf')),
Â Â Â Â null)
Â Â from wp_users where ID=1
 |
| --- | --- |

Lo que dice este SQL es "seleccione el tÃ­tulo de la publicaciÃ³n donde el ID de la publicaciÃ³n es 1, pero combine en una consulta que llevarÃ¡ mucho tiempo si suponemos que la cuenta de usuario con ID 1 (que generalmente es una cuenta de administrador) tiene la letra ' a' como primera letra del nombre de usuarioâ€.

Cuando se ejecuta esta consulta, si la pÃ¡gina tarda mucho en cargarse, el atacante ha adivinado correctamente la primera letra del nombre de usuario del administrador. Luego pueden pasar a las letras dos y tres hasta que tengan su nombre de usuario de administrador. Una vez que lo tengan, pueden extraer su contraseÃ±a hash de administrador, su correo electrÃ³nico de administrador, cualquier correo electrÃ³nico de usuario o cualquier dato que deseen, siempre que se tomen el tiempo suficiente para ejecutar el ataque.

Recuerde, estos ataques son automatizados y las conjeturas incorrectas no toman tiempo, por lo que los datos se pueden extraer con relativa rapidez utilizando esta tÃ©cnica.

Ataques de inyecciÃ³n SQL ciegos basados â€‹â€‹en contenido

Un ataque de inyecciÃ³n SQL ciega basado en contenido es otra forma en que un atacante extrae datos de una base de datos cuando no puede ver la salida de la base de datos.

Si la consulta que genera el contenido es la siguiente (recuerde, el resultado de la consulta no se envÃ­a al usuario)

| 1 | select post_status from wp_posts where ID=1 |

Supongamos que el valor '1' anterior es un parÃ¡metro de consulta sin filtrar agregado a la consulta de la base de datos como en nuestro ejemplo anterior. Por tanto, un atacante puede controlar todo el texto despuÃ©s de 'ID='.

Un atacante puede agregar lo siguiente a la consulta para verificar que si incluye una condiciÃ³n falsa, verÃ¡ generado contenido inusual:

| 1 | select post_status from wp_posts where ID=1 and 1=2 |

Obviamente, 1 no es igual a 2, por lo que en la consulta anterior la base de datos devolverÃ¡ un conjunto de resultados vacÃ­o. El atacante examinarÃ¡ la pÃ¡gina resultante y si es una pÃ¡gina sin contenido o un mensaje de error que dice algo como "sin contenido", sabrÃ¡ cÃ³mo se ve la respuesta de una consulta vacÃ­a con una condiciÃ³n falsa. Luego, el atacante puede incluir algo como lo siguiente:

| 1
2
3 | select post_status from wp_posts where ID=1
Â Â and (select ID from wp_users where
Â Â user_login='admin' and ID=1)
 |
| --- | --- |

La consulta anterior estarÃ¡ vacÃ­a si el usuario de la base de datos con ID 1 no tiene el nombre de usuario 'admin'. Sin embargo, devolverÃ¡ un resultado normal no vacÃ­o al navegador si el usuario con ID 1 tiene el nombre de usuario "admin". Con esta tÃ©cnica, un atacante puede extraer datos de una base de datos comprobando si hay respuestas vacÃ­as y no vacÃ­as de la aplicaciÃ³n.

Otro ejemplo de una consulta de inyecciÃ³n SQL ciega basada en contenido es:

| 1
2
3 | select post_status from wp_posts where
Â Â ID=1 and (select 1 from wp_users where
Â Â substring(user_pass,1,1) = 'a' and ID=1) |
| --- | --- |

La consulta anterior verificarÃ¡ si la primera letra de la contraseÃ±a hash para el usuario con ID 1 es una 'a'. Con esta tÃ©cnica, un atacante puede revisar cada carÃ¡cter y extraer la contraseÃ±a hash de las cuentas de administrador.

## Consecuencias

> Las consecuencias de una inyecciÃ³n SQL pueden incluir:
> 
- **PÃ©rdida o alteraciÃ³n de datos:** el atacante puede eliminar, modificar o extraer informaciÃ³n de la base de datos.
- **Inestabilidad del sistema:** el cÃ³digo malicioso puede causar que la base de datos deje de funcionar correctamente, lo que puede resultar en tiempos de inactividad y pÃ©rdida de disponibilidad.
- **Dificultad para detectar y mitigar el ataque:** debido a que el cÃ³digo malicioso se inserta en una consulta SQL legÃ­tima.
- **Posibilidad de propagaciÃ³n del ataque:** si el atacante tiene acceso a datos sensibles, como contraseÃ±as de usuario, puede utilizarlos para propagar el ataque a otros sistemas.
- **Acceso no autorizado:** un atacante podrÃ­a obtener acceso no autorizado al sistema o a la aplicaciÃ³n web, lo que le permitirÃ­a acceder a informaciÃ³n confidencial o realizar acciones maliciosas en el sistema.
- **ModificaciÃ³n de datos:** un atacante podrÃ­a modificar, eliminar o agregar datos al sistema, lo que podrÃ­a tener graves consecuencias en la integridad y exactitud de los datos.
- **EjecuciÃ³n de cÃ³digo malicioso:** un atacante podrÃ­a ejecutar cÃ³digo malicioso en el sistema, lo que podrÃ­a resultar en la toma de control del sistema o en el robo de informaciÃ³n confidencial.
- **DenegaciÃ³n de servicio:** un atacante podrÃ­a utilizar la inyecciÃ³n de comando para sobrecargar el sistema y hacer que se vuelva inoperable.
- **La no correcciÃ³n de esta falla puede causar divulgaciÃ³n no autorizada de su informaciÃ³n y la de sus clientes que podrÃ­a dar lugar a fraude, usurpaciÃ³n de identidad y a sanciones reglamentarias.**
- Para evitar la inyecciÃ³n de comandos, es importante validar y filtrar todas las entradas de usuario en las aplicaciones web, y evitar el uso de comandos de shell en aplicaciones web. AdemÃ¡s, es importante mantener todas las aplicaciones y sistemas actualizados y parcheados para evitar que se exploten vulnerabilidades conocidas.

## **SoluciÃ³n**

> Para prevenir y solucionar la inyecciÃ³n SQL avanzada, se pueden tomar las siguientes medidas:
> 
- **Validar y sanitizar todas las entradas de datos**: AsegÃºrese de que todas las entradas de datos, ya sean proporcionadas por los usuarios o por otras fuentes, sean validadas y sanitizadas adecuadamente antes de ser utilizadas en una consulta SQL.
- **Utilizar consultas parametrizadas:** En lugar de construir una consulta SQL dinÃ¡micamente utilizando cadenas de texto, utilice consultas parametrizadas que permitan que los parÃ¡metros sean pasados como argumentos separados. Esto reducirÃ¡ la posibilidad de inyecciÃ³n SQL, ya que los valores de los parÃ¡metros son tratados como datos, no como parte de la consulta SQL.
- **Limitar los permisos de la base de datos:** AsegÃºrese de que los usuarios de la base de datos tengan solo los permisos necesarios para realizar sus funciones y nada mÃ¡s. Esto limitarÃ¡ el alcance de cualquier posible ataque.
- **Utilizar herramientas de seguridad y pruebas de penetraciÃ³n:** Realice pruebas regulares de seguridad y pruebas de penetraciÃ³n en la aplicaciÃ³n para identificar posibles vulnerabilidades y errores de seguridad. TambiÃ©n puede utilizar herramientas de seguridad de terceros para proteger la aplicaciÃ³n contra la inyecciÃ³n SQL.
- ActualizaciÃ³n y parcheo del software de la base de datos y uso de firewalls de aplicaciÃ³n web (WAF)

Es una tarea difÃ­cil determinar si una cadena de usuario es maliciosa o no. Por lo tanto, la mejor manera de hacerlo es â€œescaparâ€ de los caracteres especiales en la entrada del usuario. Puede escapar una cadena antes de construir la consulta en PHP usando la funciÃ³n mysql_escape_string(). O en MySQL usando la funciÃ³n mysqli_real_escape_string().

Mientras se muestra la salida como HTML, tambiÃ©n tendrÃ¡ que convertir la cadena para asegurarse de que los caracteres especiales no interfieren con el marcado HTML. Puede convertir caracteres especiales en PHP usando la funciÃ³n htmlspecialchars(). Alternativamente, puede usar sentencias preparadas para evitar las inyecciones de SQL. Una sentencia preparada es una plantilla de una consulta SQL, en la que se especifican los parÃ¡metros en una etapa posterior para ejecutarla. AquÃ­ hay un ejemplo de una declaraciÃ³n preparada en PHP y MySQLi.

`$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

`$query->execute(array($username, $password));`

> ğŸ“– En resumen, para solucionar y prevenir la inyecciÃ³n SQL avanzada, es necesario validar y sanitizar todas las entradas de datos, utilizar consultas parametrizadas, limitar los permisos de la base de datos y utilizar herramientas de seguridad y pruebas de penetraciÃ³n.

</aside>

REFERENCIAS

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)

# **Pruebas de inyecciÃ³n SQL: todo lo que necesita saber**

Para mejorar sus habilidades de pentester de aplicaciones web, es importante aprender a detectar vulnerabilidades de inyecciÃ³n SQL. Profundizarwmoa en los principios y mÃ©todos de prueba que pueden descubrir los detalles de esta amenaza. Exploraremos tÃ©cnicas de prueba manuales, como analizar URL y formularios, comprender la interacciÃ³n del usuario y el procesamiento de aplicaciones.

AdemÃ¡s, proporcionaremos ejemplos reales de cargas Ãºtiles de inyecciÃ³n SQL que puede utilizar en sus propias pruebas. Para mejorar aÃºn mÃ¡s sus habilidades, cubriremos la automatizaciÃ³n con herramientas como SQLmap y Burp Suite, que ofrecen informaciÃ³n de expertos de la industria sobre tÃ©cnicas modernas. TambiÃ©n obtendrÃ¡ conocimientos sobre la interpretaciÃ³n de mensajes de error complejos que son cruciales para identificar y resolver problemas. Al dominar las tÃ©cnicas bÃ¡sicas y avanzadas descritas en este artÃ­culo, podrÃ¡ mejorar la seguridad de sus aplicaciones y contribuir a un entorno digital mÃ¡s seguro.

## **Comprender las inyecciones SQL**

Las inyecciones SQL son una vulnerabilidad informÃ¡tica que puede afectar aplicaciones web y bases de datos que utilizan el lenguaje SQL. Estos ataques aprovechan las vulnerabilidades en los formularios de entrada y las URL dentro de las aplicaciones. Insertan intencionalmente declaraciones SQL daÃ±inas en las solicitudes del servidor. El objetivo principal de un ataque de inyecciÃ³n SQL es controlar cÃ³mo funciona la base de datos. Esto permite el acceso no autorizado a datos confidenciales extrayÃ©ndolos, modificÃ¡ndolos o eliminÃ¡ndolos.

**Los ataques de inyecciÃ³n SQL se pueden dividir en varias categorÃ­as. Los mÃ¡s conocidos son:**

**InyecciÃ³n basada en errores:** esta tÃ©cnica implica insertar entradas daÃ±inas en la base de datos de un sistema para provocar errores. Estos errores potencialmente pueden brindarle informaciÃ³n Ãºtil.

![SQL 2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql2.png?raw=true)

**InyecciÃ³n basada en uniÃ³n:** el operador UNION le permite combinar los resultados de una consulta daÃ±ina y una consulta vÃ¡lida. Esto les permite acceder a datos de otras tablas sin permiso.

![SQL 3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql3.png?raw=true)

**InyecciÃ³n ciega** : en este tipo de ataque, el perpetrador no recibe una respuesta directa del servidor. En cambio, infieren informaciÃ³n sobre el comportamiento del sistema para recopilar datos.

![SQL 4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql4.png?raw=true)

**InyecciÃ³n ciega basada en el tiempo** : esta tÃ©cnica implica agregar intencionalmente retrasos a las consultas para verificar la precisiÃ³n de condiciones especÃ­ficas. Al analizar los mensajes de error, puede extraer informaciÃ³n valiosa sobre la base de datos, lo que ayuda a una mayor explotaciÃ³n, como descubrir nombres de tablas o detalles del sistema, sin generar alarmas ni sospechas.

## **Pruebas manuales de inyecciÃ³n SQL**

Profundicemos ahora en las tÃ©cnicas manuales de prueba de inyecciÃ³n SQL examinando de cerca la estructura de la URL. Al hacerlo, podemos identificar vulnerabilidades potenciales y explotarlas con fines de evaluaciÃ³n de seguridad.

**Analizando la estructura de la URL**

![SQL 5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql5.png?raw=true)

Durante el proceso de prueba manual de inyecciÃ³n SQL, un anÃ¡lisis profundo de la estructura de la URL es esencial para identificar y evaluar vulnerabilidades en las aplicaciones web. Este enfoque implica identificar debilidades en la aplicaciÃ³n inyectando intencionalmente cÃ³digo SQL malicioso a travÃ©s de parÃ¡metros que se encuentran dentro de las URL.

Para analizar la vulnerabilidad de un sitio web a los ataques de inyecciÃ³n SQL, es importante identificar cualquier entrada del usuario que se transmita a travÃ©s de los parÃ¡metros de la URL. Estos parÃ¡metros pueden servirle potencialmente como puntos de entrada. Una vez que se identifican estos parÃ¡metros, probar su manipulabilidad se vuelve crucial.

Esto implica insertar varias cadenas de prueba, caracteres especiales y secuencias de escape para determinar si la aplicaciÃ³n maneja adecuadamente dichas entradas sin generar errores.

![SQL 6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql6.png?raw=true)

Otro paso importante es examinar minuciosamente los mensajes de error que produce la aplicaciÃ³n. Estos mensajes pueden exponer inadvertidamente vulnerabilidades internas en el sistema, descubriendo potencialmente debilidades de inyecciÃ³n SQL.

Por ejemplo, en la imagen de arriba, puede ver un error generado al manipular el parÃ¡metro **de usuario** en la URL, lo que nos ayuda a identificar la **consulta SQL especÃ­fica**Â  que estÃ¡ causando el error. Esto luego podrÃ­a usarse para intentar explotar la vulnerabilidad que estÃ¡ causando el error o lanzar un ataque de denegaciÃ³n de servicio (DoS) en el sitio web enviando demasiadas consultas SQL no vÃ¡lidas.

Para profundizar mÃ¡s en las pruebas de este tipo de URL, puede intentar identificar dÃ³nde se inserta la entrada del usuario en la consulta SQL. Puede ser un campo de entrada, una variable en la URL o cualquier forma de entrada del usuario.

Para comenzar, puede utilizar una carga Ãºtil de SQL bÃ¡sica como esta:' OR '1'='1

Inserte esta carga Ãºtil en la entrada sospechosa y vea si el mensaje de error de SQL desaparece. Si el mensaje de error desaparece o se produce un comportamiento diferente, podrÃ­a ser una seÃ±al de que el sitio es vulnerable a un ataque de inyecciÃ³n SQL. Si la carga Ãºtil bÃ¡sica no produce resultados significativos, es posible que desee experimentar con cargas Ãºtiles de SQL mÃ¡s avanzadas, como la inyecciÃ³n SQL ciega basada en UNION o basada en tiempo. Por ejemplo, una carga Ãºtil basada en UNION que podrÃ­as probar es: ' UNION

`SELECT null, username, password FROM users--`

Este tipo de carga Ãºtil intenta extraer informaciÃ³n de la tabla de usuarios. Sin embargo, tenga cuidado al utilizar cargas Ãºtiles avanzadas como esta, ya que pueden afectar negativamente al sitio que estÃ¡ probando, si no se usan correctamente.

En resumen, analizar la estructura de la URL en las pruebas manuales de inyecciÃ³n SQL puede ayudar a identificar vulnerabilidades potenciales y evaluar la capacidad de una aplicaciÃ³n para manejar entradas maliciosas, brindÃ¡ndole datos importantes para continuar con su pentest.

## **Campos de formulario y mecanismos de validaciÃ³n**

Los campos de formulario en una aplicaciÃ³n web sirven como punto de entrada para la entrada del usuario. Puede explotar estos campos mediante inyecciones SQL, donde inyecta cÃ³digo SQL daÃ±ino. Estos campos de formulario se utilizan comÃºnmente para recopilar datos importantes del usuario, como nombres, direcciones de correo electrÃ³nico, contraseÃ±as y mÃ¡s.

La combinaciÃ³n de campos de formulario bien diseÃ±ados con mecanismos de validaciÃ³n sÃ³lidos puede mitigar eficazmente el riesgo de inyecciones de SQL. Por ejemplo, un campo de correo electrÃ³nico debe aceptar estrictamente sÃ³lo direcciones de correo electrÃ³nico vÃ¡lidas, evitando la inserciÃ³n de caracteres especiales que podrÃ­an manipular consultas SQL. Este no es siempre el caso y estÃ¡ sujeto a abuso.

Probar para ver si el formulario acepta caracteres especiales o entradas no tÃ­picas puede indicar la posibilidad de enviar comandos o solicitudes maliciosos a la base de datos.

![SQL 7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql7.png?raw=true)

Cuando se prueban manualmente las vulnerabilidades de inyecciÃ³n SQL, las medidas de seguridad existentes, como la validaciÃ³n de las entradas del usuario, a veces pueden impedir el proceso de inyecciÃ³n. En tales casos, vale la pena explorar cargas Ãºtiles bÃ¡sicas, como insertar **'OR 1=1--** en el campo de entrada; Este tipo de cargas Ãºtiles se denominan cargas Ãºtiles de omisiÃ³n porque utilizan una condiciÃ³n que siempre es verdadera para manipular una entrada vulnerable y omitir la autenticaciÃ³n, acceder a datos no autorizados o ejecutar comandos maliciosos.

![SQL 8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql8.png?raw=true)

Si bien la validaciÃ³n de entradas es una salvaguarda importante, no siempre es infalible, por lo que para identificar posibles vulnerabilidades es esencial realizar pruebas completas y exhaustivas.

## **Valores de cookies y encabezados HTTP**

En las pruebas de inyecciÃ³n SQL manuales, puede manipular las solicitudes explotando los valores de las cookies y los encabezados HTTP de una aplicaciÃ³n web. Estos elementos se consideran entradas externas, por lo que es importante que realice pruebas adecuadas con las herramientas correctas (como Burp Suite).

Las cookies, que contienen informaciÃ³n almacenada en el navegador de un usuario, pueden ser vulnerables a la manipulaciÃ³n. Un mÃ©todo comÃºn es inyectar cÃ³digo SQL daÃ±ino alterando los datos dentro de una cookie. Si se utiliza una cookie, por ejemplo, para almacenar una identificaciÃ³n de usuario en una aplicaciÃ³n, puede intentar modificar esa identificaciÃ³n dentro de la propia cookie. Este tipo de explotaciÃ³n podrÃ­a dar lugar a un acceso no autorizado a datos o funciones sensibles.

> ğŸ’¡ Por ejemplo, considere una aplicaciÃ³n que utiliza una cookie para controlar al usuario que ha iniciado sesiÃ³n actualmente. Ahora, supongamos que un hacker con intenciones maliciosas logra alterar esta cookie alterando el ID de usuario que contiene.

</aside>

Si la aplicaciÃ³n no aborda adecuadamente esta modificaciÃ³n, podrÃ­a generar involuntariamente una consulta SQL daÃ±ina basada en el ID manipulado. Esto podrÃ­a potencialmente otorgar acceso no autorizado a datos confidenciales.

AdemÃ¡s, cuando un navegador envÃ­a una solicitud a una aplicaciÃ³n, incluye encabezados HTTP como User-Agents. Usted (el atacante) puede alterar estos encabezados insertando cadenas daÃ±inas en las solicitudes. Por ejemplo, podrÃ­a utilizar la siguiente carga Ãºtil:'UNION SELECT null, username, password FROM users--

Esta carga Ãºtil estÃ¡ diseÃ±ada para extraer datos de la tabla de "usuarios" de una base de datos. Supongamos que tiene una solicitud HTTP GET que incluye un parÃ¡metro "cat" en el que colocar la carga Ãºtil. En la pestaÃ±a "Solicitud HTTP" de Burp Suite, cambie el parÃ¡metro "cat" para que contenga la carga Ãºtil, por ejemplo:cat=' UNION SELECT null, username, password FROM users--

Comience a enviar la solicitud y observe la respuesta. Si el sitio es vulnerable a una inyecciÃ³n SQL basada en UNION, obtendrÃ¡ una respuesta que incluye informaciÃ³n de la tabla "usuarios".

![SQL 9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql9.png?raw=true)

En ambos casos, es esencial garantizar que la aplicaciÃ³n maneje de forma segura los valores de las cookies y los encabezados HTTP. Las pruebas manuales implican analizar el impacto de dichas manipulaciones en las entradas de la aplicaciÃ³n y verificar su respuesta a posibles ataques de inyecciÃ³n SQL.

**Entrada controlada por el usuario (UCI) procesada por la aplicaciÃ³n**

Cuando se prueban manualmente las vulnerabilidades de inyecciÃ³n SQL, el concepto de "Entrada controlada por el usuario" o UCI se refiere a cualquier entrada proporcionada por el usuario y posteriormente procesada por la aplicaciÃ³n. Esto puede incluir datos ingresados â€‹â€‹en campos de formulario, valores de cookies, parÃ¡metros en URLs o encabezados HTTP (que ya vimos antes), puedes aprovechar estas oportunidades para inyectar cÃ³digo SQL malicioso y causar grandes daÃ±os.

En este enfoque, manipula intencionalmente la entrada proporcionada para insertar caracteres especiales o secuencias de escape (como â€˜â€™ o =). Estas manipulaciones pueden alterar las consultas SQL generadas por la aplicaciÃ³n y explotar vulnerabilidades en su procesamiento de entrada. El objetivo es engaÃ±ar a la aplicaciÃ³n para que ejecute consultas SQL no deseadas, lo que resulta en una extracciÃ³n de datos no autorizada o en un compromiso del sistema.

### **Debe tener una lista de cargas Ãºtiles de inyecciÃ³n SQL**

Las cargas Ãºtiles son fragmentos de cÃ³digo que se insertan intencionalmente en los campos de entrada de las aplicaciones web. Estos fragmentos tienen como objetivo explotar las vulnerabilidades en los sistemas de gestiÃ³n de bases de datos. Los profesionales de la seguridad y los evaluadores de penetraciÃ³n suelen utilizar estas herramientas para evaluar el nivel de resistencia que tiene una aplicaciÃ³n contra posibles ataques. A continuaciÃ³n, se muestra una lista de las cargas Ãºtiles de

inyecciÃ³n SQL mÃ¡s comunes utilizadas por **Pentesters**Â  y **Bug Bounty Hunters**Â  (en un contexto de piraterÃ­a Ã©tica) para probar manualmente formularios en busca de vulnerabilidades de inyecciÃ³n SQL:

- payload de inyecciÃ³n SQL bÃ¡sica: **' OR '1'='1** (se utiliza para omitir la autenticaciÃ³n ingresando una condiciÃ³n que siempre es verdadera).
- Recuperar informaciÃ³n: **' UNION SELECT null,username,password FROM users--** (Se utiliza para extraer datos confidenciales como nombre de usuario y contraseÃ±a de la base de datos).
- ManipulaciÃ³n de consultas: **'; DROP TABLE users; --** (Se utiliza para provocar la eliminaciÃ³n de la tabla "usuarios").
- Obtener los nombres de las tablas: **' AND 1=0 UNION SELECT table_name, null FROM information_schema.tables--** (Se utiliza para extraer los nombres de las tablas en la base de datos).
- Extraer nombre de la base de datos: **' AND 1=0 UNION SELECT null, database()--** (Se utiliza para extraer el nombre de la base de datos actual).
- Uso de UNION para extraer datos: **' UNION SELECT username, password FROM users--** (Se utiliza para extraer datos confidenciales mediante una operaciÃ³n UNION).
- Uso de comentarios para omitir: **admin' --** (Utiliza un comentario para omitir el resto de la entrada e iniciar sesiÃ³n como administrador).
- Uso de SQLi ciego basado en tiempo: **' OR IF(1=1, SLEEP(5), 0)--** (Retrasa la respuesta del servidor para confirmar la vulnerabilidad de inyecciÃ³n SQL).
- Uso de SQLi basado en errores: **' AND 1=CONVERT(int, (SELECT @@version))--** (fuerza un error de SQL a revelar informaciÃ³n de la base de datos).

Todas estas cargas Ãºtiles se pueden usar (y son las mÃ¡s efectivas) en **formularios de inicio de sesiÃ³n** vulnerables , **URL** (usadas como consultas maliciosas) y **solicitudes** (capturadas y modificadas por usted con la carga Ãºtil correcta).

### **Pruebas automatizadas de inyecciÃ³n de SQL**

Cuando se trata de seguridad de la informaciÃ³n, herramientas como SQLmap y Burp Suite gozan de gran prestigio en el campo de las pruebas de inyecciÃ³n SQL.

### **DescripciÃ³n general de las herramientas: SQLmap y Burp Suite**

Estas herramientas son ampliamente utilizadas por los profesionales de la seguridad y brindan soluciones automatizadas efectivas para detectar y explotar vulnerabilidades de inyecciÃ³n SQL en aplicaciones web. Si bien SQLmap se especializa en pruebas y automatizaciÃ³n avanzadas, Burp Suite ofrece un ecosistema completo para analizar la seguridad de las aplicaciones. Permite a los expertos identificar, evaluar y abordar vulnerabilidades crÃ­ticas, incluidas aquellas relacionadas con ataques de inyecciÃ³n SQL.

Ahora veamos en detalle para quÃ© sirven estas herramientas y para quÃ© se utilizan:

- **SQLmap** : es una valiosa herramienta de cÃ³digo abierto que automatiza las pruebas de inyecciÃ³n de SQL. Detecta vulnerabilidades de forma eficaz, extrae datos y compromete los sistemas de bases de datos utilizando una variedad de cargas Ãºtiles y tÃ©cnicas. Los probadores de penetraciÃ³n dependen principalmente de SQLmap para evaluar la seguridad de las aplicaciones.

![SQL 10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql10.png?raw=true)

- **Burp Suite** : es un conjunto completo de herramientas diseÃ±adas para la seguridad de aplicaciones web. Entre sus caracterÃ­sticas, la herramienta incluye un mÃ³dulo de Seguridad de Aplicaciones Web (WAS), que ayuda a los especialistas en seguridad a identificar y abordar vulnerabilidades en sitios web. Este mÃ³dulo puede detectar amenazas de seguridad comunes que incluyen, como es de esperar, ataques de inyecciÃ³n SQL.

![SQL 11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql11.png?raw=true)

### **EjecuciÃ³n de SQLmap para buscar y explotar inyecciones de SQL**

Ahora, usemos SQLmap para descubrir sistemÃ¡ticamente vulnerabilidades de inyecciÃ³n SQL en un sitio web deliberadamente vulnerable. Nuestro objetivo serÃ¡ VulnWeb ( http://testphp.vulnweb.com ), un sitio web diseÃ±ado especÃ­ficamente para que los estudiantes de Seguridad CibernÃ©tica aprendan atacando y explotando sus vulnerabilidades.

Si encuentra una URL web como, en este caso, [http://testphp.vulnweb.com/listproducts.php](http://testphp.vulnweb.com/listproducts.php)? **cat=1** , donde el parÃ¡metro 'GET' estÃ¡ resaltado, podrÃ­a indicar que el sitio web es susceptible a ataques de inyecciÃ³n SQL. En tales casos, es posible que pueda acceder a informaciÃ³n confidencial de la base de datos. Se sabe que SQLmap es el mÃ¡s eficaz en escenarios que involucran sitios web basados â€‹â€‹en PHP.

![SQL 12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql12.png?raw=true)

**Paso 1: EvaluaciÃ³n del parÃ¡metro de la URL**

Una forma sencilla de determinar si su sitio web es vulnerable es reemplazar el valor en el parÃ¡metro de solicitud de obtenciÃ³n con un *****Â  (asterisco).

![SQL 13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql13.png?raw=true)

Este tipo de error sugiere que el sitio web es vulnerable a algÃºn tipo de ataques de inyecciÃ³n SQL.

**Paso 2: comprobar la URL con SQLmap**

Necesitamos ingresar la URL web deseada que debe verificarse, usando el parÃ¡metro -u . Generalmente el objetivo principal es determinar si es posible acceder a una base de datos, por lo que podemos utilizar la opciÃ³n --dbsÂ  para este propÃ³sito. Al utilizar --dbs, podemos obtener una lista de todas las bases de datos disponibles.

El primer comando serÃ¡:

`sqlmap -u [http://testphp.vulnweb.com/listproducts.php?cat=1](http://testphp.vulnweb.com/listproducts.php?cat=1) --dbs`

![SQL 14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql14.png?raw=true)

**Paso 3: comprender el resultado**

En el resultado anterior, puede ver en amarillo las partes donde SQLmap encontrÃ³ vulnerabilidades de inyecciÃ³n SQL y en naranja las mejores cargas Ãºtiles, sugeridas por SQLmap, para usar ese tipo especÃ­fico de inyecciÃ³n SQL (por ejemplo, la primera vulnerabilidad encontrada es una vulnerabilidad booleana). **InyecciÃ³n SQL ciega** basada y la carga Ãºtil sugerida es: cat-1 AND 1050-1050). Tomemos, por ejemplo, la Ãºltima parte del resultado, resaltada en amarillo, que dice: â€œEl parÃ¡metro GET **'cat'** es ' **Consulta UNION genÃ©rica** '.

Esta parte del resultado nos dice que el parÃ¡metro "cat" de una solicitud GET (que es el tipo de solicitud web que, en este caso, SQLmap estÃ¡ usando para probar la URL) dentro de "[http://testphp.vulnweb.com](http://testphp.vulnweb.com/) /listaproductos.php? **cat** =1â€ es vulnerable a una consulta UNION genÃ©rica.

**Pero Â¿quÃ© es una consulta UNION GenÃ©rica?**

Es un ataque que normalmente implica manipular la consulta SQL para combinar los resultados de 2 o mÃ¡s tablas de bases de datos, lo que le permite obtener acceso no autorizado a datos confidenciales. En resumen, este resultado de SQLmap sugiere que se necesitan mÃ¡s pruebas para confirmar si el parÃ¡metro **'cat'** es realmente vulnerable a un ataque de inyecciÃ³n SQL de "consulta UNION genÃ©rica". Es una seÃ±al para investigar y potencialmente explotar una vulnerabilidad en la validaciÃ³n de entrada de la aplicaciÃ³n (que es la parte de la aplicaciÃ³n web que verifica y permite la entrada del usuario segÃºn la consulta utilizada).

Y es por eso que podemos ver, en el Ãºltimo resultado resaltado en naranja, que SQLmap sugiere una carga Ãºtil especÃ­fica, para probar manualmente el sitio web vulnerable para ese tipo de ataque de inyecciÃ³n SQL.

## **AnÃ¡lisis de mensajes de error**

Durante el proceso de anÃ¡lisis de errores en las pruebas de inyecciÃ³n SQL, los errores generados por una aplicaciÃ³n pueden ofrecer informaciÃ³n importante sobre la existencia de vulnerabilidades. Por ejemplo, los mensajes de error que contienen informaciÃ³n confidencial como nombres de tablas, errores flagrantes de sintaxis SQL en los comentarios de la aplicaciÃ³n y respuestas inconsistentes, como resultados faltantes o duplicados, pueden indicar una posible manipulaciÃ³n de la consulta.

![SQL 15](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql15.png?raw=true)

Estos mensajes de error pueden ofrecer informaciÃ³n valiosa sobre el funcionamiento interno del sistema. Para activar estos mensajes, se pueden ingresar intencionalmente datos maliciosos que provoquen que las consultas fallen. En la imagen de arriba, puede ver un error de sintaxis SQL (que ya mencionamos antes) que aparece despuÃ©s de cambiar el valor del parÃ¡metro **cat de " 1** " a ***** (ejemplo de entrada maliciosa).

Si encuentra errores de sintaxis SQL, como el comÃºnmente visto "Tiene un error en su sintaxis SQL" (que podemos ver en la imagen), generalmente significa que la entrada se incluye directamente en las consultas sin la verificaciÃ³n adecuada. Este tipo de errores a menudo indican un comportamiento interno del sistema y ayudan a los expertos en seguridad a identificar posibles debilidades en las aplicaciones.

## **Preguntas frecuentes**

- **Â¿Es ilegal realizar pruebas de inyecciones de SQL?**

La legalidad de cualquier Pentest depende Ãºnicamente de las leyes locales y federales de su paÃ­s, por lo que es una buena prÃ¡ctica estar informado sobre ellas antes de realizar cualquier tipo de prueba activa. Sin embargo, no deberÃ­a haber ningÃºn problema siempre que la actividad se realice de manera responsable y en plataformas donde se haya obtenido el **permiso por escrito**Â  del propietario.

- **Â¿QuÃ© son las tÃ©cnicas de inyecciÃ³n SQL?**

Existen varias tÃ©cnicas que se pueden utilizar para manipular consultas, como ataques UNION, ataques basados â€‹â€‹en tiempo y ataques basados â€‹â€‹en errores. Estas tÃ©cnicas implican el uso de datos maliciosos para explotar vulnerabilidades.

- **Â¿CuÃ¡l es la mejor herramienta de inyecciÃ³n SQL?**

Para fines de automatizaciÃ³n, SQLmap se utiliza ampliamente, mientras que Burp Suite ofrece una soluciÃ³n versÃ¡til para anÃ¡lisis de seguridad.

- **Â¿Necesito aprender SQL para inyecciones de SQL?**

Tener algunos conocimientos de SQL puede resultar Ãºtil, pero tambiÃ©n hay herramientas disponibles que pueden simplificar el proceso de identificaciÃ³n de vulnerabilidades.

## **InyecciÃ³n SQL ciega**

La inyecciÃ³n ciega de SQL, una forma sigilosa y astuta de ataque de inyecciÃ³n de SQL, plantea un desafÃ­o Ãºnico para los profesionales de la seguridad debido a su naturaleza esquiva y su dificultad de detecciÃ³n y explotaciÃ³n. En este completo artÃ­culo, profundizaremos en el mundo de la inyecciÃ³n SQL ciega y descubriremos los matices sutiles que la distinguen de otros ataques de inyecciÃ³n SQL.

A lo largo del artÃ­culo, analizaremos varias herramientas y mÃ©todos, centrÃ¡ndonos en Kali Linux como nuestra plataforma preferida, aunque puede utilizar las herramientas mencionadas en la mayorÃ­a de los sistemas operativos. A medida que concluimos, le brindaremos un conjunto de mejores prÃ¡cticas probadas para defender sus aplicaciones web contra estos ataques esquivos y potencialmente daÃ±inos. Al final de este artÃ­culo, estarÃ¡ bien versado en cÃ³mo comprender, explotar y defenderse contra las vulnerabilidades de inyecciÃ³n SQL ciega.

Ahora, profundicemos en esta guÃ­a detallada y prepÃ¡rese con los conocimientos y tÃ©cnicas esenciales para abordar de manera efectiva los desafÃ­os que plantea este tipo de vulnerabilidad.

### **Â¿QuÃ© es la inyecciÃ³n SQL ciega?**

La inyecciÃ³n SQL es una vulnerabilidad frecuente de las aplicaciones web que ocurre cuando un atacante logra ejecutar **cÃ³digo SQL** no autorizado en la base de datos de una aplicaciÃ³n web. Los atacantes hacen esto insertando declaraciones SQL maliciosas en los campos de entrada del usuario, como cuadros de bÃºsqueda o formularios de inicio de sesiÃ³n. Cuando tiene Ã©xito, un atacante puede obtener informaciÃ³n confidencial de la base de datos, modificar o eliminar datos e incluso ejecutar comandos administrativos.

La inyecciÃ³n ciega de SQL, una variante mÃ¡s oculta, ocurre cuando el atacante **no puede ver directamente el resultado** de sus consultas inyectadas. En este caso, deben deducir los resultados indirectamente utilizando tÃ©cnicas basadas en contenido o en tiempo. Este tipo de ataque se utiliza cuando la aplicaciÃ³n no muestra visiblemente los resultados de una consulta SQL inyectada, lo que dificulta que el atacante confirme el Ã©xito de sus acciones.

El beneficio de utilizar la inyecciÃ³n SQL ciega sobre un ataque de inyecciÃ³n SQL estÃ¡ndar radica en su sutileza. Dado que el atacante no ve directamente el resultado, puede resultar mÃ¡s difÃ­cil para los sistemas de seguridad o los administradores detectar el ataque. El atacante suele utilizar respuestas condicionales ( **basadas en booleanos** ) o retrasos en el tiempo de respuesta de la aplicaciÃ³n ( **basadas en tiempos** ) para inferir si el cÃ³digo SQL inyectado ha tenido el efecto deseado.

Al recopilar lenta y metÃ³dicamente informaciÃ³n sobre la estructura y el contenido de la base de datos, un atacante aÃºn puede explotar una vulnerabilidad de inyecciÃ³n SQL ciega para acceder a datos confidenciales y manipular el sistema sin levantar sospechas inmediatas.

## **Descargo de responsabilidad**

Queremos ser absolutamente claros sobre la importancia de cumplir con las leyes aplicables con respecto al escaneo y la explotaciÃ³n de vulnerabilidades de aplicaciones web. Antes de realizar cualquier forma de piraterÃ­a Ã©tica o prueba de penetraciÃ³n en un sistema, **asegÃºrese de haber obtenido el permiso explÃ­cito** del sistema o del propietario de la red.

La piraterÃ­a o el escaneo no autorizados pueden parecer triviales, pero pueden acarrear graves consecuencias legales, incluidas multas o prisiÃ³n, segÃºn su jurisdicciÃ³n. **No lo hagas.** Algunas de las leyes que rigen esta actividad incluyen:

- La Ley de Abuso y Fraude InformÃ¡tico (Estados Unidos)
- Secciones 184, 342.1, 380 y 430 del CÃ³digo Penal de CanadÃ¡ (CanadÃ¡)
- Ley de uso indebido de computadoras de 1990 (Inglaterra)
- Segundo. 202a y 202b del CÃ³digo Penal alemÃ¡n (Alemania)
- Ley de TecnologÃ­a de la InformaciÃ³n Sec. 43 y 66 (India)
- Ley sobre la prohibiciÃ³n del acceso no autorizado a ordenadores (JapÃ³n)

 Si duda si estÃ¡ actuando con claridad, consulte el acuerdo o el alcance de sus actividades autorizadas con una entidad especÃ­fica o revise el cÃ³digo de conducta o las pautas de divulgaciÃ³n con cualquiera de los programas de recompensas por errores mencionados al final de este artÃ­culo.

## **Descubriendo y explotando SQLi ciego**

Ahora que tiene un conocimiento sÃ³lido de la inyecciÃ³n SQL ciega y en quÃ© se diferencia de la inyecciÃ³n SQL normal, profundicemos en el **proceso de descubrir** y explotar estas vulnerabilidades.Â  Primero, lo guiaremos en la configuraciÃ³n de su entorno de laboratorio, luego realizaremos pruebas manuales de inyecciÃ³n ciega de SQL y, finalmente, usaremos herramientas como SQLMap y Burp Suite para agilizar el proceso de explotaciÃ³n.

### **Configurando su laboratorio**

Para comenzar, deberÃ¡ configurar su laboratorio para descubrir y explotar vulnerabilidades de inyecciÃ³n SQL ciega. Hay **varias herramientas que puede utilizar** y usaremos las siguientes herramientas y recursos:

**Maldita aplicaciÃ³n web vulnerable (DVWA):** DVWA es una aplicaciÃ³n web intencionalmente vulnerable que proporciona un entorno seguro para practicar diversas tÃ©cnicas. **Viene preinstalado en Kali Linux** o puedes descargarlo con sudo apt install dvwa. Una vez instalado, establezca el nivel de dificultad en "bajo" o "medio" y navegue hasta el desafÃ­o "InyecciÃ³n SQL (ciega)". Usaremos esto para simular un escenario del mundo real y demostrar mÃ©todos de prueba. Para iniciar la aplicaciÃ³n DVWA:

1. Abra la terminal y escriba el comando: dvwa-start.
2. Si no estÃ¡ en la cuenta raÃ­z, se le pedirÃ¡ que lo permita.
3. El navegador deberÃ­a abrirse automÃ¡ticamente en DVWA.
4. (Alternativamente) Si no se abre, vaya al navegador e ingrese: **[http://127.0.0.1:42001](http://127.0.0.1:42001/)**en la barra de direcciones.
5. Para detener el servidor DVWA, regrese a la terminal y escriba el comando: dvwa-stop.

**SQLMap:** esta poderosa herramienta de cÃ³digo abierto automatiza la detecciÃ³n y explotaciÃ³n de vulnerabilidades de inyecciÃ³n SQL. **Viene preinstalado en Kali Linux** , por lo que si ese es el sistema operativo que estÃ¡s usando, no necesitas descargarlo por separado. Usaremos SQLMap para automatizar la explotaciÃ³n de la vulnerabilidad de inyecciÃ³n SQL ciega descubierta en DVWA.

**Burp Suite:** Burp Suite es un conjunto de herramientas de prueba de seguridad de aplicaciones web ampliamente utilizado. Para este artÃ­culo, usaremos la Community Edition, **que viene preinstalada en Kali Linux** . Esto se utilizarÃ¡ para interceptar las solicitudes realizadas a la DVWA. Demostraremos un mÃ©todo alternativo de prueba con SQLMap capturando una solicitud con Burp, guardÃ¡ndola como un archivo de texto y luego ejecutÃ¡ndola a travÃ©s de SQLMap. Se recomienda que sÃ³lo ejecute DVWA u otras aplicaciones intencionalmente vulnerables en un entorno virtual.

## **Pruebas de inyecciÃ³n SQL ciega**

La detecciÃ³n de una inyecciÃ³n SQL ciega implica enviar consultas que producen respuestas condicionales o retrasan el tiempo de respuesta del servidor. Lo guiaremos a travÃ©s de cada paso del proceso para que pueda realizar pruebas exhaustivas de inyecciÃ³n SQL ciega y comprender el razonamiento o el comportamiento detrÃ¡s de cada acciÃ³n. Como nota, la estructura de consulta exacta o los comandos pueden variar segÃºn la base de datos utilizada. Se demuestra MySQL.

**Paso 1: respuesta normal**

Comience enviando una respuesta normal, como ingresar '2', para ver cÃ³mo se comporta la aplicaciÃ³n en circunstancias normales. Esto ayuda a establecer una base para el comportamiento esperado sin necesidad de inyectar cÃ³digo SQL.

![SQL 16](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql16.png?raw=true)

**Paso 2: prueba sencilla**

Realice una prueba sencilla ingresando una comilla simple ( 2â€˜#) despuÃ©s del '2' para verificar si esto podrÃ­a indicar una vulnerabilidad potencial en la aplicaciÃ³n web. Si se produce un error o el comportamiento cambia, podrÃ­a sugerir que la aplicaciÃ³n estÃ¡ manejando incorrectamente la entrada del usuario y puede ser susceptible a la inyecciÃ³n SQL. Este ( â€˜) no es obligatorio en todos los casos y puede variar segÃºn la base de datos en la que estÃ© probando.

NOTA: Al realizar pruebas dentro de un campo de formulario, debe colocar un #al final de su consulta para comentar cualquier texto que el programa pueda agregar posteriormente.

![SQL 17](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql17.png?raw=true)

**Paso 3: prueba de verdadero/falso**

Realice las pruebas de verdadero/falso inyectando condiciones " " 2â€™ AND 1=1#(siempre verdadera) y " 2â€™ AND 1=0#" (siempre falsa) y observe las respuestas de la aplicaciÃ³n a ambas consultas. Si el comportamiento de la aplicaciÃ³n cambia segÃºn la veracidad de la condiciÃ³n inyectada, indica que el cÃ³digo SQL se estÃ¡ ejecutando, confirmando la presencia de una vulnerabilidad.

En un ataque de inyecciÃ³n SQL normal, esta condiciÃ³n verdadera podrÃ­a devolver informaciÃ³n adicional de una tabla, pero ese no es el caso en un ataque ciego. Nuevamente, estÃ¡s buscando cambios en la respuesta.

![SQL 18](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql18.png?raw=true)

*El resultado de 1=1, una condiciÃ³n intencionalmente verdadera.*

![SQL 19](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql19.png?raw=true)

*El resultado de 1=0, una condiciÃ³n intencionalmente falsa.*

**Paso 4: prueba basada en el tiempo**

Pruebe el mÃ©todo basado en tiempos introduciendo " 2â€™ AND SLEEP(5)#" en la consulta. Compare el tiempo de respuesta con y sin el comando de suspensiÃ³n. Un retraso notable indica una vulnerabilidad potencial, ya que demuestra que la aplicaciÃ³n estÃ¡ ejecutando el comando SQL inyectado y esperando el tiempo especificado antes de devolver una respuesta.

![SQL 20](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql20.png?raw=true)

> *Ejecutar el ataque basado en el tiempo.*

![SQL 21](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql21.png?raw=true)

> *Ataque basado en tiempo completo.*

**Paso 5: determinar las columnas**

Determine la cantidad de columnas en la base de datos usando la 2â€™ ORDER BY X#condiciÃ³n " ", donde X es la cantidad de columnas que estamos probando. Incremente el nÃºmero hasta que cambie el comportamiento de la aplicaciÃ³n, lo que significa que ha encontrado la longitud correcta. Este paso es esencial para comprender la estructura de la base de datos, lo que puede resultar Ãºtil a la hora de explotar la vulnerabilidad.

![SQL 22](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql22.png?raw=true)

> *Prueba manual para una longitud de columna de 1.*

![SQL 23](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql23.png?raw=true)

> *Prueba manual para una longitud de columna de 2.*

> ğŸ‘‰ En nuestro caso, la aplicaciÃ³n web arrojÃ³ un error cuando probamos una longitud de columna de 3. Este cambio en el comportamiento nos permite saber que hemos identificado que el nÃºmero correcto de columnas es 2, ya que esa fue la Ãºltima prueba exitosa antes del cambio. . Esto se aprende observando el cambio en respuesta.

</aside>

**Paso 6: Determinar la longitud de DB**

A continuaciÃ³n, demostraremos la 2â€™ AND LENGTH(DATABASE())=X#condiciÃ³n " ", donde X es el nÃºmero de caracteres que se prueban. Esto se puede utilizar para determinar la longitud del nombre de la base de datos. Usaremos el mismo enfoque que acabamos de usar para determinar el nÃºmero de columnas, excepto que esta vez intentamos obtener el nÃºmero de caracteres en el nombre de la base de datos. Para hacer esto, probaremos por longitud de caracteres de manera iterativa.

![SQL 24](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql24.png?raw=true)

> *Prueba para una longitud de carÃ¡cter de 1.*

![SQL 25](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql25.png?raw=true)

> *Finalmente, un cambio indica una longitud de nombre de base de datos de 4.*

Esto tambiÃ©n se puede realizar con un comando de suspensiÃ³n en los casos en que no haya un indicador visual disponible. Por ejemplo, utilice " 2â€™ AND LENGTH(DATABASE())=X AND SLEEP(5)#" donde X es la longitud sospechosa de la base de datos. Si el comando de suspensiÃ³n retrasa la respuesta de la aplicaciÃ³n, confirma la longitud correcta de la base de datos.

![SQL 26](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql26.png?raw=true)

**Paso 7: determinar el nombre de la base de datos**

Finalmente, podemos comenzar a enumerar el nombre real de la base de datos. Ya sabemos que tiene cuatro caracteres, pero podemos hacer mÃ¡s determinando cuÃ¡les son esos caracteres. Para hacer esto, probaremos diferentes caracteres ASCII usando 2â€™ AND ASCII(SUBSTR(DATABASE(),X,X))>YY#. En este caso X, es la posiciÃ³n del carÃ¡cter que estamos probando y YYes el **[carÃ¡cter decimal ASCII](https://www.asciitable.com/)** .

Con este mÃ©todo, le pregunta a la base de datos si el primer carÃ¡cter es mayor que una letra establecida. Si no es asÃ­, responderÃ¡ con una negativa. Comenzaremos en algÃºn lugar cerca de la mitad del alfabeto minÃºsculo con â€œlâ€ (que es el decimal ASCII 108). Entonces la consulta se ve asÃ­: 2â€™ AND ASCII(SUBSTR(DATABASE(),1,1))>108#.

![SQL 27](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql27.png?raw=true))

SegÃºn la respuesta, sabemos que el primer carÃ¡cter no es mayor que â€œlâ€, por lo que tenemos que cambiar la operaciÃ³n para preguntar si es menor que â€œlâ€. Hacemos esto cambiando la consulta a 2â€™ AND ASCII(SUBSTR(DATABASE(),1,1))<108#.

![SQL 28](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql28.png?raw=true)

![SQL 29](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql29.png?raw=true)

SegÃºn esta respuesta, ahora sabemos que la primera letra estÃ¡ en algÃºn lugar entre la â€œlâ€ minÃºscula y todos los caracteres ASCII anteriores. TÃ©cnicamente, esto incluye todas las mayÃºsculas, nÃºmeros y caracteres especiales. Sabiendo esto podemos empezar a probar de forma incremental hasta que veamos un cambio en la respuesta. En nuestro caso, vemos una respuesta modificada una vez que ingresamos 100.

![SQL 30](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql30.png?raw=true)

![SQL 31](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql31.png?raw=true)

Esto ahora nos dice que el carÃ¡cter no es menor que una â€œdâ€ minÃºscula. Podemos confirmar que esta es la letra correcta invirtiendo la consulta.

![SQL 32](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql32.png?raw=true)

![SQL 33](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql33.png?raw=true)

Hemos confirmado con Ã©xito el primer personaje. Ahora, podemos usar este mismo mÃ©todo cambiando la consulta a la ubicaciÃ³n del segundo carÃ¡cter y repitiendo esto nuevamente. Nos aseguraremos de cambiar la ubicaciÃ³n ingresando 2â€™ AND ASCII(SUBSTR(DATABASE(),2,2))<108#.

![SQL 34](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql34.png?raw=true)

![SQL 35](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql35.png?raw=true)

![SQL 36](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql36.png?raw=true)

> *Con este resultado, sabemos que el segundo carÃ¡cter es mayor que la â€œlâ€ minÃºscula.*

A estas alturas, deberÃ­a comprender el fundamento de cada paso. Al observar el comportamiento de la aplicaciÃ³n en respuesta a varios comandos SQL inyectados, puede identificar y comprender eficazmente las vulnerabilidades de inyecciÃ³n SQL ciega.

En la siguiente secciÃ³n, demostraremos cÃ³mo explotar estas vulnerabilidades con la ayuda de SQLMap. ContinÃºe practicando estas tÃ©cnicas en un entorno controlado para perfeccionar sus habilidades y convertirse en un experto en la detecciÃ³n y explotaciÃ³n de ataques de inyecciÃ³n SQL ciega.

### **Ejemplo 1: ExplotaciÃ³n de la inyecciÃ³n SQL ciega**

Ahora que hemos confirmado la vulnerabilidad, seguiremos los pasos para explotarla usando SQLMap. Preste atenciÃ³n a las capturas de pantalla de cada paso para una mejor comprensiÃ³n. AÃºn mejor, sigue las instrucciones para consolidar realmente el proceso y el aprendizaje en tu mente y desarrollar esta habilidad.

**Paso 1: familiarizarse con SQLMap**

Abra la pÃ¡gina de ayuda de SQLMap para familiarizarse con el tipo de informaciÃ³n necesaria para un ataque y la estructura de comando de la herramienta. En concreto veremos que podemos utilizar una URL con la -ubandera y la informaciÃ³n de la cookie con la bandera `--cookie=COOKIE.`

`sqlmap -h`

![SQL 37](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql37.png?raw=true)

**Paso 2: recuperar informaciÃ³n de la sesiÃ³n**

Recopile las cookies requeridas y el nivel de seguridad del Panel de desarrollador del navegador en la pestaÃ±a Almacenamiento.

![SQL 38](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql38.png?raw=true)

**Paso 3: comando URL de SQLMap**

Ejecute SQLMap con la informaciÃ³n -uy --cookie=. Revise la informaciÃ³n resultante, que incluye los parÃ¡metros, la carga Ãºtil y la ubicaciÃ³n de los archivos de salida.

![SQL 39](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql39.png?raw=true)

> *SQLMap ejecutando ataque URL.*

![SQL 40](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql40.png?raw=true)

> *DevoluciÃ³n de parÃ¡metros y ubicaciÃ³n de salida.*

**Paso 4: abrir el archivo de sesiÃ³n**

Ahora iremos a la terminal y navegaremos hasta la ubicaciÃ³n del archivo de salida. Primero, lo usaremos para ver con quÃ© archivos tenemos para trabajar. UtilÃ­celo sqlitebrowserpara abrir el session.sqlitearchivo.

![SQL 41](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql41.png?raw=true)

**Paso 5: Navegador de base de datos**

En el navegador sqlite, examine la estructura de la base de datos y explore las pestaÃ±as de datos.

![SQL 42](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql42.png?raw=true)

> *VisualizaciÃ³n de la pestaÃ±a "Estructura de la base de datos" en DB Browser.*

![SQL 43](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql43.png?raw=true)

> *VisualizaciÃ³n de la pestaÃ±a "Buscar datos" en DB Browser.*

**Paso 6: ver el archivo de destino**

Regrese a la terminal y use cat target.txtpara ver el archivo que contiene el comando que usÃ³.

![SQL 44](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql44.png?raw=true)

**Paso 7: Ver registro**

Ãšselo cat log para ver el contenido del registro. Esto incluye la misma informaciÃ³n de parÃ¡metros y carga Ãºtil que vimos anteriormente, asÃ­ como detalles sobre la base de datos y la tecnologÃ­a de la aplicaciÃ³n web. Toda esta informaciÃ³n podrÃ­a ser Ãºtil en cualquier seguimiento de las pruebas de penetraciÃ³n que podamos realizar en etapas posteriores.

![SQL 45](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql45.png?raw=true)

**Paso 8: URL de SQLMap con indicador de nombre de base de datos**

Ahora regresaremos a la terminal y ejecutaremos el mismo comando en SQLMap, pero esta vez agregaremos '--dbs' para descubrir el nombre de la base de datos. Sabemos que tiene cuatro caracteres debido a nuestra prueba manual anterior, pero queremos saber mÃ¡s sobre esta base de datos.

![SQL 46](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql46.png?raw=true)

> *Â¡Y ahÃ­ estÃ¡, â€œdvwaâ€!*

**Paso 9: URL de SQLMap con indicador de columna**

A continuaciÃ³n, queremos obtener las columnas de usuario con las banderas -D dvwa -T users --columns. Esto le proporcionarÃ¡ mucha mÃ¡s informaciÃ³n sobre lo que realmente hay dentro de la base de datos.

![SQL 47](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql47.png?raw=true)

![SQL 48](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql48.png?raw=true)

**Paso 10: URL de SQLMap con indicador de volcado de usuario**

Ahora llegamos a la parte buena, utilÃ­cela -T users --dumppara extraer datos de la tabla del usuario. Revise la respuesta y observe cÃ³mo SQLMap le solicita que descifre el hash de las contraseÃ±as que descubre y luego le presenta los resultados en una tabla clara y ordenada.

![SQL 49](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql49.png?raw=true)

![SQL 50](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql50.png?raw=true)

> *AquÃ­ revisa la base de datos y extrae informaciÃ³n del usuario.*

![SQL 51](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql51.png?raw=true)

> *SQLMap ofrece descifrar los hashes de contraseÃ±as. Â¡SÃ­, por favor!*

![SQL 52](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql52.png?raw=true)

Observe la ordenada disposiciÃ³n de la informaciÃ³n en la imagen de arriba. AdemÃ¡s de simplemente descifrar las contraseÃ±as y colocarlas en una tabla ordenada, SQLMap tambiÃ©n genera automÃ¡ticamente esa informaciÃ³n en un archivo .csv. Luego, esto se puede incorporar a otras herramientas para realizar mÃ¡s exploits durante un caso de prueba de penetraciÃ³n.

### **Ejemplo 2: ExplotaciÃ³n de la inyecciÃ³n SQL ciega con datos HTTP**

Ahora demostraremos un mÃ©todo alternativo para explotar la inyecciÃ³n SQL ciega utilizando SQLMap y **la recopilaciÃ³n de datos HTTP de Burp Suite** .

**Paso 1: Intercepta el trÃ¡fico con Burp Suite**

Abra Burp Suite, que ha configurado para capturar el trÃ¡fico HTTP. Luego navegue hasta la pestaÃ±a Proxy y localice el envÃ­o de la consulta en el historial HTTP.

![SQL 53](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql53.png?raw=true)

**Paso 2: enviar solicitud al repetidor**

En el panel Solicitud, haga clic derecho en el envÃ­o de la consulta y seleccione 'Enviar al repetidor'.

**Paso 3: copie los datos sin procesar de Burp Suite**

Cambie a la pestaÃ±a Repetidor y copie los datos de la solicitud sin procesar del panel.

![SQL 54](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql54.png?raw=true)

**Paso 4: crear archivo de solicitud**

Pegue los datos de la solicitud sin procesar en un archivo nuevo que usarÃ¡ con SQLMap. En nuestro ejemplo, llamamos a este archivo request.

![SQL 55](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql55.png?raw=true)

**Paso 5: SQLMap carga el archivo de solicitud HTTP**

Regrese a la terminal y ejecute el comando sqlmap -r request. El -rindicador le indica a SQLMap que analice y utilice la solicitud HTTP sin formato del archivo especificado.

![SQL 56](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql56.png?raw=true)

Como en el mÃ©todo anterior, SQLMap ofrecerÃ¡ descifrar los hash de contraseÃ±a del usuario descubierto una vez que haya extraÃ­do los datos.

![SQL 57](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql57.png?raw=true)

> ğŸ‘‰ Este mÃ©todo proporciona una alternativa a la introducciÃ³n manual de informaciÃ³n de cookies y URL en la lÃ­nea de comando, lo que agiliza el proceso utilizando el trÃ¡fico HTTP capturado. Como en los mÃ©todos anteriores, esta informaciÃ³n se envÃ­a a su directorio y puede estudiarse o utilizarse para esfuerzos futuros.

</aside>

## **Defensa contra la inyecciÃ³n SQL ciega**

Si sigue las mejores prÃ¡cticas y pautas recomendadas por organizaciones acreditadas como **OWASP** , NIST, W3 y Amazon AWS, puede fortalecer significativamente las defensas de su aplicaciÃ³n contra estos ataques.

Estas organizaciones proporcionan informaciÃ³n y recursos valiosos que cubren una amplia gama de temas, incluidas prÃ¡cticas de codificaciÃ³n segura, seguridad de bases de datos, defensas de aplicaciones web y monitoreo y respuesta a incidentes. En esta secciÃ³n, exploraremos estas mejores prÃ¡cticas en detalle y le brindaremos pasos prÃ¡cticos para ayudar a proteger su aplicaciÃ³n web contra vulnerabilidades de inyecciÃ³n SQL ciega.

### **PrÃ¡cticas de codificaciÃ³n segura**

La implementaciÃ³n de prÃ¡cticas de codificaciÃ³n segura es crucial para defenderse contra ataques de inyecciÃ³n SQL ciega. **[OWASP recomienda utilizar declaraciones preparadas](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)** o consultas parametrizadas para separar la entrada del usuario del cÃ³digo SQL, lo que reduce el riesgo de inyecciÃ³n. AdemÃ¡s, la incorporaciÃ³n de tÃ©cnicas de validaciÃ³n de entradas, como las listas blancas, ayuda a **restringir los tipos de datos que pueden introducir** los usuarios, lo que mejora aÃºn mÃ¡s la seguridad.

### **Seguridad de la base de datos**

Las medidas de seguridad de la base de datos son esenciales para minimizar el impacto potencial de un ataque. Limitar los privilegios de los usuarios de la base de datos garantiza que los atacantes no puedan obtener acceso a informaciÃ³n confidencial ni realizar acciones no autorizadas. Actualizar y parchear periÃ³dicamente su sistema de administraciÃ³n de bases de datos ayuda a abordar las vulnerabilidades conocidas, lo que dificulta que los atacantes las exploten. Puede leer mÃ¡s sobre esto en **[NIST SP 800-44 versiÃ³n 2](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** (la SecciÃ³n 6.4.2 analiza esto especÃ­ficamente).

### **Defensas de aplicaciones web**

La implementaciÃ³n de defensas de aplicaciones web, como un firewall de aplicaciones web (WAF), puede ayudar a detectar y bloquear los intentos de inyecciÃ³n de SQL. **[Amazon AWS analiza](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-use-case.html)** cÃ³mo un WAF analiza el trÃ¡fico entrante y filtra solicitudes maliciosas a travÃ©s de grupos de reglas administrados por bases de datos, lo que reduce la probabilidad de un ataque exitoso.

### **Seguimiento y respuesta a incidentes**

Monitorear y registrar la actividad de las aplicaciones es vital para identificar actividades sospechosas y detectar posibles ataques desde el principio. **[NIST recomienda](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** establecer un sistema sÃ³lido de registro y monitoreo, junto con un plan de respuesta a incidentes bien definido, que garantice respuestas rÃ¡pidas y efectivas a los incidentes de seguridad.

## **ConclusiÃ³n**

A lo largo de este artÃ­culo, hemos profundizado en la inyecciÃ³n SQL ciega, explorando sus caracterÃ­sticas Ãºnicas y las tÃ©cnicas utilizadas para descubrir y explotar estas vulnerabilidades. Desde configurar un entorno de prueba con DVWA y Kali Linux hasta realizar pruebas manuales y utilizar herramientas como SQLMap y Burp Suite, le proporcionamos orientaciÃ³n prÃ¡ctica y consejos prÃ¡cticos para adquirir habilidades en este tema complejo.

AdemÃ¡s, hemos enfatizado la importancia de implementar medidas de seguridad sÃ³lidas, como prÃ¡cticas de codificaciÃ³n segura, seguridad de bases de datos, defensas de aplicaciones web y monitoreo y respuesta a incidentes para protegerse contra ataques de inyecciÃ³n SQL ciega.

Como hemos demostrado, la inyecciÃ³n ciega de SQL es un desafÃ­o formidable en la seguridad cibernÃ©tica para aplicaciones web, pero con el conocimiento y las habilidades adecuados, puede defenderse eficazmente contra estas amenazas. ContinÃºe su aprendizaje tomando estos cursos para reforzar su aptitud en defensa y piraterÃ­a Ã©tica de aplicaciones web:

## **Preguntas frecuentes**

- **Â¿CuÃ¡les son los tipos de inyecciÃ³n SQL ciega?**

Hay dos tipos principales de inyecciÃ³n SQL ciega:

**InyecciÃ³n SQL ciega basada en booleanos** : en este tipo, los atacantes infieren informaciÃ³n de las respuestas de la aplicaciÃ³n web, como cambios en el contenido, mensajes de error o cÃ³digos de estado HTTP, aunque el resultado de la consulta real no es directamente visible.

**InyecciÃ³n SQL ciega basada en el tiempo** : en este tipo, los atacantes introducen retrasos en sus consultas SQL utilizando funciones sensibles al tiempo (por ejemplo, SLEEP o WAITFOR DELAY) y observan el tiempo de respuesta de la aplicaciÃ³n web para inferir informaciÃ³n sobre la base de datos. Los diferentes tiempos de respuesta indican si la condiciÃ³n inyectada era verdadera o falsa.

- **Â¿QuÃ© es la respuesta condicional de inyecciÃ³n SQL ciega?**

Una respuesta condicional de inyecciÃ³n SQL ciega, tambiÃ©n conocida como inyecciÃ³n SQL ciega basada en contenido o booleana, es una tÃ©cnica utilizada por los atacantes para extraer informaciÃ³n de una aplicaciÃ³n web vulnerable sin ver directamente el resultado de sus consultas SQL inyectadas.

En cambio, los atacantes inyectan declaraciones SQL con condiciones verdaderas o falsas y observan cambios en el comportamiento o contenido de la aplicaciÃ³n web en funciÃ³n de la veracidad de estas condiciones. Al analizar estas respuestas, el atacante puede inferir indirectamente la informaciÃ³n que busca en la base de datos.

Piense en esto como un juego malicioso de 20 preguntas.

- **Â¿QuÃ© herramientas se pueden utilizar para explotar la inyecciÃ³n SQL ciega?**

Existen varias herramientas que se pueden utilizar para explotar las vulnerabilidades de inyecciÃ³n SQL ciega. Algunas de las herramientas mÃ¡s populares y efectivas incluyen:

1. SQLMap: SQLMap, una herramienta de cÃ³digo abierto poderosa y ampliamente utilizada, automatiza la detecciÃ³n y explotaciÃ³n de vulnerabilidades de inyecciÃ³n SQL.

2. Burp Suite: Esta es una plataforma integral de prueba de seguridad de aplicaciones web, que incluye una gama de herramientas para detectar y explotar vulnerabilidades de inyecciÃ³n SQL ciega, como los mÃ³dulos Repetidor e Intruso.

3. Pruebas manuales: si bien las herramientas automatizadas pueden resultar muy Ãºtiles, las pruebas manuales siguen desempeÃ±ando un papel esencial en la detecciÃ³n y explotaciÃ³n de vulnerabilidades de inyecciÃ³n SQL ciega.

- **Â¿CuÃ¡les son las seÃ±ales de que un sitio web es vulnerable a la inyecciÃ³n SQL ciega?**

Si bien ningÃºn indicador garantiza la presencia de una vulnerabilidad, los siguientes signos pueden sugerir que una aplicaciÃ³n web podrÃ­a ser susceptible a una inyecciÃ³n SQL ciega:

1. Comportamiento inesperado: si la aplicaciÃ³n muestra un comportamiento inusual cuando ciertos caracteres (como comillas simples o dobles) se ingresan en los campos de entrada del usuario, puede indicar que la aplicaciÃ³n no estÃ¡ manejando o desinfectando adecuadamente la entrada del usuario.

2. Respuestas condicionales: al inyectar consultas SQL que deberÃ­an devolver verdadero o falso, si la aplicaciÃ³n muestra un comportamiento diferente segÃºn la veracidad de la condiciÃ³n inyectada, puede sugerir una vulnerabilidad de inyecciÃ³n SQL ciega.

3. Retrasos de tiempo: la aplicaciÃ³n experimenta retrasos notables en el tiempo de respuesta cuando se inyectan consultas SQL especÃ­ficas (por ejemplo, al usar la SLEEP()funciÃ³n).

4. Mensajes de error: si bien es posible que los mensajes de error no sean directamente visibles en los ataques de inyecciÃ³n SQL ciega, se debe evaluar cualquier mensaje de error o respuesta inusual de la aplicaciÃ³n.

- **Â¿CuÃ¡les son las mejores prÃ¡cticas para prevenir la inyecciÃ³n SQL ciega?**

Las mejores prÃ¡cticas para prevenir la inyecciÃ³n ciega de SQL implican una combinaciÃ³n de prÃ¡cticas de codificaciÃ³n segura, medidas de seguridad de bases de datos, defensas de aplicaciones web y estrategias de monitoreo y respuesta a incidentes.

**Advanced SQL Injection**

La inyecciÃ³n SQL avanzada es una tÃ©cnica mÃ¡s sofisticada que la inyecciÃ³n SQL bÃ¡sica, que utiliza tÃ©cnicas mÃ¡s complejas para explotar vulnerabilidades en las aplicaciones web. Esto puede incluir la manipulaciÃ³n de los datos de entrada de la aplicaciÃ³n, la identificaciÃ³n de patrones de filtrado, la explotaciÃ³n de errores en la aplicaciÃ³n y la utilizaciÃ³n de herramientas automatizadas para la inyecciÃ³n de cÃ³digo malicioso. Este ataque puede tener consecuencias graves, como la exposiciÃ³n de informaciÃ³n confidencial, el robo de datos, la alteraciÃ³n de la informaciÃ³n almacenada en la base de datos y la pÃ©rdida de datos importantes. Por lo tanto, es importante que las empresas y desarrolladores de aplicaciones web implementen medidas de seguridad adecuadas para evitar este tipo de ataques.

![SQL 58](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql58.png?raw=true)

## Consecuencias

Las consecuencias de una inyecciÃ³n SQL Avanzadas pueden incluir:

- **PÃ©rdida o alteraciÃ³n de datos:** el atacante puede eliminar, modificar o extraer informaciÃ³n de la base de datos.
- **Inestabilidad del sistema:** el cÃ³digo malicioso puede causar que la base de datos deje de funcionar correctamente, lo que puede resultar en tiempos de inactividad y pÃ©rdida de disponibilidad.
- **Dificultad para detectar y mitigar el ataque:** debido a que el cÃ³digo malicioso se inserta en una consulta SQL legÃ­tima.
- **Posibilidad de propagaciÃ³n del ataque:** si el atacante tiene acceso a datos sensibles, como contraseÃ±as de usuario, puede utilizarlos para propagar el ataque a otros sistemas.
- **Acceso no autorizado:** un atacante podrÃ­a obtener acceso no autorizado al sistema o a la aplicaciÃ³n web, lo que le permitirÃ­a acceder a informaciÃ³n confidencial o realizar acciones maliciosas en el sistema.
- **ModificaciÃ³n de datos:** un atacante podrÃ­a modificar, eliminar o agregar datos al sistema, lo que podrÃ­a tener graves consecuencias en la integridad y exactitud de los datos.
- **EjecuciÃ³n de cÃ³digo malicioso:** un atacante podrÃ­a ejecutar cÃ³digo malicioso en el sistema, lo que podrÃ­a resultar en la toma de control del sistema o en el robo de informaciÃ³n confidencial.
- **DenegaciÃ³n de servicio:** un atacante podrÃ­a utilizar la inyecciÃ³n de comando para sobrecargar el sistema y hacer que se vuelva inoperable.

**La no correcciÃ³n de esta falla puede causar divulgaciÃ³n no autorizada de su informaciÃ³n y la de sus clientes que podrÃ­a dar lugar a fraude, usurpaciÃ³n de identidad y a sanciones reglamentarias.** Para evitar la inyecciÃ³n de comandos, es importante validar y filtrar todas las entradas de usuario en las aplicaciones web, y evitar el uso de comandos de shell en aplicaciones web.Â  AdemÃ¡s, es importante mantener todas las aplicaciones y sistemas actualizados y parcheados para evitar que se exploten vulnerabilidades conocidas.

## SoluciÃ³n

Para prevenir y solucionar la inyecciÃ³n SQL avanzada, se pueden tomar las siguientes medidas:

- **Validar y sanitizar todas las entradas de datos**: AsegÃºrese de que todas las entradas de datos, ya sean proporcionadas por los usuarios o por otras fuentes, sean validadas y sanitizadas adecuadamente antes de ser utilizadas en una consulta SQL.
- **Utilizar consultas parametrizadas:** En lugar de construir una consulta SQL dinÃ¡micamente utilizando cadenas de texto, utilice consultas parametrizadas que permitan que los parÃ¡metros sean pasados como argumentos separados. Esto reducirÃ¡ la posibilidad de inyecciÃ³n SQL, ya que los valores de los parÃ¡metros son tratados como datos, no como parte de la consulta SQL.
- **Limitar los permisos de la base de datos:** AsegÃºrese de que los usuarios de la base de datos tengan solo los permisos necesarios para realizar sus funciones y nada mÃ¡s. Esto limitarÃ¡ el alcance de cualquier posible ataque.
- **Utilizar herramientas de seguridad y pruebas de penetraciÃ³n:** Realice pruebas regulares de seguridad y pruebas de penetraciÃ³n en la aplicaciÃ³n para identificar posibles vulnerabilidades y errores de seguridad. TambiÃ©n puede utilizar herramientas de seguridad de terceros para proteger la aplicaciÃ³n contra la inyecciÃ³n SQL.
- **ActualizaciÃ³n y parcheo del software de la base de datos y uso de firewalls de aplicaciÃ³n web (WAF)**

Es una tarea difÃ­cil determinar si una cadena de usuario es maliciosa o no. Por lo tanto, la mejor manera de hacerlo es â€œescaparâ€ de los caracteres especiales en la entrada del usuario. Puede escapar una cadena antes de construir la consulta en PHP usando la funciÃ³n `mysql_escape_string()`. O en MySQL usando la funciÃ³n `mysqli_real_escape_string()`.

Mientras se muestra la salida como HTML, tambiÃ©n tendrÃ¡ que convertir la cadena para asegurarse de que los caracteres especiales no interfieren con el marcado HTML. Puede convertir caracteres especiales en PHP usando la funciÃ³n htmlspecialchars().

> ğŸ‘‰ Alternativamente, puede usar sentencias preparadas para evitar las inyecciones de SQL. Una sentencia preparada es una plantilla de una consulta SQL, en la que se especifican los parÃ¡metros en una etapa posterior para ejecutarla. AquÃ­ hay un ejemplo de una declaraciÃ³n preparada en PHP y MySQLi.

</aside>

`$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

`$query->execute(array($username, $password));`

> ğŸ“– En resumen, para solucionar y prevenir la inyecciÃ³n SQL avanzada, es necesario validar y sanitizar todas las entradas de datos, utilizar consultas parametrizadas, limitar los permisos de la base de datos y utilizar herramientas de seguridad y pruebas de penetraciÃ³n.

</aside>

## Referencias

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)
- [https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)
