---
title: "Understanding SQL Injection: The Second Most Critical OWASP Vulnerability"
subtitle: "Learn all about SQL Injection"
tags: ["pentesting", "cybersecurity", "sql"]
authors: ["blindma1den", "lorenagubaira"]

---

> âœ‹ This article assumes you have a basic understanding of [creating an API endpoint using HTTP](https://4geeks.com/lesson/building-apis-with-python-flask) and pass variables either as query strings or form values.

## What is SQL Injection?

SQL Injection is a web vulnerability that allows an attacker to interfere with the queries a website makes to its database. It can enable unauthorized access to data, including sensitive information.

## When Does it Happen and Why?

SQL Injection occurs when an application fails to properly sanitize user inputs before using them in SQL queries. When user input is directly incorporated into a query, malicious actors can inject SQL code to manipulate the query, accessing or modifying unauthorized data. The key reason behind SQL injection vulnerabilities is improper validation or filtering of user input, allowing harmful SQL commands to be executed.

## Difference Between Classic and Blind SQL Injection

- **Classic SQL Injection**: Direct feedback is provided by the database, which helps attackers exploit the vulnerability faster.
  
- **Blind SQL Injection**: No visible error messages are displayed, making it harder to exploit. Attackers rely on true/false responses to infer whether the injection was successful.

## Step-by-Step Python Example Using Python Flask

Below are examples of classic and blind SQL injection vulnerabilities using Python with Flask.

### 1. Classic SQL Injection in Flask

Here is the sample code for a Flask API that contains an SQL Injection Vulnerability

```python
from flask import Flask, request
import sqlite3

# We create a new website
app = Flask(__name__)

# We specify that the website will have a /classic directory url, for example: mywebsite.com/classic
@app.route('/classic')
def classic_sql_injection():
    # the variable "id" is received from the URL, for example: mywebsite.com/classic?id=1
    user_id = request.args.get('id')

    conn = sqlite3.connect('example.db')
    cur = conn.cursor()   
    # Here is the vulnerability, the variable user_id could contain any value, including SQL Statements.
    query = f"SELECT * FROM users WHERE id = {user_id}"  # Vulnerable code
    cur.execute(query)
    result = cur.fetchone()
    conn.close()
    
    if result:
        return f"User found: {result}"
    return "User not found"

if __name__ == "__main__":
    app.run(debug=True)
```

### Exploiting Classic SQL Injection

An attacker can manipulate the `id` parameter with the vollowing value ` as follows:

```
http://your-website.com/classic?id=1 OR 1=1
```

This will return all users because the query becomes:

```sql
SELECT * FROM users WHERE id = 1 OR 1=1;
```

### 2. Blind SQL Injection in Flask

```python
@app.route('/blind')
def blind_sql_injection():
    user_id = request.args.get('id')
    conn = sqlite3.connect('example.db')
    cur = conn.cursor()
    query = f"SELECT * FROM users WHERE id = {user_id} AND name='John'"  # Vulnerable code
    cur.execute(query)
    result = cur.fetchone()
    conn.close()

    if result:
        return "User exists"
    return "User does not exist"
```

### Exploiting Blind SQL Injection

Blind SQL Injection works without direct output. For instance, if an attacker wants to check if a user exists:

```
http://localhost:5000/blind?id=1 AND 1=1
```

This won't reveal data directly but allows inference through whether the result is `"User exists"` or `"User does not exist"`.

## Steps to Fix SQL Injection

1. **Use Prepared Statements** (also known as parameterized queries):
   Instead of directly inserting user input into SQL queries, use prepared statements to safely bind parameters to queries.

   Example:

   ```python
   query = "SELECT * FROM users WHERE id = ?"
   cur.execute(query, (user_id,))
   ```

2. **Input Validation**:
   Validate the type, length, and format of user inputs before processing them in queries. Reject any inputs that do not conform to expected patterns.

3. **ORMs (Object-Relational Mapping)**:
   Using ORMs like SQLAlchemy in Python abstracts the raw SQL queries and prevents injection by design.

4. **Stored Procedures**:
   Use stored procedures instead of dynamic SQL queries for critical database interactions.

5. **Error Handling**:
   Prevent database errors from being displayed to users, as they can leak valuable information about the system.

## What Can Hackers Do With SQL Injection?

- **Data Exfiltration**: Hackers can access sensitive information stored in the database, such as usernames, passwords, credit card details, etc.
- **Database Manipulation**: Attackers may alter or delete data, or insert malicious entries.
- **Authentication Bypass**: By manipulating login queries, attackers can bypass authentication systems and gain unauthorized access.
- **Access to Entire Systems**: Advanced SQL Injection can lead to full control over the underlying server or infrastructure.

## Best Practices to Prevent SQL Injection

1. **Use Parameterized Queries**: Avoid including raw user input in SQL queries.
2. **Validate User Inputs**: Only allow inputs that match expected formats.
3. **Escape Special Characters**: Escape characters like `'`, `"`, and `;` to prevent query manipulation.
4. **Use ORM Libraries**: An ORM abstracts raw SQL queries, making SQL injection attacks less likely.
5. **Least Privilege**: Ensure that database users have only the minimum necessary privileges.
6. **Regular Security Audits**: Perform regular code reviews and use automated tools to scan for SQL injection vulnerabilities.

## Examples of SQL Injection Categories

### 1. Error-Based Injection

An attacker forces the database to generate an error that reveals details about the database schema.

**Example**:
```
http://example.com/page?id=1' AND 1=CONVERT(int, 'test')
```

The database error message might leak valuable information about the data type or structure.

### 2. Union-Based Injection

Union queries allow attackers to combine the results of two different queries.

**Example**:
```
http://example.com/page?id=1 UNION SELECT username, password FROM users
```

This retrieves the contents of the `users` table.

### 3. Blind Injection

No error messages are shown, but an attacker can infer the result of queries through true/false conditions.

**Example**:
```
http://example.com/page?id=1 AND 1=1 -- True, page loads normally
http://example.com/page?id=1 AND 1=2 -- False, different behavior
```

### 4. Time-Based Blind Injection

The attacker can exploit time delays to infer the success of their queries.

**Example**:
```
http://example.com/page?id=1 AND IF(1=1, SLEEP(5), 0)
```
You can add a section in the article that addresses SQL injection via cookies and localStorage. Here's how you might incorporate it into the existing content:

## SQL Injection Through Cookies and LocalStorage

In addition to injecting malicious SQL through query strings and form values, attackers can also exploit insecure data storage mechanisms such as cookies and localStorage. These mechanisms are often used by web applications to store session-related information or user preferences, but if the data stored is used unsafely in SQL queries, it can lead to injection vulnerabilities.

### Example of SQL Injection Via Cookies

Let's assume you have a web application that stores the user's ID in a cookie and uses this ID to retrieve data from the database. Here's a vulnerable example in Flask:

```python
from flask import Flask, request
import sqlite3

app = Flask(__name__)

@app.route('/cookie')
def cookie_sql_injection():
    user_id = request.cookies.get('user_id')  # Retrieve user ID from cookie
    conn = sqlite3.connect('example.db')
    cur = conn.cursor()
    
    query = f"SELECT * FROM users WHERE id = {user_id}"  # Vulnerable code
    cur.execute(query)
    result = cur.fetchone()
    conn.close()
    
    if result:
        return f"User found: {result}"
    return "User not found"

if __name__ == "__main__":
    app.run(debug=True)
```

In this example, the `user_id` stored in the cookie is directly used in the SQL query without proper sanitization. An attacker can modify the cookie in their browser's developer tools and inject SQL code.

**Exploiting the vulnerability:**

The attacker could manipulate the `user_id` cookie to inject a malicious SQL query:

```
user_id=1 OR 1=1;
```

This will modify the query to:

```sql
SELECT * FROM users WHERE id = 1 OR 1=1;
```

As a result, all users will be retrieved from the database, and sensitive data could be leaked.

### Example of SQL Injection Via LocalStorage

LocalStorage is a browser-based storage mechanism that allows web applications to store data on the client side. If an application retrieves data from localStorage and directly uses it in SQL queries without validation, this can lead to SQL injection vulnerabilities.

In a front-end JavaScript app, the `user_id` could be retrieved from localStorage and passed as part of an HTTP request to the Flask API:

```javascript
// Simulating vulnerable code in front-end
let userId = localStorage.getItem("user_id");
fetch(`/localstorage?user_id=${userId}`)
  .then(response => response.text())
  .then(data => console.log(data));
```

Attackers can easily manipulate `localStorage` data through the browser's developer tools:

```javascript
localStorage.setItem("user_id", "1 OR 1=1");
```

This would allow an SQL injection attack similar to the cookie example.

### How to Prevent SQL Injection via Cookies and LocalStorage

To prevent SQL injection through cookies or localStorage, follow these guidelines:
- **Never trust client-side data**: Treat all data received from the client (whether via cookies, localStorage, or query parameters) as untrusted and potentially dangerous.
- **Use Prepared Statements**: Instead of dynamically constructing SQL queries with user input, always use parameterized queries.
  
   Example of fixing the above code:

   ```python
   query = "SELECT * FROM users WHERE id = ?"
   cur.execute(query, (user_id,))
   ```
   
- **Sanitize and Validate Input**: Ensure that any data coming from cookies or localStorage is sanitized and validated before using it in queries. Only allow expected formats (such as integers for user IDs) and reject malformed input.
- **Encrypt Cookies**: Always encrypt sensitive data stored in cookies and validate the integrity of the cookie data before using it.
  
