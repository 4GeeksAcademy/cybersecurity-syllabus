# How to bypass firewalls by hiding all traffic on HTTPS (SSL) 443 encapsulated traffic

Generally, when behind a public or blocked firewall, most outbound (outgoing) traffic allowed is port 80(http) and 443(https). This is to allow only web browsing and prevent the use of other applications and services such as email or gaming. Outgoing web traffic can also be restricted by content filtering, allowing what type of websites can be accessed. Another major concern is privacy. When you use public networks or even use your own ISP's network, all your traffic is visible to them.

With this reverse proxy setup, we can mask all of our traffic to essentially appear as HTTPS traffic, allowing us to bypass many of these restrictions. This can also be used as an alternative to VPNs or in conjunction with VPNs to further mask traffic and provide more privacy. This method will work in most situations. Sometimes SSL inspection is configured or advanced content filtering and/or threat intelligence is leveraged, which increases traffic blocking factors. However, these scenarios typically only occur in mature corporate environments and not on average public networks.

We will host a reverse proxy on the Internet. With a tool called Stunnel, we can create an encrypted port forwarding tunnel over a 443 (HTTPS) connection. We will then use that port forwarding to create a hidden SSH tunnel inside the encrypted 443(SSL) traffic, which will allow us to set up a nested socket proxy OR a port forwarding, which in turn will allow us to send any traffic we want outside the network.

![firewall-bypass](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/firewall-bypass.png?raw=true)

### Requirements

For this implementation, I will use an Ubuntu 23.04 VPS (virtual private server) for the reverse proxy server and Kali 6.3.0 for the client machine. This configuration does not require these operating systems specifically. If you decide to use different operating systems, make sure the tools are compatible.

Reverse proxy server:

- [LetsEncrypt (free SSL certificate service)](https://letsencrypt.org/docs/faq/)
- Purchased domain to create a valid SSL certificate (can be an inexpensive domain, i.e. $1.99/year)

Tools/Services

- [apache2](https://httpd.apache.org/)
- [certbot](https://certbot.eff.org/)
- [stunnel(server mode)](https://www.stunnel.org/)

Client machine:

Tools

- [stunnel(client mode)](https://www.stunnel.org/)

### Configuration

Reverse Proxy Server

The server will require the most configuration effort. Since this is a new Ubuntu installation, we will update and upgrade the server.

```bash
sudo apt update && sudo apt upgrade -y
```

Now, we need to install the apache2 service and then run certbot to receive our SSL certificate from LetsEncrypt. This allows us to receive a signed SSL certificate related to our domain for the reverse proxy server.

**Install Apache2**

```bash
sudo apt update

sudo apt install apache2
```

Considering that the server runs services and is accessible from the Internet, we will create host-based firewall rules.

Create host-based firewall rules

```bash

sudo ufw allow 22/tcp

sudo ufw allow 80/tcp

sudo ufw allow 443/tcp
```

Feel free to add more firewall rules as needed for any other services you decide to run. Now that the rules have been created, we need to enable them.

Enable firewall rules

```bash
sudo ufw reload
```

Enable Apache2 service

```bash
sudo systemctl start apache2
```

Now, as explained on the certbot website, we will use the apache2 service to request our signed SSL certificate for the purchased domain. If you don't already have one, this is the time to purchase a domain before proceeding. The domain we purchase is important because this is where all of our tunneled traffic will be seen as it passes through the network and firewall. Choose a generic or innocent domain name with a common top level domain such as .com, .net, .io, etc. (Threat intelligence firewalls have been known to block cheap or uncommon domains such as .xyz).

The registrar usually provides DNS services that you will use for the domain you purchased. Once you have created a DNS A record and pointed to your reverse proxy server, you are ready to receive your SSL certificate using certbot. Certbot is a script that automates the creation of SSL certificates with LetsEncrypt. For specific instructions, which may vary depending on your reverse proxy server's operating system, [visit here](https://certbot.eff.org/instructions)

**Install Certbot**

```bash
sudo snap install --classic certbot

sudo ln -s /snap/bin/certbot /usr/bin/certbot
```

Before running cerbot, we will edit the configuration file /etc/apache2/sites-available/000-default.conf so that the cerbot script can identify our server by the acquired domain name.

Editing the Apache2 configuration file

```bash
sudo vim /etc/apache2/sites-available/000-default.conf
```

Add the following line to the configuration file.

```bash
ServerName yourdomain.net
```

![yourdomain.net](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net.png?raw=true)

Now it is time to receive our SSL certificate and start configuring Stunnel.

Run certbot

```bash
sudo snap install --classic certbot
```

Once this runs successfully, you should see the result of where your new SSL certificate and private key are located.

```bash
cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem

key = /etc/letsencrypt/live/yourourdomain.net/privkey.pem
```

We no longer need the apache2 service now that we have used certbot to obtain our valid SSL certificate. The service must be stopped so that Stunnel can later use the 443 listening port.

Stop the Apache2 service

```bash
sudo systemctl stop apache2
```

Stunnel can now be configured. Install it on the reverse proxy server.

Install Stunnel

```bash
sudo apt update

sudo apt install stunnel4
```

Create/edit the Stunnel configuration file on the server to use our new SSL certificate. We will define its listening port and forwarding instructions.

```bash
sudo vim /etc/stunnel/stunnel.conf
```

Add the following lines to the configuration file

```bash
pid = /var/run/stunnel.pid

cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem

key = /etc/letsencrypt/live/yourourdomain.net/privkey.pem

[ssh]

accept = 0.0.0.0.0:443

connect = localhost:22
```

![yourdomain.net1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net1.png?raw=true)

Edit the additional Stunnel configuration file to enable the service

```bash
sudo vim /etc/default/stunnel4
```

Add the following line to the end of the configuration file

> ENABLED=1

![yourdomain.net2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net2.png?raw=true)

Start the tunnel service

```bash
sudo /etc/init.d/stunnel4 restart
```

To make sure that the Stunnel service is running and listening on the specified port 443, run the following command

```bash
sudo netstat -ano | grep tcp
```

![yourdomain.net3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net3.png?raw=true)

If you see that your reverse proxy server is listening on port 443 after starting the Stunnel service, you are all set! Now let's move on to the client machine, configure the Stunnel client, and start bypassing it.

### Client machine

Update and upgrade the new Kali installation on the client machine.

```bash
sudo apt update && sudo apt upgrade -y
```

Now that our client machine is updated and ready to go, we need to install Stunnel.

**install Stunnel**

```bash
sudo apt install stunnel4
```

Create a configuration file for the Stunnel client. This can be created anywhere, but I will create mine in the $HOME directory.

Create configuration file

```bash
vim $HOME/stunnel-client.conf
```

Add the following lines to the configuration file

```bash
pid = /tmp/stunnel.pid

client=yes

[ssh]

accept=9443

connect=yourdomain.net:443
```

![Client1 Machine](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente1.png?raw=true)

Run the Stunnel client to connect to the reverse proxy server by setting up the SSL(443) tunnel

```bash
sudo stunnel $HOME/stunnel-client.conf
```

Now confirm if the client is listening on its forwarding port defined in the configuration file.

```bash
sudo netstat -an | grep tcp
```

![Client2 Machine](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente2.png?raw=true)

**Avoiding**

The reverse proxy server is fully installed and configured. We can successfully connect from our client machine using Stunnel to create the SSL (443) tunnel. Now we will configure our SSH forward port or sockets proxy which will be hidden inside our SSL (443) tunnel.

SSH sockets 4/5 Proxy

This SSH tunnel will open a socket proxy on the client machine that will forward any traffic sent to it through the SSH tunnel that is hidden inside the SSL (443) tunnel.

Create the SSH sock proxy tunnel

```bash
sudo ssh -D 9090 -q -C -N <user>@127.0.0.1 -p 9443
```

- D : specifies the listening port of the socks proxy on the client
- q : runs quiet mode where no output is displayed locally
- C : compress data in the tunnel to save bandwidth
- N : non=interactive ssh session just creats the tunnel, no command prompt
- p : defines the destination port to connect to (We are connecting to port forward provided by Stunnel client)

![Client Machine3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente3.png?raw=true)

SSH port forwarding

This SSH tunnel will create a listening port on the client machine to forward traffic through the SSH tunnel that is hidden inside the SSL (443) tunnel.

Creating the SSH port forwarding tunnel

```bash
sudo ssh -q -C -N -L 9090:<destination ip>:<destination port> <user>@127.0.0.1 -p 9443
```

- L : specifies the listening port of the port forward on the client
- q : runs quiet mode where no output is displayed locally
- C : compress data in the tunnel to save bandwidth
- N : non-interactive ssh session just creats the tunnel no command prompt
- p : defines the destination port to connect to (We are connecting to port forward provided by Stunnel client)

![Client Machine4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente4.png?raw=true)

## Conclusion

With this configuration and reverse proxy server technique, we can make all O-specific traffic appear as HTTPS(443). Once the client establishes its SSL tunnel with the reverse proxy server, the firewall cannot distinguish between our SSL tunnel and normal HTTPS(443) traffic due to encryption. On public networks in general, this is sufficient to bypass firewall restrictions. This also works as a VPN alternative in networks where VPN traffic is blocked. Remember that only TCP traffic can pass through the SSH Socks proxy or port forwarding.

When it comes to advanced firewalls, many additional factors can determine whether the SSL connection is allowed through port 443. More advanced firewalls can not only perform SSL inspection (decryption) but can also make decisions to allow traffic based on the destination geographic IP address, location, SSL certificate attributes, domain categorization, and domain reputation. This is where it is crucial to choose a domain with a common TLD (top-level domain) and a generally trusted country to host the reverse proxy server.

> 👉 It would be recommended to register an expired domain that already has URL categorization and a good reputation. If you have purchased a new domain, there are ways to categorize it and create a domain reputation. These will not be covered here but will be addressed in another blog. If you made it this far, I hope it was helpful and I'm sure you'll come up with some creative use cases for this setup.

It is essential to first understand how a firewall works before attempting to hack into it. A firewall tracks all network traffic, both inbound and outbound, and, depending on the rules that have been configured, allows or prohibits that traffic from reaching its destination. The fact that firewalls are often the initial line of defense in a network makes them an example of perimeter security.

Let's summarize everything written above. Always think outside the box. Try different encryption techniques and some will work. Don't be lazy to check DNS records. Don't forget that any protection on web resources can be circumvented, and WAF is not a panacea for all problems. Hackers don't sleep and are always looking for new techniques to attack your resources and make a profit. Periodic penetration testing will help you avoid many problems.
