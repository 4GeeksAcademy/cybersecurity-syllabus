---
title: "Guía Completa de IPTables"
subtitle: "Domina IPTables y protege tu red con técnicas avanzadas de firewall"
tags: ["pentesting", "ciberseguridad"]
authors: ["blindma1den", "lorenagubaira"]

---

### ¿Qué se puede hacer con iptables?

Uno de sus usos principales es analizar el tráfico para **ver las características de los paquetes**. Para esto se implementa un cortafuegos que controla el tráfico.Por otro lado, también permiten utilizar una tecnología tan importante como es la NAT, que se basa en la traducción de redes. Se puede configurar un dispositivo para NAT con iptables, independientemente del Firewall.

Otra función interesante es la de marcar los paquetes. Esto se suele hacer con el uso de iptables, para que esos paquetes pasen a otros programas, y estos en función de las etiquetas, hacen una cosa u otra. Esto se realiza mediante mangle que, con el marcado, prepara los paquetes para un procesamiento futuro.

### Combinar con otros servicios

Las iptables resultan una herramienta muy potente y flexible, y nos ayudan mucho en cuanto al control del tráfico en sistemas basados en Linux. Lo cual es muy útil para proteger los servicios que dependen de estos servidores. Lo cuales podemos encontrar en una grandísima cantidad de servicios actualmente. Uno de los problemas que nos podemos encontrar, es que, para poder implementarlas con otros servicios, es necesario llegar a utilizar código para que todo salga a la perfección. Ante esto, debemos tener en cuenta que cualquier cambio que se realice de forma incorrecta en las reglas, puede hacer que todo el tráfico de la red se quede bloqueado. Por lo cual siempre es recomendable dar uso de copias de seguridad, para tener siempre una vía de recuperación.

> Algunos de los ejemplos de uso más básicos son:

- **Servidores web HTTP/HTTPS**.
- **Servidores SSH**.
- **Servidores SMTP**.

También es posible implementarlas para disponer de algunas políticas por defecto, como puede ser la denegación de todo. Es común que muchos lugares utilicen estas políticas predefinidas, en lugar de crear las suyas. En este caso, siempre tendremos una disponible que negará todo el tráfico, y luego abrir solo los puertos que sea explícitamente necesarios para lo que vamos a necesitar. En todo caso, estos ejemplos son los más básicos. Iptables puede ser implementado en muchos más sistemas y muy complejos. Como limitar la tasa de tráfico, bloquear direcciones IP, loguear tráfico y muchas más opciones. Siempre se debe recordar, que las reglas no persisten después de los reinicios. Por lo cual será necesario dar uso de scripts que programemos, y que se ejecuten al inicio de la sesión. De este modo estarán siempre disponibles. El problema de todo esto es que, para la programación, es necesario tener conocimientos sobre el código necesario para estas herramientas.

### Calcular iptables

El cálculo de iptables, implica que se deben definir las reglas en una tabla, y que sean aplicadas a la entrada y salida del tráfico. Para ello se debe seguir un conjunto de cadenas predefinidas, las cuales con INPUT, OUTPUT y FORWARD. Estas son las encargadas de determinar el tráfico que se debe analizar. Pero para poder calcularlas, se deben conocer las reglas de las mismas.

- **Criterios de procedencia:** Se deben establecer las condiciones para que los paquetes puedan aplicar las reglas. Esto incluye información como las direcciones IP de origen y destino, así como los puertos, protocolos y otras características que puede tener un paquete.
- **Acción:** Se tiene que definir la acción que se va a tomar cuando se cumplan ciertos criterios de coincidencia. Estas pueden ser ACCEPT, DROP y REJECT. Donde se acepta el paquete, se rechaza o incluso se llega a descartar por completo.
- **Orden de las reglas:** Debemos saber que las reglas se van a evaluar de forma secuencial. Esto hace que el orden en el cual se establecen, sea sumamente importante, ya que determinará la acción que se va a realizar primero. Lo más recomendable es buscar un orden lógico, y que sea coherente con todas las demás reglas que se establecen.

Pero eso no es todo, sino que para poder calcular las iptables, debemos tener en cuenta algunos factores que son muy importantes.

- **Seguridad:** Al fin y al cabo, las iptables se utilizan para proteger a los sistemas de posibles amenazas externas. Por lo cual se debe pensar en la seguridad cuanto nos encontramos manipulando este tipo de parámetros.
- **Rendimiento:** Se debe realizar un cálculo eficiente, el cual se encuentre totalmente optimizado. Esto minimizará la cantidad de reglas que vamos a necesitar, reduciendo también todas las posibles redundancias que se pueden generar. Lo cual puede producir una sobreocupación de reglas.
- **Flexibilidad:** Las iptables son una característica muy flexible a la hora de definir lo que pueden hacer. Es por ello que se pueden establecer condiciones muy específicas para poder adaptarse a prácticamente cualquier necesidad que tenga el sistema que estamos manejando.

Una vez que ya conocemos las principales características, vamos a enseñar el funcionamiento y la arquitectura de este cortafuegos.

**Funcionamiento y arquitectura**

Este cortafuegos se basa en reglas que iremos introduciendo una tras otra, su funcionamiento se basa en aplicar reglas que el propio firewall se encargue de ejecutar. Aunque en un primer momento **iptables** pueda parecer sencillo de usar, si quieres hacerlo de forma avanzada, es más complicado. A continuación, podés ver un esquema resumido del funcionamiento de iptables.

![iptables1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/iptables1.es.png?raw=true)

**La estructura de iptables** se basa en tablas, muchas de ellas ya están creadas de forma predeterminada. Dentro de las tablas tenemos las cadenas, que también tenemos algunas creadas de forma predeterminada. Finalmente, dentro de las cadenas tenemos las diferentes reglas que podemos configurar. En la siguiente foto podés ver un pequeño esquema de cómo quedaría la arquitectura del firewall:

![iptables2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/iptables2.es.png?raw=true)

De forma predeterminada tenemos un total de cuatro tablas:

- **Tabla filter**: es la tabla por defecto, si no definimos una tabla para añadir una regla, siempre se irá a la tabla filter. En esta tabla tenemos un total de tres cadenas por defecto, dependiendo de lo que nos interese, tendremos que usar una cadena u otra: INPUT (son los paquetes en sentido entrante, al propio firewall), OUTPUT (son los paquetes en sentido saliente, desde el servidor hacia fuera), y FORWARD (sirve para filtrar los paquetes que van de una interfaz de red a otra).
- **Tabla nat**: esta tabla se encarga de hacer el NAT, transformar la IP privada en pública y al revés. Dentro de NAT tenemos tres cadenas: PREROUTING (altera los paquetes antes de enrutarlos, aquí se hace el DNAT o reenvío de puertos), POSTROUTING (altera los paquetes después de enrutarlos, aquí se hace el SNAT o MASQUERADE) y OUTPUT (paquetes generados por el firewall que atravesará el NAT configurado).
- **Tabla mangle**: esta tabla se encarga de hacer la alteración de los paquetes, es donde se configura el QoS para la calidad del servicio, alterar cabeceras TCP etc. En esta tabla tenemos las cinco cadenas: PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING.
- **Tabla raw**: esta tabla no se suele usar porque los paquetes viajan sin estado de conexión. Tenemos la cadena PREROUTING y OUTPUT.

Para hacer todo esto, utiliza algunas reglas de filtrado que nos indicarán que paquetes serán aceptados y cuales rechazados o directamente, omitidos. Estas cadenas de datos la forman:

- **INPUT**: Se refiere a los paquetes que llegan al sistema.
- **OUTPUT**: Filtra los paquetes que salen de nuestra red.
- **FORWARD**: No indica el tráfico del router que es enviado a otros equipos.

En la siguiente imagen podes ver un pequeño resumen de las cadenas que tenemos en las diferentes tablas:

![iptables3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/iptables3.es.png?raw=true)

El funcionamiento a la hora de **añadir una regla** es el siguiente:

- Las reglas que incorporamos a las cadenas siempre tienen un objetivo (-j en la regla).
- Cuando el firewall recibe un paquete, comprueba si el paquete concuerda con una regla que hayamos dado de alta. Si concuerda, se ejecuta el orden objetivo, si no, pasa a la siguiente regla hasta el final de la cadena.
- Las reglas se verifican en un orden secuencial, desde la primera regla hasta la última. Es muy importante el orden, si bloqueamos todo primero y luego permitimos algo más específico, bloquearemos todo el tráfico y la regla más específica no se comprobará.
- En el caso de que ninguna regla satisfaga el paquete, entonces se utilizará la política de la cadena que tengamos (regla global).

Los objetivos que tienen las diferentes reglas son las siguientes:

- **ACCEPT**: acepta el paquete y lo pasa al siguiente nivel, un servidor web, SSH, FTP etc.
- **DROP**: bloquea el paquete y no lo pasa al siguiente nivel.
- **QUEUE**: es un objetivo especial, que pasa al paquete en una cola destinada al procesamiento en espacio de usuario. Esto se puede usar para utilizar otros programas externos.
- **RETURN**: tiene el mismo efecto que si hubiésemos llegado al final de la cadena. Si la regla estaba en una cadena de las que hay por defecto, entonces se ejecuta la política de la cadena. Para una regla que esté en una cadena definida por el usuario, se sale de ella, y se continúa atravesando la cadena anterior al salto, justo después de la regla con la que se saltó.

Como hemos mencionado y con respecto a las tablas mangle, iptables puede dar uso de la NAT, que contará con sus propias tablas, mediante la que se indica las reglas para realizar el enmascaramiento del paquete, redirigir puertos o cambiar alguna dirección de origen y destino. Nos podemos encontrar:

- **PREROUTING**: Mediante esta, indicaremos a la máquina que realice determinadas acciones sobre los paquetes antes de que sean enrutados.
- **POSTROUTING**: Nos permite realizar determinadas acciones antes de que el paquete salga del cortafuegos.
- **OUTPUT**: Nos da la opción de modificar los paquetes generados en el cortafuegos antes de ser enrutados.

Una vez que ya conocemos el funcionamiento y su arquitectura, vamos a ver diferentes comandos para realizar diferentes acciones.

## Comandos imprescindibles para usar iptables

Lo primero que debemos tener en cuenta a la hora de configurar este firewall, es que necesitamos **permisos de superusuario** para realizar las diferentes órdenes. Es totalmente necesario para que se ejecuten, de lo contrario no funcionará. Las siguientes órdenes no llevan «sudo» porque suponemos que ya estás con el superusuario (sudo su).

En las últimas versiones de Linux no es posible parar el servicio de iptables, para poder permitir todo el tráfico de red y dejar el firewall con los parámetros por defecto, tenemos que ejecutar las siguientes órdenes:

```bash
sudo iptables -F
sudo iptables -X
sudo iptables -t nat -F
sudo iptables -t nat -X
sudo iptables -t mangle -F
sudo iptables -t mangle -X
sudo iptables -P INPUT ACCEPT
sudo iptables -P FORWARD ACCEPT
sudo iptables -P OUTPUT ACCEPT
```

Una vez que hayamos hecho esto, ya tendremos el firewall «reseteado» y con el permitir todo. Ahora que ya sabemos cómo resetearlo, vamos a ver las diferentes órdenes.

## Visualizar las tablas actuales

**Si quieres ver el contenido de las diferentes cadenas** y reglas que tenemos en una determinada tabla, a continuación, puedes ver cómo se verían:

```bash
iptables -t filter --list
iptables -t mangle --list
iptables -t nat --list
iptables -t raw --list
```

### Argumentos principales y para qué sirven

- `-t, --table table`: Selecciona la tabla que queramos.
- `-A, --append chain rule-specification`: Añade una nueva regla en una determinada cadena.
- `-C, --check chain rule-specification`: Comprueba que existe una determinada regla en una cadena.
- `-D, --delete chain rule-specification`: Borra la regla que pongamos en una determinada cadena.
- `-D, --delete chain rulenum`: Borra la regla número X en una determinada cadena.
- `-I, --insert chain [rulenum] rule-specification`: Inserta una nueva regla con un número en una determinada cadena.
- `-R, --replace chain rulenum rule-specification`: Reemplaza una determinada regla en una cadena; sirve para cambiarla de número.
- `-L, --list [chain]`: Muestra el listado de reglas de una cadena.
- `-F, --flush [chain]`: Elimina todas las reglas de una determinada cadena.
- `-Z, --zero [chain [rulenum]]`: Pone los contadores de una determinada regla a 0.
- `-N, --new-chain chain`: Crea una nueva cadena en una determinada tabla.
- `-X, --delete-chain [chain]`: Borra una determinada cadena (vacía) en una tabla.
- `-P, --policy chain target`: Aplica la política por defecto; se cumple cuando ninguna regla de las cadenas se cumple.
- `-E, --rename-chain old-chain new-chain`: Renombra una cadena añadida anteriormente.
- `-h`: Muestra la ayuda.
- `-v, --verbose`: Salida que se usa en conjunto con `-L`, sirve para mostrar más información que lo que proporciona el comando `-L`.
- `-n, --numeric`: Las direcciones IP y los números de puertos aparecerán como números. Por ejemplo, si filtramos el puerto 80, con el `-L` típico aparecerá `www`, y no `80`.
- `-x, --exact`: Muestra el valor exacto del contador de paquetes y bytes, en lugar de usar `K`, `M`, o `G` para los valores.
- `--line-numbers`: Al mostrar el listado de reglas, mostrará el número exacto de la regla. Ideal para usar `-D` y el número (eliminar) o `-I` para insertar antes o después de dicha regla.


### Condiciones principales

- **`-p`, --protocol protocolo**: Filtra el paquete por protocolo. El protocolo especificado puede ser: tcp, udp, Idplite, icmp, esp, ah, sctp.
- **`-s`, --source address[/mask][,…]**: Dirección IP de origen del paquete. Podemos especificar una IP o una subred (indicando la máscara en formato CIDR). También podemos usar nombres de host (dominios, sitios web, etc.), pero no es eficiente. Se pueden especificar varias direcciones de origen (por ejemplo, 192.168.1.1,192.168.1.2), pero se crearán reglas separadas para satisfacerlas.
- **`-d`, --destination address[/mask][,…]**: Dirección IP de destino del paquete. Se comporta exactamente igual que `-s`.
- **`-m`, --match match**: Especifica si queremos llamar a módulos extendidos de iptables para realizar acciones específicas como:
    - Especificar múltiples puertos de origen y destino (módulo multiport).
    - Controlar conexiones (módulo conntrack).
    - Prevenir ataques de fuerza bruta (módulo recent, ideal para SSH).
    - Limitar el número de conexiones (módulos limit y connlimit).
    - Especificar rangos de direcciones IP (módulo iprange).
- **`-j`, --jump target**: Especifica el objetivo de la regla, como aceptar, rechazar, o incluso reenviar el paquete a otra cadena para su posterior procesamiento. En cualquier regla, siempre tendremos un `-j` para indicar qué acción tomar. Si no incluimos `-j`, la regla se añadirá y contará los paquetes, pero no realizará ninguna acción. Si usamos `-j` para reenviar a otra cadena, una vez que el procesamiento en la otra cadena haya terminado, volverá a la original.
- **`-g`, --goto chain**: Se utiliza para reenviar el tráfico a otra cadena, pero a diferencia de jump, no vuelve a la cadena original por donde entró.
- **`-i`, --in-interface nombre**: Nombre de la interfaz por donde un paquete se recibe. Solo aplicable para cadenas de entrada como INPUT, FORWARD y PREROUTING. Si usamos '!', significa todas las interfaces excepto esa. Si agregamos un '+' al final del nombre, cualquier interfaz que comience con ese nombre será coincidente. Por ejemplo, si tienes eth0, eth1 y eth2, puedes hacer coincidir las tres usando eth+.
- **`-o`, --out-interface nombre**: Nombre de la interfaz por donde un paquete sale. Solo aplicable para cadenas de salida como OUTPUT, FORWARD y POSTROUTING.

### Condiciones solamente si usas TCP o UDP

Si utilizas el protocolo TCP o UDP, es posible que quieras filtrar por número de puerto de origen y/o destino. A continuación, tienes los dos argumentos que puedes usar:

- **`--sport`, --source-port**: Selecciona puertos de origen para permitir o denegar. Si usamos `!`, los excluye.
- **`--dport`, --destination-port**: Selecciona puertos de destino para permitir o denegar. Si usamos `!`, los excluye.


Existen muchas más condiciones para una configuración avanzada del firewall, pero las elementales ya las tenemos listadas.

### Configurar la política por defecto

Las políticas sirven para que, cuando no se encuentra una regla dentro de la cadena, se ejecute la política por defecto. La política por defecto de todas las cadenas es `ACCEPT`, pero hay dos opciones: `ACCEPT` o `DROP`.

- **`-P`, --policy chain target**

**Ejemplos:**

- `iptables -P INPUT DROP`
- `iptables -P FORWARD DROP`
- `iptables -P OUTPUT DROP`

Con esto nos quedaremos sin internet, por lo que a continuación debemos empezar a crear reglas permisivas.

A continuación, podés ver todas las políticas que tenemos en las diferentes tablas:

- `iptables -t filter -P (INPUT | OUTPUT | FORWARD) (ACCEPT | DROP)`
- `iptables -P (INPUT | OUTPUT | FORWARD) (ACCEPT | DROP)`
- `iptables -t mangle -P (INPUT | OUTPUT | FORWARD | PREROUTING | POSTROUTING) (ACCEPT | DROP)`

**Ver el estado del firewall**

The `-L` parameter shows the rules we have configured. `-v` provides more information about connections, and `-n` returns IP addresses and their corresponding ports without going through a DNS server.

- `iptables -L -n -v`

This is one of the most important commands for checking the state of the firewall.

**Modules (-m match) in iptables**

### Multiport

Es una extensión de iptables que nos da la posibilidad de agrupar reglas similares con diferentes puertos TCP y UDP en una sola. Multiport permite especificar varios puertos tanto en intervalos como de forma individual, con un máximo de 15 argumentos de puertos.

**Ejemplo:**

- `iptables -A INPUT -p tcp -m multiport --dports 80,81,1000:1200 -j ACCEPT`

Gracias a este módulo, tenemos la posibilidad de usar varios puertos en la misma regla.

### Iprange

iprange nos permite poner varias direcciones IP de origen o destino de una vez, sin necesidad de poner decenas de reglas. También permite poner tanto IP de origen como de destino, la sintaxis es la siguiente:

- `[!] --src-range ip-ip`: Especifica el rango de direcciones IP de origen.
- `[!] --dst-range ip-ip`: Especifica el rango de direcciones IP de destino.

El funcionamiento de esta regla es bastante sencillo, simplemente ponemos IP inicio e IP final.

### Connlimit

El módulo `connlimit` se encarga de restringir el número de conexiones simultáneas realizadas por una dirección IP, lo cual es ideal para limitar el número de conexiones y evitar ataques de DoS.

- `--connlimit-upto n`: Marca si el número de conexiones es igual o menor que N (luego podemos permitir o denegar).
- `--connlimit-above n`: Marca si el número de conexiones es mayor que N (luego podemos permitir o denegar).
- `--connlimit-mask prefix_length`: Marca por rango de subred (es igual que un host haga 2 conexiones o que dos hosts de la misma subred hagan 1 conexión cada uno).
- `--connlimit-saddr`: Aplica la limitación al grupo de origen; esta es la opción predeterminada si no se especifica nada.
- `--connlimit-daddr`: Aplica la limitación al grupo de destino.

**Ejemplo:**

Si queremos permitir únicamente dos conexiones SSH por cliente, usaríamos:

- `iptables -A INPUT -p tcp --dport 22 -m connlimit --connlimit-above 2 -j DROP`

Sin embargo, también podemos crear una regla complementaria para aceptar hasta 2 conexiones:

- `iptables -A INPUT -p tcp --dport 22 -m connlimit --connlimit-upto 2 -j ACCEPT`

### Conntrack

Este módulo sirve para realizar un tracking de las conexiones, sirve para gestionar la entrada y salida de paquetes antes y después del establecimiento de la conexión. Dentro de este módulo hay varias opciones, pero la más importante es `-ctstate` que nos permite aceptar o denegar diferentes tipos de paquetes. Dentro de ctstate tenemos varios estados, destacan los siguientes:

- **INVALID**: El paquete recibido es inválido y no pertenece a ninguna conexión.
- **NEW**: Conexiones nuevas que se realizan, o que están asociadas a una conexión que aún no es bidireccional.
- **ESTABLISHED**: Conexiones establecidas, pasan primero por NEW ya que han tenido respuesta.
- **RELATED**: Paquete que está relacionado a una conexión existente, pero que no es parte de ella, como en el caso del FTP pasivo.

**Ejemplo:**

Imaginemos que queremos acceder a cualquier sitio, sin embargo, no queremos que absolutamente nadie acceda a nosotros:

- `iptables -P INPUT DROP`
- `iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT`

### Limit

El módulo `limit` nos permite limitar tanto el tráfico como el número de logs a escribir en el syslog, así como los intentos de conexión. Tiene dos argumentos principales:

- `--limit N`: Este argumento especifica el número máximo de coincidencias promedio por segundo (N/s), minuto (N/m), hora (N/h) o día (N/d) a permitir. N especifica el número.
- `--limit-burst N`: Indica la ráfaga más larga que se puede producir antes de comprobar el límite `--limit`.

El valor por defecto, si no se especifica nada, es 3 coincidencias por hora, con ráfagas de 5. Imaginemos la siguiente regla: `iptables -A INPUT -m limit -j LOG`, el funcionamiento es el siguiente:

- La primera vez que se alcanza esta regla, se registran los primeros cinco paquetes.
- Después, pasarán veinte minutos antes de que vuelva a registrarse un paquete con esta regla (3 coincidencias entre 60 minutos igual a 20 minutos, ya que es MEDIA).
- Además, cada veinte minutos que pasen sin que un paquete alcance la regla, la ráfaga recuperará un paquete.
- Si no sucede nada durante 100 minutos, la ráfaga quedará completamente recargada; de vuelta entonces a la situación inicial.

### Recent

El módulo recent sirve para limitar el número de conexiones por segundo a nivel de IP, esto es ideal para protegernos de ataques al puerto SSH porque un atacante probará múltiples contraseñas. Por ejemplo, si queremos proteger nuestro SSH, podríamos ejecutar la siguiente regla:

- `iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set --name ssh --rsource`
- `iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --rcheck --seconds 60 --hitcount 4 --name ssh --rsource -j DROP`

Esta regla sólo permite cuatro intentos de conexión después de 60 segundos; es una ventana «deslizante».

### NAT

Este cortafuegos también se encarga de NATear nuestra conexión. Para NAT nuestra IP pública (o interfaz que tenga esta IP pública), debemos configurar:

- SNAT estático: `iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth1 -j SNAT --to IP_eth1`
- SNAT dinámico: `iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth1 -j MASQUERADE`.

Lo normal es utilizar `MASQUERADE` para hacer NAT independientemente de la dirección IP de la interfaz física o lógica.

Para abrir puertos, tenemos que añadir una regla en la cadena `PREROUTING` de la tabla NAT.

- `iptables -t nat -A PREROUTING -i eth1 -p tcp --dport 22 -j DNAT --to-destination 192.168.1.1`

La tabla `PREROUTING` también nos permite modificar los puertos sobre la marcha, de forma que si recibimos paquetes en el puerto 2121, podemos transformarlo al puerto 21.

- `iptables -t nat -A PREROUTING -i eth1 -p tcp --dport 2121 -j DNAT --to-destination 192.168.1.1:21`

Ahora que ya conocemos en detalle este cortafuegos, veamos los ejemplos básicos y más avanzados de su uso.

## Ejemplos básicos de uso

Este cortafuegos es muy completo, y disponemos de cientos de comandos que podemos ejecutar para realizar diferentes acciones. Vamos a poner algunos ejemplos fáciles de entender para una primera aproximación a este cortafuegos.

**Primero, bloquear la dirección IP 192.168.1.10 para que no se comunique con nuestro servidor:**

- `iptables -A INPUT -s 192.168.1.10 -j DROP`

A continuación, si deseas bloquear las direcciones IP 192.168.1.20, 192.168.1.30, 192.168.1.40, 192.168.1.50 para que no se comuniquen con nuestro servidor:

- `iptables -A INPUT -s 192.168.1.20,192.168.1.30,192.168.1.40,192.168.1.50 -j DROP`

Y bloquear toda la subred 192.168.2.0/24 para que no realicen ninguna comunicación a nuestro servidor, salvo la dirección IP 192.168.2.20 que estaría permitida:

- `iptables -A INPUT -s 192.168.2.20 -j ACCEPT`.
- `iptables -A INPUT -s 192.168.2.0/24 -j DROP`.

Si deseas bloquear la dirección IP 192.168.4.50 para que no pueda realizar ninguna comunicación

- `iptables -A OUTPUT -d 192.168.4.50 -j DROP`

También existe la opción de bloquear las direcciones IP 192.168.4.51 y 192.168.4.52 para que no podamos realizar ninguna comunicación:

- `iptables -A OUTPUT -d 192.168.4.51,192.168.4.52 -j DROP`

Y bloquear el acceso a [www.google.es](http://www.google.es) desde iptables:

- `iptables -A OUTPUT -d [www.google.es](http://www.google.es/) -j DROP`

Queremos bloquear el acceso a nuestro servidor desde MAC 00:01:02:03:04:05, y permitir todo lo demás:

- `iptables -A INPUT -m mac --mac-source 00:01:02:03:03:04:05 -j DROP`

Queremos permitir el acceso a nuestro servidor a la dirección MAC 00:01:02:03:03:04:06, y denegar todo lo demás:

- `iptables -A INPUT -m mac --mac-source 00:01:02:03:03:04:06 -j ACCEPT`
- `iptables -A INPUT -j DROP`

También existe la opción de bloquear la dirección IP 192.168.1.10 para evitar el ping desde nuestro servidor:

- `iptables -A INPUT -s 192.168.1.10 -p icmp -j DROP`

A continuación, bloquee las direcciones IP 192.168.1.20, 192.168.1.30, 192.168.1.40, 192.168.1.50 para que no puedan hacer ping a nuestro servidor (en una única regla):

- `iptables -A INPUT -s 192.168.1.20,192.168.1.30,192.168.1.40,192.168.1.50 -p icmp -j DROP`.

Bloquear toda la subred 192.168.2.0/24 para que no haga ping a nuestro servidor, excepto la dirección IP 192.168.2.20 que estaría permitida:

- `iptables -A INPUT -s 192.168.2.20 -p icmp -j ACCEPT`
- `iptables -A INPUT -s 192.168.2.0/24 -p icmp -j DROP`.

Además, bloquea la dirección IP 192.168.4.50 para que no podamos hacer ping:

- `iptables -A OUTPUT -d 192.168.4.50 -p icmp -j DROP`

Y bloquea las direcciones IP 192.168.4.51 y 192.168.4.52 para que no podamos hacerles ping:

- `iptables -A OUTPUT -d 192.168.4.51,192.168.4.52 -p icmp -j DROP`

Bloquear el acceso a [www.google.es](http://www.google.es) desde iptables:

- `iptables -A OUTPUT -d [www.google.es](http://www.google.es/) -p icmp -j DROP`

Como puede ver, el funcionamiento es bastante sencillo con reglas basadas en IP con origen y destino. También podemos utilizar el módulo `iprange` para configurar un rango de IPs:

Bloquear un rango de direcciones IP desde 192.168.5.1 hasta la dirección 192.168.5.50 para que no puedan hacer ping desde nuestro servidor:

- `iptables -A OUTPUT -m iprange --dst-range 192.168.5.1-192.168.5.50 -p icmp -j DROP`

También podemos filtrar el protocolo ICMP de una forma más avanzada. Imaginemos que tenemos un usuario que quiere poder hacer ping a cualquier host, pero, sin embargo, no quiere que NADIE pueda hacerle ping a él. ¿Cómo podemos hacerlo con iptables si el propio PING tiene comunicación bidireccional?

- `iptables -A INPUT -s IP -p icmp --icmp-type echo-request -j DROP`

Bloquear cualquier acceso entrante en la interfaz eth0 (únicamente), permitiendo por tanto el acceso a eth1:

- `iptables -A INPUT -i eth0 -j DROP`
- `iptables -A INPUT -i eth1 -j ACCEPT`

Bloquear el tráfico saliente en la interfaz eth0 (únicamente), permitiendo por tanto el acceso a eth1:

- `iptables -A OUTPUT -o eth0 -j DROP`
- `iptables -A OUTPUT -o eth1 -j ACCEPT`

Permitir cualquier tráfico entrante y saliente en eth0, y denegar cualquier tráfico entrante y saliente en eth1:

- `iptables -A INPUT -i eth0 -j ACCEPT`
- `iptables -A OUTPUT -o eth0 -j ACCEPT`
- `iptables -A INPUT -i eth1 -j DROP`
- `iptables -A OUTPUT -o eth1 -j DROP`

### Protocolos TCP y UDP

Si quieres empezar a ver cómo funcionan los protocolos TCP y UDP, aquí tienes algunos ejemplos:

Bloquea el acceso web a [www.google.es](http://www.google.es) y permite todo lo demás (por ejemplo, ping):

- `iptables -A OUTPUT -d [www.google.es](http://www.google.es/) -p tcp --dport 80 -j DROP`

Por otro lado, para bloquear el acceso FTP a cualquier IP o dominio, y permitir todo lo demás:

- `iptables -A OUTPUT -p tcp --dport 21 -j DROP`

Si quieres bloquear el acceso SSH a la IP 192.168.1.50, y permitir todo lo demás:

- `iptables -A OUTPUT -d 192.168.1.50 -p tcp --dport 22 -j DROP`

Para bloquear el acceso Telnet a la subred 192.168.2.0 y permitir todo lo demás:

- `iptables -A OUTPUT -d 192.168.2.0/24 -p tcp --dport 23 -j DROP`

Bloquear el acceso desde 192.168.1.50 a nuestro servidor web:

- `iptables -A INPUT -s 192.168.1.50 -p tcp --dport 80 -j DROP`

Bloquear el acceso desde 192.168.1.150 y 192.168.1.151 a nuestro servidor SSH:

- `iptables -A INPUT -s 192.168.1.150,192.168.1.151 -p tcp --dport 22 -j DROP`

Si deseas bloquear el acceso de toda la subred 192.168.2.0/24 al protocolo Telnet (puerto 23), y permitir todo lo demás:

- `iptables -A INPUT -s 192.168.2.0/24 -p tcp --dport 23 -j DROP`

Bloquear el acceso desde `192.168.1.50` a nuestro servidor web:

- `iptables -A INPUT -s 192.168.1.50 -p tcp --dport 80 -j DROP`

Bloquear el acceso desde `192.168.1.150` y `192.168.1.151` a nuestro servidor SSH:

- `iptables -A INPUT -s 192.168.1.150,192.168.1.151 -p tcp --dport 22 -j DROP`

Si desea bloquear el acceso desde toda la subred `192.168.2.0/24` a nuestro servicio telnet:

- `iptables -A INPUT -s 192.168.2.0/24 -p tcp --dport 23 -j DROP`.

Bloquear el acceso a nuestro servidor OpenVPN a todo el mundo excepto a la dirección IP `77.77.77.77`, que está permitida:

- `iptables -A INPUT -s 77.77.77.77 -p tcp --dport 1194 -j ACCEPT`
- `iptables -A INPUT -p tcp --dport 1194 -j DROP`

Para bloquear el acceso DNS a `8.8.8.8` y permitir todo lo demás (por ejemplo, ping):

- `iptables -A OUTPUT -d 8.8.8.8 -p tcp --dport 53 -j DROP`
- `iptables -A OUTPUT -d 8.8.8.8 -p udp --dport 53 -j DROP`

Para bloquear el acceso al puerto `1194` para cualquier IP o dominio y permitir todo lo demás:

- `iptables -A INPUT -p udp --dport 1194 -j DROP`

Tenemos un servidor DNS en nuestro sistema, y queremos que sólo los dispositivos de la subred `192.168.1.0/24` se comuniquen con él, bloqueando todos los demás accesos:

- `iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 53 -j ACCEPT`
- `iptables -A INPUT -s 192.168.1.0/24 -p udp --dport 53 -j ACCEPT`
- `iptables -A INPUT -p tcp --dport 53 -j DROP`
- `iptables -A INPUT -p udp --dport 53 -j DROP`

Bloquear el acceso a nuestro servidor web desde el rango IP `192.168.100.0/24` procedente de la interfaz `eth0`:

- `iptables -A INPUT -s 192.168.100.0/24 -i eth0 -p tcp --dport 80 -j DROP`

Bloquear el acceso a nuestro servidor SSH desde el rango IP `192.168.100.0/24` procedente de la interfaz `eth1`:

- `iptables -A INPUT -s 192.168.100.0/24 -i eth1 -p tcp --dport 22 -j DROP`.

## Ejemplos de uso avanzado

Si quieres aprender más sobre iptables, aquí tiene algunos ejemplos usando el módulo `connlimit`.

Permitir sólo 10 conexiones Telnet por cliente:

- `iptables -A INPUT -p tcp --dport 23 -m connlimit --connlimit-above 10 --connlimit-mask 32 -j DROP`

Denegar conexiones más allá de la quinta conexión web realizada por un cliente (no es muy práctico, pero es un ejemplo):

- `iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-hasta 5 --connlimit-mask 32 -j DROP`

Si deseas permitir sólo 10 conexiones Telnet por cliente (configurado de forma diferente al ejemplo anterior):

- `iptables -A INPUT -p tcp --dport 23 -m connlimit --connlimit-upto 10 --connlimit-mask 32 -j ACCEPT`
- `iptables -A INPUT -p tcp --dport 23 -j DROP`

Permitir sólo 10 conexiones web dentro del rango IP `10.0.0.0/8`, y denegar si se supera este número:

- `iptables -A INPUT -s 10.0.0.0/8 -p tcp --dport 80 -m connlimit --connlimit-above 10 --connlimit-mask 8 -j DROP`.

Si desea permitir sólo 20 conexiones HTTP por cliente, y si se superan, enviar un TCP Reset:

- `iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 32 -j REJECT --reject-with tcp-reset`

O de esta otra forma

- `iptables -A INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 32 -j REJECT --reject-with tcp-reset`

Como puede ver, este cortafuegos es muy completo y permite una amplia gama de configuraciones avanzadas para controlar al detalle todas las conexiones entrantes y salientes. Además, recuerde que cualquier cambio que realice en la configuración de iptables es temporal, por lo que debe guardarlo para que persista después de reiniciar el servidor.