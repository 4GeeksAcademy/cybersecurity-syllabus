# SQL Injection

La inyecci√≥n SQL es un tipo de ataque de inyecci√≥n en el cual un atacante inserta c√≥digo malicioso en una consulta SQL para ejecutar comandos no deseados en la base de datos. Los atacantes pueden utilizar la inyecci√≥n de comandos para ejecutar comandos arbitrarios en el sistema, lo que podr√≠a permitirles obtener acceso no autorizado, modificar o eliminar datos, o incluso tomar el control total del sistema. Las inyecciones a menudo se realizan a trav√©s de campos de entrada, como formularios web, par√°metros de URL o encabezados HTTP.

Los complementos de WordPress m√°s √∫tiles tienen alg√∫n tipo de interacci√≥n con la base de datos. La entrada del usuario se env√≠a con frecuencia a la base de datos, ya sea porque necesita almacenarse en la base de datos, necesita modificar algo en la base de datos o porque se utiliza como parte de una declaraci√≥n SELECT. Si la entrada del usuario no se valida ni se escapa correctamente, un atacante puede reemplazar esa entrada del usuario con comandos que puede enviar directamente a la base de datos.

Hay dos tipos de inyecci√≥n SQL. Una vulnerabilidad de inyecci√≥n SQL "cl√°sica" es aquella en la que la entrada del usuario sin filtrar permite a un atacante enviar comandos a la base de datos y la salida se env√≠a de vuelta al atacante. Una vulnerabilidad de inyecci√≥n SQL "ciega" se produce cuando el atacante puede enviar comandos a la base de datos pero en realidad no ve la salida de la base de datos.

Seg√∫n el an√°lisis de Wordfence las vulnerabilidades de inyecci√≥n SQL son la segunda vulnerabilidad m√°s com√∫n que se encuentra en los complementos de WordPress.

![SQL 1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql1.png?raw=true)

[https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)

C√≥mo funciona una vulnerabilidad de inyecci√≥n SQL cl√°sica

Para comprender c√≥mo funciona una vulnerabilidad de inyecci√≥n SQL cl√°sica, veamos un ejemplo de WordPress:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var("select post_title from " . $wpdb->posts . " where ID=" . $_GET['id']);
echo $title;
 |
| --- | --- |

El c√≥digo anterior es un ejemplo de una vulnerabilidad de inyecci√≥n SQL (SQLi). Es una vulnerabilidad de SQLi porque la entrada del usuario en $_GET['id'] se env√≠a directamente a la base de datos sin desinfecci√≥n ni escape. Esto permite a un atacante enviar comandos directamente a la base de datos.

Luego, la salida de la base de datos se env√≠a directamente al navegador del usuario. Debido a que el resultado se env√≠a al navegador, esto convierte a la vulnerabilidad en una vulnerabilidad SQLi cl√°sica, a diferencia de una vulnerabilidad de inyecci√≥n SQL ciega, que se analiza a continuaci√≥n.

Al utilizar esta vulnerabilidad, un atacante puede enviar comandos directamente a la base de datos. Estos incluyen comandos SELECT para descargar su base de datos completa, incluida la informaci√≥n de identificaci√≥n personal (PII) del usuario. En algunos casos, tambi√©n incluye comandos INSERTAR y ACTUALIZAR para crear nuevas cuentas de usuario o modificar cuentas de usuario existentes.

Corregir la vulnerabilidad anterior es relativamente f√°cil. En WordPress simplemente necesita usar el m√©todo de preparaci√≥n que desinfectar√° y escapar√° autom√°ticamente cualquier dato que env√≠e a la base de datos. El c√≥digo anterior se puede modificar de la siguiente manera para eliminar la vulnerabilidad SQLi:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var($wpdb->prepare("select post_title from " . $wpdb->posts . " where ID=%d", $_GET['id']));
echo $title;
 |
| --- | --- |

Tenga en cuenta que utilizamos el m√©todo $wpdb->prepare() para escapar de los datos que estamos enviando a la base de datos. Tiene una sintaxis similar a la funci√≥n sprintf() que le permite utilizar marcadores de posici√≥n. %d es un n√∫mero entero, %f es un flotante (o decimal) y %s es una cadena (o texto). Si utiliza %s como marcador de posici√≥n, no necesita incluir comillas, ya que se agregan autom√°ticamente.

### ¬øC√≥mo funciona una inyecci√≥n SQL ciega?

Una vulnerabilidad de inyecci√≥n SQL ciega se parece a la siguiente:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var("select post_title from " . $wpdb->posts . " where ID=" . $_GET['id']);
//Do something with title, but don't echo.
 |
| --- | --- |

En el ejemplo anterior, la entrada del usuario sin procesar y no desinfectada se env√≠a directamente a la base de datos concatenando la variable $_GET['id'] directamente a la consulta SQL. Para corregir esta vulnerabilidad, simplemente usar√≠a el m√©todo prepare() como se indic√≥ anteriormente para desinfectar y escapar de cualquier entrada de la base de datos.

La diferencia aqu√≠ es que el resultado nunca se env√≠a al navegador. Una vulnerabilidad SQLi ciega es tan grave como una vulnerabilidad SQLi normal porque, en algunos casos, un atacante puede insertar o actualizar datos f√°cilmente en su base de datos. La diferencia es que resulta m√°s dif√≠cil extraer datos de la base de datos porque el atacante no puede ver el resultado de la base de datos porque no est√° escrito en el navegador web.

## Ataques SQL ciegos basados ‚Äã‚Äãen el tiempo

Generalmente, hay dos formas en que un atacante extrae datos de una base de datos mediante un ataque de inyecci√≥n SQL ciega. El primero es utilizar un ataque basado en el tiempo. Supongamos que, utilizando la vulnerabilidad SQLi anterior, un atacante puede enviar cualquier comando a la base de datos, pero no puede ver el resultado. S√≥lo pueden ver la p√°gina web resultante.

Un atacante podr√≠a hacerle a la base de datos una pregunta como ‚Äú¬øLa primera letra de la primera cuenta de administrador comienza con 'a'? Si es as√≠, duerme 5 segundos y si no es as√≠, no duermas nada. Si la p√°gina web tarda menos de 5 segundos en generarse y regresar al navegador web, saben que la cuenta de administrador no comienza con la letra 'a' y pasan a la siguiente letra, 'b', y preguntan. la misma pregunta.

Con esta t√©cnica, un atacante puede lanzar un ataque basado en el tiempo en un sitio web y determinar los nombres de las cuentas de administrador y puede extraer contrase√±as de usuario con hash.

El SQL real enviado a la base de datos podr√≠a verse similar al siguiente:

| 1
2
3
4
5
6 | select post_title from wp_posts where ID=1
¬†¬†union select IF(
¬†¬†¬†¬†substring(wp_users.user_login,1,1)='a',
¬†¬†¬†¬†BENCHMARK(5000000,ENCODE('blah','asdf')),
¬†¬†¬†¬†null)
¬†¬†from wp_users where ID=1
 |
| --- | --- |

Lo que dice este SQL es "seleccione el t√≠tulo de la publicaci√≥n donde el ID de la publicaci√≥n es 1, pero combine en una consulta que llevar√° mucho tiempo si suponemos que la cuenta de usuario con ID 1 (que generalmente es una cuenta de administrador) tiene la letra ' a' como primera letra del nombre de usuario‚Äù.

Cuando se ejecuta esta consulta, si la p√°gina tarda mucho en cargarse, el atacante ha adivinado correctamente la primera letra del nombre de usuario del administrador. Luego pueden pasar a las letras dos y tres hasta que tengan su nombre de usuario de administrador. Una vez que lo tengan, pueden extraer su contrase√±a hash de administrador, su correo electr√≥nico de administrador, cualquier correo electr√≥nico de usuario o cualquier dato que deseen, siempre que se tomen el tiempo suficiente para ejecutar el ataque.

Recuerde, estos ataques son automatizados y las conjeturas incorrectas no toman tiempo, por lo que los datos se pueden extraer con relativa rapidez utilizando esta t√©cnica.

Ataques de inyecci√≥n SQL ciegos basados ‚Äã‚Äãen contenido

Un ataque de inyecci√≥n SQL ciega basado en contenido es otra forma en que un atacante extrae datos de una base de datos cuando no puede ver la salida de la base de datos.

Si la consulta que genera el contenido es la siguiente (recuerde, el resultado de la consulta no se env√≠a al usuario)

| 1 | select post_status from wp_posts where ID=1 |

Supongamos que el valor '1' anterior es un par√°metro de consulta sin filtrar agregado a la consulta de la base de datos como en nuestro ejemplo anterior. Por tanto, un atacante puede controlar todo el texto despu√©s de 'ID='.

Un atacante puede agregar lo siguiente a la consulta para verificar que si incluye una condici√≥n falsa, ver√° generado contenido inusual:

| 1 | select post_status from wp_posts where ID=1 and 1=2 |

Obviamente, 1 no es igual a 2, por lo que en la consulta anterior la base de datos devolver√° un conjunto de resultados vac√≠o. El atacante examinar√° la p√°gina resultante y si es una p√°gina sin contenido o un mensaje de error que dice algo como "sin contenido", sabr√° c√≥mo se ve la respuesta de una consulta vac√≠a con una condici√≥n falsa. Luego, el atacante puede incluir algo como lo siguiente:

| 1
2
3 | select post_status from wp_posts where ID=1
¬†¬†and (select ID from wp_users where
¬†¬†user_login='admin' and ID=1)
 |
| --- | --- |

La consulta anterior estar√° vac√≠a si el usuario de la base de datos con ID 1 no tiene el nombre de usuario 'admin'. Sin embargo, devolver√° un resultado normal no vac√≠o al navegador si el usuario con ID 1 tiene el nombre de usuario "admin". Con esta t√©cnica, un atacante puede extraer datos de una base de datos comprobando si hay respuestas vac√≠as y no vac√≠as de la aplicaci√≥n.

Otro ejemplo de una consulta de inyecci√≥n SQL ciega basada en contenido es:

| 1
2
3 | select post_status from wp_posts where
¬†¬†ID=1 and (select 1 from wp_users where
¬†¬†substring(user_pass,1,1) = 'a' and ID=1) |
| --- | --- |

La consulta anterior verificar√° si la primera letra de la contrase√±a hash para el usuario con ID 1 es una 'a'. Con esta t√©cnica, un atacante puede revisar cada car√°cter y extraer la contrase√±a hash de las cuentas de administrador.

## Consecuencias

> Las consecuencias de una inyecci√≥n SQL pueden incluir:
> 
- **P√©rdida o alteraci√≥n de datos:** el atacante puede eliminar, modificar o extraer informaci√≥n de la base de datos.
- **Inestabilidad del sistema:** el c√≥digo malicioso puede causar que la base de datos deje de funcionar correctamente, lo que puede resultar en tiempos de inactividad y p√©rdida de disponibilidad.
- **Dificultad para detectar y mitigar el ataque:** debido a que el c√≥digo malicioso se inserta en una consulta SQL leg√≠tima.
- **Posibilidad de propagaci√≥n del ataque:** si el atacante tiene acceso a datos sensibles, como contrase√±as de usuario, puede utilizarlos para propagar el ataque a otros sistemas.
- **Acceso no autorizado:** un atacante podr√≠a obtener acceso no autorizado al sistema o a la aplicaci√≥n web, lo que le permitir√≠a acceder a informaci√≥n confidencial o realizar acciones maliciosas en el sistema.
- **Modificaci√≥n de datos:** un atacante podr√≠a modificar, eliminar o agregar datos al sistema, lo que podr√≠a tener graves consecuencias en la integridad y exactitud de los datos.
- **Ejecuci√≥n de c√≥digo malicioso:** un atacante podr√≠a ejecutar c√≥digo malicioso en el sistema, lo que podr√≠a resultar en la toma de control del sistema o en el robo de informaci√≥n confidencial.
- **Denegaci√≥n de servicio:** un atacante podr√≠a utilizar la inyecci√≥n de comando para sobrecargar el sistema y hacer que se vuelva inoperable.
- **La no correcci√≥n de esta falla puede causar divulgaci√≥n no autorizada de su informaci√≥n y la de sus clientes que podr√≠a dar lugar a fraude, usurpaci√≥n de identidad y a sanciones reglamentarias.**
- Para evitar la inyecci√≥n de comandos, es importante validar y filtrar todas las entradas de usuario en las aplicaciones web, y evitar el uso de comandos de shell en aplicaciones web. Adem√°s, es importante mantener todas las aplicaciones y sistemas actualizados y parcheados para evitar que se exploten vulnerabilidades conocidas.

## **Soluci√≥n**

> Para prevenir y solucionar la inyecci√≥n SQL avanzada, se pueden tomar las siguientes medidas:
> 
- **Validar y sanitizar todas las entradas de datos**: Aseg√∫rese de que todas las entradas de datos, ya sean proporcionadas por los usuarios o por otras fuentes, sean validadas y sanitizadas adecuadamente antes de ser utilizadas en una consulta SQL.
- **Utilizar consultas parametrizadas:** En lugar de construir una consulta SQL din√°micamente utilizando cadenas de texto, utilice consultas parametrizadas que permitan que los par√°metros sean pasados como argumentos separados. Esto reducir√° la posibilidad de inyecci√≥n SQL, ya que los valores de los par√°metros son tratados como datos, no como parte de la consulta SQL.
- **Limitar los permisos de la base de datos:** Aseg√∫rese de que los usuarios de la base de datos tengan solo los permisos necesarios para realizar sus funciones y nada m√°s. Esto limitar√° el alcance de cualquier posible ataque.
- **Utilizar herramientas de seguridad y pruebas de penetraci√≥n:** Realice pruebas regulares de seguridad y pruebas de penetraci√≥n en la aplicaci√≥n para identificar posibles vulnerabilidades y errores de seguridad. Tambi√©n puede utilizar herramientas de seguridad de terceros para proteger la aplicaci√≥n contra la inyecci√≥n SQL.
- Actualizaci√≥n y parcheo del software de la base de datos y uso de firewalls de aplicaci√≥n web (WAF)

Es una tarea dif√≠cil determinar si una cadena de usuario es maliciosa o no. Por lo tanto, la mejor manera de hacerlo es ‚Äúescapar‚Äù de los caracteres especiales en la entrada del usuario. Puede escapar una cadena antes de construir la consulta en PHP usando la funci√≥n mysql_escape_string(). O en MySQL usando la funci√≥n mysqli_real_escape_string().

Mientras se muestra la salida como HTML, tambi√©n tendr√° que convertir la cadena para asegurarse de que los caracteres especiales no interfieren con el marcado HTML. Puede convertir caracteres especiales en PHP usando la funci√≥n htmlspecialchars(). Alternativamente, puede usar sentencias preparadas para evitar las inyecciones de SQL. Una sentencia preparada es una plantilla de una consulta SQL, en la que se especifican los par√°metros en una etapa posterior para ejecutarla. Aqu√≠ hay un ejemplo de una declaraci√≥n preparada en PHP y MySQLi.

`$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

`$query->execute(array($username, $password));`

<aside>
üìñ En resumen, para solucionar y prevenir la inyecci√≥n SQL avanzada, es necesario validar y sanitizar todas las entradas de datos, utilizar consultas parametrizadas, limitar los permisos de la base de datos y utilizar herramientas de seguridad y pruebas de penetraci√≥n.

</aside>

REFERENCIAS

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)

# **Pruebas de inyecci√≥n SQL: todo lo que necesita saber**

Para mejorar sus habilidades de pentester de aplicaciones web, es importante aprender a detectar vulnerabilidades de inyecci√≥n SQL. Profundizarwmoa en los principios y m√©todos de prueba que pueden descubrir los detalles de esta amenaza. Exploraremos t√©cnicas de prueba manuales, como analizar URL y formularios, comprender la interacci√≥n del usuario y el procesamiento de aplicaciones.

Adem√°s, proporcionaremos ejemplos reales de cargas √∫tiles de inyecci√≥n SQL que puede utilizar en sus propias pruebas. Para mejorar a√∫n m√°s sus habilidades, cubriremos la automatizaci√≥n con herramientas como SQLmap y Burp Suite, que ofrecen informaci√≥n de expertos de la industria sobre t√©cnicas modernas. Tambi√©n obtendr√° conocimientos sobre la interpretaci√≥n de mensajes de error complejos que son cruciales para identificar y resolver problemas. Al dominar las t√©cnicas b√°sicas y avanzadas descritas en este art√≠culo, podr√° mejorar la seguridad de sus aplicaciones y contribuir a un entorno digital m√°s seguro.

## **Comprender las inyecciones SQL**

Las inyecciones SQL son una vulnerabilidad inform√°tica que puede afectar aplicaciones web y bases de datos que utilizan el lenguaje SQL. Estos ataques aprovechan las vulnerabilidades en los formularios de entrada y las URL dentro de las aplicaciones. Insertan intencionalmente declaraciones SQL da√±inas en las solicitudes del servidor. El objetivo principal de un ataque de inyecci√≥n SQL es controlar c√≥mo funciona la base de datos. Esto permite el acceso no autorizado a datos confidenciales extray√©ndolos, modific√°ndolos o elimin√°ndolos.

**Los ataques de inyecci√≥n SQL se pueden dividir en varias categor√≠as. Los m√°s conocidos son:**

**Inyecci√≥n basada en errores:** esta t√©cnica implica insertar entradas da√±inas en la base de datos de un sistema para provocar errores. Estos errores potencialmente pueden brindarle informaci√≥n √∫til.

![SQL 2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql2.png?raw=true)

**Inyecci√≥n basada en uni√≥n:** el operador UNION le permite combinar los resultados de una consulta da√±ina y una consulta v√°lida. Esto les permite acceder a datos de otras tablas sin permiso.

![SQL 3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql3.png?raw=true)

**Inyecci√≥n ciega** : en este tipo de ataque, el perpetrador no recibe una respuesta directa del servidor. En cambio, infieren informaci√≥n sobre el comportamiento del sistema para recopilar datos.

![SQL 4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql4.png?raw=true)

**Inyecci√≥n ciega basada en el tiempo** : esta t√©cnica implica agregar intencionalmente retrasos a las consultas para verificar la precisi√≥n de condiciones espec√≠ficas. Al analizar los mensajes de error, puede extraer informaci√≥n valiosa sobre la base de datos, lo que ayuda a una mayor explotaci√≥n, como descubrir nombres de tablas o detalles del sistema, sin generar alarmas ni sospechas.

## **Pruebas manuales de inyecci√≥n SQL**

Profundicemos ahora en las t√©cnicas manuales de prueba de inyecci√≥n SQL examinando de cerca la estructura de la URL. Al hacerlo, podemos identificar vulnerabilidades potenciales y explotarlas con fines de evaluaci√≥n de seguridad.

**Analizando la estructura de la URL**

![SQL 5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql5.png?raw=true)

Durante el proceso de prueba manual de inyecci√≥n SQL, un an√°lisis profundo de la estructura de la URL es esencial para identificar y evaluar vulnerabilidades en las aplicaciones web. Este enfoque implica identificar debilidades en la aplicaci√≥n inyectando intencionalmente c√≥digo SQL malicioso a trav√©s de par√°metros que se encuentran dentro de las URL.

Para analizar la vulnerabilidad de un sitio web a los ataques de inyecci√≥n SQL, es importante identificar cualquier entrada del usuario que se transmita a trav√©s de los par√°metros de la URL. Estos par√°metros pueden servirle potencialmente como puntos de entrada. Una vez que se identifican estos par√°metros, probar su manipulabilidad se vuelve crucial.

Esto implica insertar varias cadenas de prueba, caracteres especiales y secuencias de escape para determinar si la aplicaci√≥n maneja adecuadamente dichas entradas sin generar errores.

![SQL 6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql6.png?raw=true)

Otro paso importante es examinar minuciosamente los mensajes de error que produce la aplicaci√≥n. Estos mensajes pueden exponer inadvertidamente vulnerabilidades internas en el sistema, descubriendo potencialmente debilidades de inyecci√≥n SQL.

Por ejemplo, en la imagen de arriba, puede ver un error generado al manipular el par√°metro **de usuario** en la URL, lo que nos ayuda a identificar la **consulta SQL espec√≠fica**¬† que est√° causando el error. Esto luego podr√≠a usarse para intentar explotar la vulnerabilidad que est√° causando el error o lanzar un ataque de denegaci√≥n de servicio (DoS) en el sitio web enviando demasiadas consultas SQL no v√°lidas.

Para profundizar m√°s en las pruebas de este tipo de URL, puede intentar identificar d√≥nde se inserta la entrada del usuario en la consulta SQL. Puede ser un campo de entrada, una variable en la URL o cualquier forma de entrada del usuario.

Para comenzar, puede utilizar una carga √∫til de SQL b√°sica como esta:' OR '1'='1

Inserte esta carga √∫til en la entrada sospechosa y vea si el mensaje de error de SQL desaparece. Si el mensaje de error desaparece o se produce un comportamiento diferente, podr√≠a ser una se√±al de que el sitio es vulnerable a un ataque de inyecci√≥n SQL. Si la carga √∫til b√°sica no produce resultados significativos, es posible que desee experimentar con cargas √∫tiles de SQL m√°s avanzadas, como la inyecci√≥n SQL ciega basada en UNION o basada en tiempo. Por ejemplo, una carga √∫til basada en UNION que podr√≠as probar es: ' UNION

`SELECT null, username, password FROM users--`

Este tipo de carga √∫til intenta extraer informaci√≥n de la tabla de usuarios. Sin embargo, tenga cuidado al utilizar cargas √∫tiles avanzadas como esta, ya que pueden afectar negativamente al sitio que est√° probando, si no se usan correctamente.

En resumen, analizar la estructura de la URL en las pruebas manuales de inyecci√≥n SQL puede ayudar a identificar vulnerabilidades potenciales y evaluar la capacidad de una aplicaci√≥n para manejar entradas maliciosas, brind√°ndole datos importantes para continuar con su pentest.

## **Campos de formulario y mecanismos de validaci√≥n**

Los campos de formulario en una aplicaci√≥n web sirven como punto de entrada para la entrada del usuario. Puede explotar estos campos mediante inyecciones SQL, donde inyecta c√≥digo SQL da√±ino. Estos campos de formulario se utilizan com√∫nmente para recopilar datos importantes del usuario, como nombres, direcciones de correo electr√≥nico, contrase√±as y m√°s.

La combinaci√≥n de campos de formulario bien dise√±ados con mecanismos de validaci√≥n s√≥lidos puede mitigar eficazmente el riesgo de inyecciones de SQL. Por ejemplo, un campo de correo electr√≥nico debe aceptar estrictamente s√≥lo direcciones de correo electr√≥nico v√°lidas, evitando la inserci√≥n de caracteres especiales que podr√≠an manipular consultas SQL. Este no es siempre el caso y est√° sujeto a abuso.

Probar para ver si el formulario acepta caracteres especiales o entradas no t√≠picas puede indicar la posibilidad de enviar comandos o solicitudes maliciosos a la base de datos.

![SQL 7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql7.png?raw=true)

Cuando se prueban manualmente las vulnerabilidades de inyecci√≥n SQL, las medidas de seguridad existentes, como la validaci√≥n de las entradas del usuario, a veces pueden impedir el proceso de inyecci√≥n. En tales casos, vale la pena explorar cargas √∫tiles b√°sicas, como insertar **'OR 1=1--** en el campo de entrada; Este tipo de cargas √∫tiles se denominan cargas √∫tiles de omisi√≥n porque utilizan una condici√≥n que siempre es verdadera para manipular una entrada vulnerable y omitir la autenticaci√≥n, acceder a datos no autorizados o ejecutar comandos maliciosos.

![SQL 8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql8.png?raw=true)

Si bien la validaci√≥n de entradas es una salvaguarda importante, no siempre es infalible, por lo que para identificar posibles vulnerabilidades es esencial realizar pruebas completas y exhaustivas.

## **Valores de cookies y encabezados HTTP**

En las pruebas de inyecci√≥n SQL manuales, puede manipular las solicitudes explotando los valores de las cookies y los encabezados HTTP de una aplicaci√≥n web. Estos elementos se consideran entradas externas, por lo que es importante que realice pruebas adecuadas con las herramientas correctas (como Burp Suite).

Las cookies, que contienen informaci√≥n almacenada en el navegador de un usuario, pueden ser vulnerables a la manipulaci√≥n. Un m√©todo com√∫n es inyectar c√≥digo SQL da√±ino alterando los datos dentro de una cookie. Si se utiliza una cookie, por ejemplo, para almacenar una identificaci√≥n de usuario en una aplicaci√≥n, puede intentar modificar esa identificaci√≥n dentro de la propia cookie. Este tipo de explotaci√≥n podr√≠a dar lugar a un acceso no autorizado a datos o funciones sensibles.

<aside>
üí° Por ejemplo, considere una aplicaci√≥n que utiliza una cookie para controlar al usuario que ha iniciado sesi√≥n actualmente. Ahora, supongamos que un hacker con intenciones maliciosas logra alterar esta cookie alterando el ID de usuario que contiene.

</aside>

Si la aplicaci√≥n no aborda adecuadamente esta modificaci√≥n, podr√≠a generar involuntariamente una consulta SQL da√±ina basada en el ID manipulado. Esto podr√≠a potencialmente otorgar acceso no autorizado a datos confidenciales.

Adem√°s, cuando un navegador env√≠a una solicitud a una aplicaci√≥n, incluye encabezados HTTP como User-Agents. Usted (el atacante) puede alterar estos encabezados insertando cadenas da√±inas en las solicitudes. Por ejemplo, podr√≠a utilizar la siguiente carga √∫til:'UNION SELECT null, username, password FROM users--

Esta carga √∫til est√° dise√±ada para extraer datos de la tabla de "usuarios" de una base de datos. Supongamos que tiene una solicitud HTTP GET que incluye un par√°metro "cat" en el que colocar la carga √∫til. En la pesta√±a "Solicitud HTTP" de Burp Suite, cambie el par√°metro "cat" para que contenga la carga √∫til, por ejemplo:cat=' UNION SELECT null, username, password FROM users--

Comience a enviar la solicitud y observe la respuesta. Si el sitio es vulnerable a una inyecci√≥n SQL basada en UNION, obtendr√° una respuesta que incluye informaci√≥n de la tabla "usuarios".

![SQL 9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql9.png?raw=true)

En ambos casos, es esencial garantizar que la aplicaci√≥n maneje de forma segura los valores de las cookies y los encabezados HTTP. Las pruebas manuales implican analizar el impacto de dichas manipulaciones en las entradas de la aplicaci√≥n y verificar su respuesta a posibles ataques de inyecci√≥n SQL.

**Entrada controlada por el usuario (UCI) procesada por la aplicaci√≥n**

Cuando se prueban manualmente las vulnerabilidades de inyecci√≥n SQL, el concepto de "Entrada controlada por el usuario" o UCI se refiere a cualquier entrada proporcionada por el usuario y posteriormente procesada por la aplicaci√≥n. Esto puede incluir datos ingresados ‚Äã‚Äãen campos de formulario, valores de cookies, par√°metros en URLs o encabezados HTTP (que ya vimos antes), puedes aprovechar estas oportunidades para inyectar c√≥digo SQL malicioso y causar grandes da√±os.

En este enfoque, manipula intencionalmente la entrada proporcionada para insertar caracteres especiales o secuencias de escape (como ‚Äò‚Äô o =). Estas manipulaciones pueden alterar las consultas SQL generadas por la aplicaci√≥n y explotar vulnerabilidades en su procesamiento de entrada. El objetivo es enga√±ar a la aplicaci√≥n para que ejecute consultas SQL no deseadas, lo que resulta en una extracci√≥n de datos no autorizada o en un compromiso del sistema.

### **Debe tener una lista de cargas √∫tiles de inyecci√≥n SQL**

Las cargas √∫tiles son fragmentos de c√≥digo que se insertan intencionalmente en los campos de entrada de las aplicaciones web. Estos fragmentos tienen como objetivo explotar las vulnerabilidades en los sistemas de gesti√≥n de bases de datos. Los profesionales de la seguridad y los evaluadores de penetraci√≥n suelen utilizar estas herramientas para evaluar el nivel de resistencia que tiene una aplicaci√≥n contra posibles ataques. A continuaci√≥n, se muestra una lista de las cargas √∫tiles de

inyecci√≥n SQL m√°s comunes utilizadas por **Pentesters**¬† y **Bug Bounty Hunters**¬† (en un contexto de pirater√≠a √©tica) para probar manualmente formularios en busca de vulnerabilidades de inyecci√≥n SQL:

- payload de inyecci√≥n SQL b√°sica: **' OR '1'='1** (se utiliza para omitir la autenticaci√≥n ingresando una condici√≥n que siempre es verdadera).
- Recuperar informaci√≥n: **' UNION SELECT null,username,password FROM users--** (Se utiliza para extraer datos confidenciales como nombre de usuario y contrase√±a de la base de datos).
- Manipulaci√≥n de consultas: **'; DROP TABLE users; --** (Se utiliza para provocar la eliminaci√≥n de la tabla "usuarios").
- Obtener los nombres de las tablas: **' AND 1=0 UNION SELECT table_name, null FROM information_schema.tables--** (Se utiliza para extraer los nombres de las tablas en la base de datos).
- Extraer nombre de la base de datos: **' AND 1=0 UNION SELECT null, database()--** (Se utiliza para extraer el nombre de la base de datos actual).
- Uso de UNION para extraer datos: **' UNION SELECT username, password FROM users--** (Se utiliza para extraer datos confidenciales mediante una operaci√≥n UNION).
- Uso de comentarios para omitir: **admin' --** (Utiliza un comentario para omitir el resto de la entrada e iniciar sesi√≥n como administrador).
- Uso de SQLi ciego basado en tiempo: **' OR IF(1=1, SLEEP(5), 0)--** (Retrasa la respuesta del servidor para confirmar la vulnerabilidad de inyecci√≥n SQL).
- Uso de SQLi basado en errores: **' AND 1=CONVERT(int, (SELECT @@version))--** (fuerza un error de SQL a revelar informaci√≥n de la base de datos).

Todas estas cargas √∫tiles se pueden usar (y son las m√°s efectivas) en **formularios de inicio de sesi√≥n** vulnerables , **URL** (usadas como consultas maliciosas) y **solicitudes** (capturadas y modificadas por usted con la carga √∫til correcta).

### **Pruebas automatizadas de inyecci√≥n de SQL**

Cuando se trata de seguridad de la informaci√≥n, herramientas como SQLmap y Burp Suite gozan de gran prestigio en el campo de las pruebas de inyecci√≥n SQL.

### **Descripci√≥n general de las herramientas: SQLmap y Burp Suite**

Estas herramientas son ampliamente utilizadas por los profesionales de la seguridad y brindan soluciones automatizadas efectivas para detectar y explotar vulnerabilidades de inyecci√≥n SQL en aplicaciones web. Si bien SQLmap se especializa en pruebas y automatizaci√≥n avanzadas, Burp Suite ofrece un ecosistema completo para analizar la seguridad de las aplicaciones. Permite a los expertos identificar, evaluar y abordar vulnerabilidades cr√≠ticas, incluidas aquellas relacionadas con ataques de inyecci√≥n SQL.

Ahora veamos en detalle para qu√© sirven estas herramientas y para qu√© se utilizan:

- **SQLmap** : es una valiosa herramienta de c√≥digo abierto que automatiza las pruebas de inyecci√≥n de SQL. Detecta vulnerabilidades de forma eficaz, extrae datos y compromete los sistemas de bases de datos utilizando una variedad de cargas √∫tiles y t√©cnicas. Los probadores de penetraci√≥n dependen principalmente de SQLmap para evaluar la seguridad de las aplicaciones.

![SQL 10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql10.png?raw=true)

- **Burp Suite** : es un conjunto completo de herramientas dise√±adas para la seguridad de aplicaciones web. Entre sus caracter√≠sticas, la herramienta incluye un m√≥dulo de Seguridad de Aplicaciones Web (WAS), que ayuda a los especialistas en seguridad a identificar y abordar vulnerabilidades en sitios web. Este m√≥dulo puede detectar amenazas de seguridad comunes que incluyen, como es de esperar, ataques de inyecci√≥n SQL.

![SQL 11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql11.png?raw=true)

### **Ejecuci√≥n de SQLmap para buscar y explotar inyecciones de SQL**

Ahora, usemos SQLmap para descubrir sistem√°ticamente vulnerabilidades de inyecci√≥n SQL en un sitio web deliberadamente vulnerable. Nuestro objetivo ser√° VulnWeb ( http://testphp.vulnweb.com ), un sitio web dise√±ado espec√≠ficamente para que los estudiantes de Seguridad Cibern√©tica aprendan atacando y explotando sus vulnerabilidades.

Si encuentra una URL web como, en este caso, [http://testphp.vulnweb.com/listproducts.php](http://testphp.vulnweb.com/listproducts.php)? **cat=1** , donde el par√°metro 'GET' est√° resaltado, podr√≠a indicar que el sitio web es susceptible a ataques de inyecci√≥n SQL. En tales casos, es posible que pueda acceder a informaci√≥n confidencial de la base de datos. Se sabe que SQLmap es el m√°s eficaz en escenarios que involucran sitios web basados ‚Äã‚Äãen PHP.

![SQL 12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql12.png?raw=true)

**Paso 1: Evaluaci√≥n del par√°metro de la URL**

Una forma sencilla de determinar si su sitio web es vulnerable es reemplazar el valor en el par√°metro de solicitud de obtenci√≥n con un *****¬† (asterisco).

![SQL 13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql13.png?raw=true)

Este tipo de error sugiere que el sitio web es vulnerable a alg√∫n tipo de ataques de inyecci√≥n SQL.

**Paso 2: comprobar la URL con SQLmap**

Necesitamos ingresar la URL web deseada que debe verificarse, usando el par√°metro -u . Generalmente el objetivo principal es determinar si es posible acceder a una base de datos, por lo que podemos utilizar la opci√≥n --dbs¬† para este prop√≥sito. Al utilizar --dbs, podemos obtener una lista de todas las bases de datos disponibles.

El primer comando ser√°:

`sqlmap -u [http://testphp.vulnweb.com/listproducts.php?cat=1](http://testphp.vulnweb.com/listproducts.php?cat=1) --dbs`

![SQL 14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql14.png?raw=true)

**Paso 3: comprender el resultado**

En el resultado anterior, puede ver en amarillo las partes donde SQLmap encontr√≥ vulnerabilidades de inyecci√≥n SQL y en naranja las mejores cargas √∫tiles, sugeridas por SQLmap, para usar ese tipo espec√≠fico de inyecci√≥n SQL (por ejemplo, la primera vulnerabilidad encontrada es una vulnerabilidad booleana). **Inyecci√≥n SQL ciega** basada y la carga √∫til sugerida es: cat-1 AND 1050-1050). Tomemos, por ejemplo, la √∫ltima parte del resultado, resaltada en amarillo, que dice: ‚ÄúEl par√°metro GET **'cat'** es ' **Consulta UNION gen√©rica** '.

Esta parte del resultado nos dice que el par√°metro "cat" de una solicitud GET (que es el tipo de solicitud web que, en este caso, SQLmap est√° usando para probar la URL) dentro de "[http://testphp.vulnweb.com](http://testphp.vulnweb.com/) /listaproductos.php? **cat** =1‚Äù es vulnerable a una consulta UNION gen√©rica.

**Pero ¬øqu√© es una consulta UNION Gen√©rica?**

Es un ataque que normalmente implica manipular la consulta SQL para combinar los resultados de 2 o m√°s tablas de bases de datos, lo que le permite obtener acceso no autorizado a datos confidenciales. En resumen, este resultado de SQLmap sugiere que se necesitan m√°s pruebas para confirmar si el par√°metro **'cat'** es realmente vulnerable a un ataque de inyecci√≥n SQL de "consulta UNION gen√©rica". Es una se√±al para investigar y potencialmente explotar una vulnerabilidad en la validaci√≥n de entrada de la aplicaci√≥n (que es la parte de la aplicaci√≥n web que verifica y permite la entrada del usuario seg√∫n la consulta utilizada).

Y es por eso que podemos ver, en el √∫ltimo resultado resaltado en naranja, que SQLmap sugiere una carga √∫til espec√≠fica, para probar manualmente el sitio web vulnerable para ese tipo de ataque de inyecci√≥n SQL.

## **An√°lisis de mensajes de error**

Durante el proceso de an√°lisis de errores en las pruebas de inyecci√≥n SQL, los errores generados por una aplicaci√≥n pueden ofrecer informaci√≥n importante sobre la existencia de vulnerabilidades. Por ejemplo, los mensajes de error que contienen informaci√≥n confidencial como nombres de tablas, errores flagrantes de sintaxis SQL en los comentarios de la aplicaci√≥n y respuestas inconsistentes, como resultados faltantes o duplicados, pueden indicar una posible manipulaci√≥n de la consulta.

![SQL 15](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql15.png?raw=true)

Estos mensajes de error pueden ofrecer informaci√≥n valiosa sobre el funcionamiento interno del sistema. Para activar estos mensajes, se pueden ingresar intencionalmente datos maliciosos que provoquen que las consultas fallen. En la imagen de arriba, puede ver un error de sintaxis SQL (que ya mencionamos antes) que aparece despu√©s de cambiar el valor del par√°metro **cat de " 1** " a ***** (ejemplo de entrada maliciosa).

Si encuentra errores de sintaxis SQL, como el com√∫nmente visto "Tiene un error en su sintaxis SQL" (que podemos ver en la imagen), generalmente significa que la entrada se incluye directamente en las consultas sin la verificaci√≥n adecuada. Este tipo de errores a menudo indican un comportamiento interno del sistema y ayudan a los expertos en seguridad a identificar posibles debilidades en las aplicaciones.

## **Preguntas frecuentes**

- **¬øEs ilegal realizar pruebas de inyecciones de SQL?**

La legalidad de cualquier Pentest depende √∫nicamente de las leyes locales y federales de su pa√≠s, por lo que es una buena pr√°ctica estar informado sobre ellas antes de realizar cualquier tipo de prueba activa. Sin embargo, no deber√≠a haber ning√∫n problema siempre que la actividad se realice de manera responsable y en plataformas donde se haya obtenido el **permiso por escrito**¬† del propietario.

- **¬øQu√© son las t√©cnicas de inyecci√≥n SQL?**

Existen varias t√©cnicas que se pueden utilizar para manipular consultas, como ataques UNION, ataques basados ‚Äã‚Äãen tiempo y ataques basados ‚Äã‚Äãen errores. Estas t√©cnicas implican el uso de datos maliciosos para explotar vulnerabilidades.

- **¬øCu√°l es la mejor herramienta de inyecci√≥n SQL?**

Para fines de automatizaci√≥n, SQLmap se utiliza ampliamente, mientras que Burp Suite ofrece una soluci√≥n vers√°til para an√°lisis de seguridad.

- **¬øNecesito aprender SQL para inyecciones de SQL?**

Tener algunos conocimientos de SQL puede resultar √∫til, pero tambi√©n hay herramientas disponibles que pueden simplificar el proceso de identificaci√≥n de vulnerabilidades.

## **Inyecci√≥n SQL ciega**

La inyecci√≥n ciega de SQL, una forma sigilosa y astuta de ataque de inyecci√≥n de SQL, plantea un desaf√≠o √∫nico para los profesionales de la seguridad debido a su naturaleza esquiva y su dificultad de detecci√≥n y explotaci√≥n. En este completo art√≠culo, profundizaremos en el mundo de la inyecci√≥n SQL ciega y descubriremos los matices sutiles que la distinguen de otros ataques de inyecci√≥n SQL.

A lo largo del art√≠culo, analizaremos varias herramientas y m√©todos, centr√°ndonos en Kali Linux como nuestra plataforma preferida, aunque puede utilizar las herramientas mencionadas en la mayor√≠a de los sistemas operativos. A medida que concluimos, le brindaremos un conjunto de mejores pr√°cticas probadas para defender sus aplicaciones web contra estos ataques esquivos y potencialmente da√±inos. Al final de este art√≠culo, estar√° bien versado en c√≥mo comprender, explotar y defenderse contra las vulnerabilidades de inyecci√≥n SQL ciega.

Ahora, profundicemos en esta gu√≠a detallada y prep√°rese con los conocimientos y t√©cnicas esenciales para abordar de manera efectiva los desaf√≠os que plantea este tipo de vulnerabilidad.

### **¬øQu√© es la inyecci√≥n SQL ciega?**

La inyecci√≥n SQL es una vulnerabilidad frecuente de las aplicaciones web que ocurre cuando un atacante logra ejecutar **c√≥digo SQL** no autorizado en la base de datos de una aplicaci√≥n web. Los atacantes hacen esto insertando declaraciones SQL maliciosas en los campos de entrada del usuario, como cuadros de b√∫squeda o formularios de inicio de sesi√≥n. Cuando tiene √©xito, un atacante puede obtener informaci√≥n confidencial de la base de datos, modificar o eliminar datos e incluso ejecutar comandos administrativos.

La inyecci√≥n ciega de SQL, una variante m√°s oculta, ocurre cuando el atacante **no puede ver directamente el resultado** de sus consultas inyectadas. En este caso, deben deducir los resultados indirectamente utilizando t√©cnicas basadas en contenido o en tiempo. Este tipo de ataque se utiliza cuando la aplicaci√≥n no muestra visiblemente los resultados de una consulta SQL inyectada, lo que dificulta que el atacante confirme el √©xito de sus acciones.

El beneficio de utilizar la inyecci√≥n SQL ciega sobre un ataque de inyecci√≥n SQL est√°ndar radica en su sutileza. Dado que el atacante no ve directamente el resultado, puede resultar m√°s dif√≠cil para los sistemas de seguridad o los administradores detectar el ataque. El atacante suele utilizar respuestas condicionales ( **basadas en booleanos** ) o retrasos en el tiempo de respuesta de la aplicaci√≥n ( **basadas en tiempos** ) para inferir si el c√≥digo SQL inyectado ha tenido el efecto deseado.

Al recopilar lenta y met√≥dicamente informaci√≥n sobre la estructura y el contenido de la base de datos, un atacante a√∫n puede explotar una vulnerabilidad de inyecci√≥n SQL ciega para acceder a datos confidenciales y manipular el sistema sin levantar sospechas inmediatas.

## **Descargo de responsabilidad**

Queremos ser absolutamente claros sobre la importancia de cumplir con las leyes aplicables con respecto al escaneo y la explotaci√≥n de vulnerabilidades de aplicaciones web. Antes de realizar cualquier forma de pirater√≠a √©tica o prueba de penetraci√≥n en un sistema, **aseg√∫rese de haber obtenido el permiso expl√≠cito** del sistema o del propietario de la red.

La pirater√≠a o el escaneo no autorizados pueden parecer triviales, pero pueden acarrear graves consecuencias legales, incluidas multas o prisi√≥n, seg√∫n su jurisdicci√≥n. **No lo hagas.** Algunas de las leyes que rigen esta actividad incluyen:

- La Ley de Abuso y Fraude Inform√°tico (Estados Unidos)
- Secciones 184, 342.1, 380 y 430 del C√≥digo Penal de Canad√° (Canad√°)
- Ley de uso indebido de computadoras de 1990 (Inglaterra)
- Segundo. 202a y 202b del C√≥digo Penal alem√°n (Alemania)
- Ley de Tecnolog√≠a de la Informaci√≥n Sec. 43 y 66 (India)
- Ley sobre la prohibici√≥n del acceso no autorizado a ordenadores (Jap√≥n)

 Si duda si est√° actuando con claridad, consulte el acuerdo o el alcance de sus actividades autorizadas con una entidad espec√≠fica o revise el c√≥digo de conducta o las pautas de divulgaci√≥n con cualquiera de los programas de recompensas por errores mencionados al final de este art√≠culo.

## **Descubriendo y explotando SQLi ciego**

Ahora que tiene un conocimiento s√≥lido de la inyecci√≥n SQL ciega y en qu√© se diferencia de la inyecci√≥n SQL normal, profundicemos en el **proceso de descubrir** y explotar estas vulnerabilidades.¬† Primero, lo guiaremos en la configuraci√≥n de su entorno de laboratorio, luego realizaremos pruebas manuales de inyecci√≥n ciega de SQL y, finalmente, usaremos herramientas como SQLMap y Burp Suite para agilizar el proceso de explotaci√≥n.

### **Configurando su laboratorio**

Para comenzar, deber√° configurar su laboratorio para descubrir y explotar vulnerabilidades de inyecci√≥n SQL ciega. Hay **varias herramientas que puede utilizar** y usaremos las siguientes herramientas y recursos:

**Maldita aplicaci√≥n web vulnerable (DVWA):** DVWA es una aplicaci√≥n web intencionalmente vulnerable que proporciona un entorno seguro para practicar diversas t√©cnicas. **Viene preinstalado en Kali Linux** o puedes descargarlo con sudo apt install dvwa. Una vez instalado, establezca el nivel de dificultad en "bajo" o "medio" y navegue hasta el desaf√≠o "Inyecci√≥n SQL (ciega)". Usaremos esto para simular un escenario del mundo real y demostrar m√©todos de prueba. Para iniciar la aplicaci√≥n DVWA:

1. Abra la terminal y escriba el comando: dvwa-start.
2. Si no est√° en la cuenta ra√≠z, se le pedir√° que lo permita.
3. El navegador deber√≠a abrirse autom√°ticamente en DVWA.
4. (Alternativamente) Si no se abre, vaya al navegador e ingrese: **[http://127.0.0.1:42001](http://127.0.0.1:42001/)**en la barra de direcciones.
5. Para detener el servidor DVWA, regrese a la terminal y escriba el comando: dvwa-stop.

**SQLMap:** esta poderosa herramienta de c√≥digo abierto automatiza la detecci√≥n y explotaci√≥n de vulnerabilidades de inyecci√≥n SQL. **Viene preinstalado en Kali Linux** , por lo que si ese es el sistema operativo que est√°s usando, no necesitas descargarlo por separado. Usaremos SQLMap para automatizar la explotaci√≥n de la vulnerabilidad de inyecci√≥n SQL ciega descubierta en DVWA.

**Burp Suite:** Burp Suite es un conjunto de herramientas de prueba de seguridad de aplicaciones web ampliamente utilizado. Para este art√≠culo, usaremos la Community Edition, **que viene preinstalada en Kali Linux** . Esto se utilizar√° para interceptar las solicitudes realizadas a la DVWA. Demostraremos un m√©todo alternativo de prueba con SQLMap capturando una solicitud con Burp, guard√°ndola como un archivo de texto y luego ejecut√°ndola a trav√©s de SQLMap. Se recomienda que s√≥lo ejecute DVWA u otras aplicaciones intencionalmente vulnerables en un entorno virtual.

## **Pruebas de inyecci√≥n SQL ciega**

La detecci√≥n de una inyecci√≥n SQL ciega implica enviar consultas que producen respuestas condicionales o retrasan el tiempo de respuesta del servidor. Lo guiaremos a trav√©s de cada paso del proceso para que pueda realizar pruebas exhaustivas de inyecci√≥n SQL ciega y comprender el razonamiento o el comportamiento detr√°s de cada acci√≥n. Como nota, la estructura de consulta exacta o los comandos pueden variar seg√∫n la base de datos utilizada. Se demuestra MySQL.

**Paso 1: respuesta normal**

Comience enviando una respuesta normal, como ingresar '2', para ver c√≥mo se comporta la aplicaci√≥n en circunstancias normales. Esto ayuda a establecer una base para el comportamiento esperado sin necesidad de inyectar c√≥digo SQL.

![SQL 16](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql16.png?raw=true)

**Paso 2: prueba sencilla**

Realice una prueba sencilla ingresando una comilla simple ( 2‚Äò#) despu√©s del '2' para verificar si esto podr√≠a indicar una vulnerabilidad potencial en la aplicaci√≥n web. Si se produce un error o el comportamiento cambia, podr√≠a sugerir que la aplicaci√≥n est√° manejando incorrectamente la entrada del usuario y puede ser susceptible a la inyecci√≥n SQL. Este ( ‚Äò) no es obligatorio en todos los casos y puede variar seg√∫n la base de datos en la que est√© probando.

NOTA: Al realizar pruebas dentro de un campo de formulario, debe colocar un #al final de su consulta para comentar cualquier texto que el programa pueda agregar posteriormente.

![SQL 17](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql17.png?raw=true)

**Paso 3: prueba de verdadero/falso**

Realice las pruebas de verdadero/falso inyectando condiciones " " 2‚Äô AND 1=1#(siempre verdadera) y " 2‚Äô AND 1=0#" (siempre falsa) y observe las respuestas de la aplicaci√≥n a ambas consultas. Si el comportamiento de la aplicaci√≥n cambia seg√∫n la veracidad de la condici√≥n inyectada, indica que el c√≥digo SQL se est√° ejecutando, confirmando la presencia de una vulnerabilidad.

En un ataque de inyecci√≥n SQL normal, esta condici√≥n verdadera podr√≠a devolver informaci√≥n adicional de una tabla, pero ese no es el caso en un ataque ciego. Nuevamente, est√°s buscando cambios en la respuesta.

![SQL 18](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql18.png?raw=true)

*El resultado de 1=1, una condici√≥n intencionalmente verdadera.*

![SQL 19](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql19.png?raw=true)

*El resultado de 1=0, una condici√≥n intencionalmente falsa.*

**Paso 4: prueba basada en el tiempo**

Pruebe el m√©todo basado en tiempos introduciendo " 2‚Äô AND SLEEP(5)#" en la consulta. Compare el tiempo de respuesta con y sin el comando de suspensi√≥n. Un retraso notable indica una vulnerabilidad potencial, ya que demuestra que la aplicaci√≥n est√° ejecutando el comando SQL inyectado y esperando el tiempo especificado antes de devolver una respuesta.

![SQL 20](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql20.png?raw=true)

> *Ejecutar el ataque basado en el tiempo.*

![SQL 21](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql21.png?raw=true)

> *Ataque basado en tiempo completo.*

**Paso 5: determinar las columnas**

Determine la cantidad de columnas en la base de datos usando la 2‚Äô ORDER BY X#condici√≥n " ", donde X es la cantidad de columnas que estamos probando. Incremente el n√∫mero hasta que cambie el comportamiento de la aplicaci√≥n, lo que significa que ha encontrado la longitud correcta. Este paso es esencial para comprender la estructura de la base de datos, lo que puede resultar √∫til a la hora de explotar la vulnerabilidad.

![SQL 22](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql22.png?raw=true)

> *Prueba manual para una longitud de columna de 1.*

![SQL 23](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql23.png?raw=true)

> *Prueba manual para una longitud de columna de 2.*

<aside>
üëâ En nuestro caso, la aplicaci√≥n web arroj√≥ un error cuando probamos una longitud de columna de 3. Este cambio en el comportamiento nos permite saber que hemos identificado que el n√∫mero correcto de columnas es 2, ya que esa fue la √∫ltima prueba exitosa antes del cambio. . Esto se aprende observando el cambio en respuesta.

</aside>

**Paso 6: Determinar la longitud de DB**

A continuaci√≥n, demostraremos la 2‚Äô AND LENGTH(DATABASE())=X#condici√≥n " ", donde X es el n√∫mero de caracteres que se prueban. Esto se puede utilizar para determinar la longitud del nombre de la base de datos. Usaremos el mismo enfoque que acabamos de usar para determinar el n√∫mero de columnas, excepto que esta vez intentamos obtener el n√∫mero de caracteres en el nombre de la base de datos. Para hacer esto, probaremos por longitud de caracteres de manera iterativa.

![SQL 24](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql24.png?raw=true)

> *Prueba para una longitud de car√°cter de 1.*

![SQL 25](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql25.png?raw=true)

> *Finalmente, un cambio indica una longitud de nombre de base de datos de 4.*

Esto tambi√©n se puede realizar con un comando de suspensi√≥n en los casos en que no haya un indicador visual disponible. Por ejemplo, utilice " 2‚Äô AND LENGTH(DATABASE())=X AND SLEEP(5)#" donde X es la longitud sospechosa de la base de datos. Si el comando de suspensi√≥n retrasa la respuesta de la aplicaci√≥n, confirma la longitud correcta de la base de datos.

![SQL 26](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql26.png?raw=true)

**Paso 7: determinar el nombre de la base de datos**

Finalmente, podemos comenzar a enumerar el nombre real de la base de datos. Ya sabemos que tiene cuatro caracteres, pero podemos hacer m√°s determinando cu√°les son esos caracteres. Para hacer esto, probaremos diferentes caracteres ASCII usando 2‚Äô AND ASCII(SUBSTR(DATABASE(),X,X))>YY#. En este caso X, es la posici√≥n del car√°cter que estamos probando y YYes el **[car√°cter decimal ASCII](https://www.asciitable.com/)** .

Con este m√©todo, le pregunta a la base de datos si el primer car√°cter es mayor que una letra establecida. Si no es as√≠, responder√° con una negativa. Comenzaremos en alg√∫n lugar cerca de la mitad del alfabeto min√∫sculo con ‚Äúl‚Äù (que es el decimal ASCII 108). Entonces la consulta se ve as√≠: 2‚Äô AND ASCII(SUBSTR(DATABASE(),1,1))>108#.

![SQL 27](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql27.png?raw=true))

Seg√∫n la respuesta, sabemos que el primer car√°cter no es mayor que ‚Äúl‚Äù, por lo que tenemos que cambiar la operaci√≥n para preguntar si es menor que ‚Äúl‚Äù. Hacemos esto cambiando la consulta a 2‚Äô AND ASCII(SUBSTR(DATABASE(),1,1))<108#.

![SQL 28](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql28.png?raw=true)

![SQL 29](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql29.png?raw=true)

Seg√∫n esta respuesta, ahora sabemos que la primera letra est√° en alg√∫n lugar entre la ‚Äúl‚Äù min√∫scula y todos los caracteres ASCII anteriores. T√©cnicamente, esto incluye todas las may√∫sculas, n√∫meros y caracteres especiales. Sabiendo esto podemos empezar a probar de forma incremental hasta que veamos un cambio en la respuesta. En nuestro caso, vemos una respuesta modificada una vez que ingresamos 100.

![SQL 30](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql30.png?raw=true)

![SQL 31](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql31.png?raw=true)

Esto ahora nos dice que el car√°cter no es menor que una ‚Äúd‚Äù min√∫scula. Podemos confirmar que esta es la letra correcta invirtiendo la consulta.

![SQL 32](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql32.png?raw=true)

![SQL 33](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql33.png?raw=true)

Hemos confirmado con √©xito el primer personaje. Ahora, podemos usar este mismo m√©todo cambiando la consulta a la ubicaci√≥n del segundo car√°cter y repitiendo esto nuevamente. Nos aseguraremos de cambiar la ubicaci√≥n ingresando 2‚Äô AND ASCII(SUBSTR(DATABASE(),2,2))<108#.

![SQL 34](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql34.png?raw=true)

![SQL 35](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql35.png?raw=true)

![SQL 36](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql36.png?raw=true)

> *Con este resultado, sabemos que el segundo car√°cter es mayor que la ‚Äúl‚Äù min√∫scula.*

A estas alturas, deber√≠a comprender el fundamento de cada paso. Al observar el comportamiento de la aplicaci√≥n en respuesta a varios comandos SQL inyectados, puede identificar y comprender eficazmente las vulnerabilidades de inyecci√≥n SQL ciega.

En la siguiente secci√≥n, demostraremos c√≥mo explotar estas vulnerabilidades con la ayuda de SQLMap. Contin√∫e practicando estas t√©cnicas en un entorno controlado para perfeccionar sus habilidades y convertirse en un experto en la detecci√≥n y explotaci√≥n de ataques de inyecci√≥n SQL ciega.

### **Ejemplo 1: Explotaci√≥n de la inyecci√≥n SQL ciega**

Ahora que hemos confirmado la vulnerabilidad, seguiremos los pasos para explotarla usando SQLMap. Preste atenci√≥n a las capturas de pantalla de cada paso para una mejor comprensi√≥n. A√∫n mejor, sigue las instrucciones para consolidar realmente el proceso y el aprendizaje en tu mente y desarrollar esta habilidad.

**Paso 1: familiarizarse con SQLMap**

Abra la p√°gina de ayuda de SQLMap para familiarizarse con el tipo de informaci√≥n necesaria para un ataque y la estructura de comando de la herramienta. En concreto veremos que podemos utilizar una URL con la -ubandera y la informaci√≥n de la cookie con la bandera `--cookie=COOKIE.`

`sqlmap -h`

![SQL 37](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql37.png?raw=true)

**Paso 2: recuperar informaci√≥n de la sesi√≥n**

Recopile las cookies requeridas y el nivel de seguridad del Panel de desarrollador del navegador en la pesta√±a Almacenamiento.

![SQL 38](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql38.png?raw=true)

**Paso 3: comando URL de SQLMap**

Ejecute SQLMap con la informaci√≥n -uy --cookie=. Revise la informaci√≥n resultante, que incluye los par√°metros, la carga √∫til y la ubicaci√≥n de los archivos de salida.

![SQL 39](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql39.png?raw=true)

> *SQLMap ejecutando ataque URL.*

![SQL 40](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql40.png?raw=true)

> *Devoluci√≥n de par√°metros y ubicaci√≥n de salida.*

**Paso 4: abrir el archivo de sesi√≥n**

Ahora iremos a la terminal y navegaremos hasta la ubicaci√≥n del archivo de salida. Primero, lo usaremos para ver con qu√© archivos tenemos para trabajar. Util√≠celo sqlitebrowserpara abrir el session.sqlitearchivo.

![SQL 41](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql41.png?raw=true)

**Paso 5: Navegador de base de datos**

En el navegador sqlite, examine la estructura de la base de datos y explore las pesta√±as de datos.

![SQL 42](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql42.png?raw=true)

> *Visualizaci√≥n de la pesta√±a "Estructura de la base de datos" en DB Browser.*

![SQL 43](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql43.png?raw=true)

> *Visualizaci√≥n de la pesta√±a "Buscar datos" en DB Browser.*

**Paso 6: ver el archivo de destino**

Regrese a la terminal y use cat target.txtpara ver el archivo que contiene el comando que us√≥.

![SQL 44](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql44.png?raw=true)

**Paso 7: Ver registro**

√öselo cat log para ver el contenido del registro. Esto incluye la misma informaci√≥n de par√°metros y carga √∫til que vimos anteriormente, as√≠ como detalles sobre la base de datos y la tecnolog√≠a de la aplicaci√≥n web. Toda esta informaci√≥n podr√≠a ser √∫til en cualquier seguimiento de las pruebas de penetraci√≥n que podamos realizar en etapas posteriores.

![SQL 45](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql45.png?raw=true)

**Paso 8: URL de SQLMap con indicador de nombre de base de datos**

Ahora regresaremos a la terminal y ejecutaremos el mismo comando en SQLMap, pero esta vez agregaremos '--dbs' para descubrir el nombre de la base de datos. Sabemos que tiene cuatro caracteres debido a nuestra prueba manual anterior, pero queremos saber m√°s sobre esta base de datos.

![SQL 46](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql46.png?raw=true)

> *¬°Y ah√≠ est√°, ‚Äúdvwa‚Äù!*

**Paso 9: URL de SQLMap con indicador de columna**

A continuaci√≥n, queremos obtener las columnas de usuario con las banderas -D dvwa -T users --columns. Esto le proporcionar√° mucha m√°s informaci√≥n sobre lo que realmente hay dentro de la base de datos.

![SQL 47](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql47.png?raw=true)

![SQL 48](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql48.png?raw=true)

**Paso 10: URL de SQLMap con indicador de volcado de usuario**

Ahora llegamos a la parte buena, util√≠cela -T users --dumppara extraer datos de la tabla del usuario. Revise la respuesta y observe c√≥mo SQLMap le solicita que descifre el hash de las contrase√±as que descubre y luego le presenta los resultados en una tabla clara y ordenada.

![SQL 49](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql49.png?raw=true)

![SQL 50](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql50.png?raw=true)

> *Aqu√≠ revisa la base de datos y extrae informaci√≥n del usuario.*

![SQL 51](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql51.png?raw=true)

> *SQLMap ofrece descifrar los hashes de contrase√±as. ¬°S√≠, por favor!*

![SQL 52](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql52.png?raw=true)

Observe la ordenada disposici√≥n de la informaci√≥n en la imagen de arriba. Adem√°s de simplemente descifrar las contrase√±as y colocarlas en una tabla ordenada, SQLMap tambi√©n genera autom√°ticamente esa informaci√≥n en un archivo .csv. Luego, esto se puede incorporar a otras herramientas para realizar m√°s exploits durante un caso de prueba de penetraci√≥n.

### **Ejemplo 2: Explotaci√≥n de la inyecci√≥n SQL ciega con datos HTTP**

Ahora demostraremos un m√©todo alternativo para explotar la inyecci√≥n SQL ciega utilizando SQLMap y **la recopilaci√≥n de datos HTTP de Burp Suite** .

**Paso 1: Intercepta el tr√°fico con Burp Suite**

Abra Burp Suite, que ha configurado para capturar el tr√°fico HTTP. Luego navegue hasta la pesta√±a Proxy y localice el env√≠o de la consulta en el historial HTTP.

![SQL 53](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql53.png?raw=true)

**Paso 2: enviar solicitud al repetidor**

En el panel Solicitud, haga clic derecho en el env√≠o de la consulta y seleccione 'Enviar al repetidor'.

**Paso 3: copie los datos sin procesar de Burp Suite**

Cambie a la pesta√±a Repetidor y copie los datos de la solicitud sin procesar del panel.

![SQL 54](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql54.png?raw=true)

**Paso 4: crear archivo de solicitud**

Pegue los datos de la solicitud sin procesar en un archivo nuevo que usar√° con SQLMap. En nuestro ejemplo, llamamos a este archivo request.

![SQL 55](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql55.png?raw=true)

**Paso 5: SQLMap carga el archivo de solicitud HTTP**

Regrese a la terminal y ejecute el comando sqlmap -r request. El -rindicador le indica a SQLMap que analice y utilice la solicitud HTTP sin formato del archivo especificado.

![SQL 56](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql56.png?raw=true)

Como en el m√©todo anterior, SQLMap ofrecer√° descifrar los hash de contrase√±a del usuario descubierto una vez que haya extra√≠do los datos.

![SQL 57](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql57.png?raw=true)

<aside>
üëâ Este m√©todo proporciona una alternativa a la introducci√≥n manual de informaci√≥n de cookies y URL en la l√≠nea de comando, lo que agiliza el proceso utilizando el tr√°fico HTTP capturado. Como en los m√©todos anteriores, esta informaci√≥n se env√≠a a su directorio y puede estudiarse o utilizarse para esfuerzos futuros.

</aside>

## **Defensa contra la inyecci√≥n SQL ciega**

Si sigue las mejores pr√°cticas y pautas recomendadas por organizaciones acreditadas como **OWASP** , NIST, W3 y Amazon AWS, puede fortalecer significativamente las defensas de su aplicaci√≥n contra estos ataques.

Estas organizaciones proporcionan informaci√≥n y recursos valiosos que cubren una amplia gama de temas, incluidas pr√°cticas de codificaci√≥n segura, seguridad de bases de datos, defensas de aplicaciones web y monitoreo y respuesta a incidentes. En esta secci√≥n, exploraremos estas mejores pr√°cticas en detalle y le brindaremos pasos pr√°cticos para ayudar a proteger su aplicaci√≥n web contra vulnerabilidades de inyecci√≥n SQL ciega.

### **Pr√°cticas de codificaci√≥n segura**

La implementaci√≥n de pr√°cticas de codificaci√≥n segura es crucial para defenderse contra ataques de inyecci√≥n SQL ciega. **[OWASP recomienda utilizar declaraciones preparadas](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)** o consultas parametrizadas para separar la entrada del usuario del c√≥digo SQL, lo que reduce el riesgo de inyecci√≥n. Adem√°s, la incorporaci√≥n de t√©cnicas de validaci√≥n de entradas, como las listas blancas, ayuda a **restringir los tipos de datos que pueden introducir** los usuarios, lo que mejora a√∫n m√°s la seguridad.

### **Seguridad de la base de datos**

Las medidas de seguridad de la base de datos son esenciales para minimizar el impacto potencial de un ataque. Limitar los privilegios de los usuarios de la base de datos garantiza que los atacantes no puedan obtener acceso a informaci√≥n confidencial ni realizar acciones no autorizadas. Actualizar y parchear peri√≥dicamente su sistema de administraci√≥n de bases de datos ayuda a abordar las vulnerabilidades conocidas, lo que dificulta que los atacantes las exploten. Puede leer m√°s sobre esto en **[NIST SP 800-44 versi√≥n 2](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** (la Secci√≥n 6.4.2 analiza esto espec√≠ficamente).

### **Defensas de aplicaciones web**

La implementaci√≥n de defensas de aplicaciones web, como un firewall de aplicaciones web (WAF), puede ayudar a detectar y bloquear los intentos de inyecci√≥n de SQL. **[Amazon AWS analiza](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-use-case.html)** c√≥mo un WAF analiza el tr√°fico entrante y filtra solicitudes maliciosas a trav√©s de grupos de reglas administrados por bases de datos, lo que reduce la probabilidad de un ataque exitoso.

### **Seguimiento y respuesta a incidentes**

Monitorear y registrar la actividad de las aplicaciones es vital para identificar actividades sospechosas y detectar posibles ataques desde el principio. **[NIST recomienda](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** establecer un sistema s√≥lido de registro y monitoreo, junto con un plan de respuesta a incidentes bien definido, que garantice respuestas r√°pidas y efectivas a los incidentes de seguridad.

## **Conclusi√≥n**

A lo largo de este art√≠culo, hemos profundizado en la inyecci√≥n SQL ciega, explorando sus caracter√≠sticas √∫nicas y las t√©cnicas utilizadas para descubrir y explotar estas vulnerabilidades. Desde configurar un entorno de prueba con DVWA y Kali Linux hasta realizar pruebas manuales y utilizar herramientas como SQLMap y Burp Suite, le proporcionamos orientaci√≥n pr√°ctica y consejos pr√°cticos para adquirir habilidades en este tema complejo.

Adem√°s, hemos enfatizado la importancia de implementar medidas de seguridad s√≥lidas, como pr√°cticas de codificaci√≥n segura, seguridad de bases de datos, defensas de aplicaciones web y monitoreo y respuesta a incidentes para protegerse contra ataques de inyecci√≥n SQL ciega.

Como hemos demostrado, la inyecci√≥n ciega de SQL es un desaf√≠o formidable en la seguridad cibern√©tica para aplicaciones web, pero con el conocimiento y las habilidades adecuados, puede defenderse eficazmente contra estas amenazas. Contin√∫e su aprendizaje tomando estos cursos para reforzar su aptitud en defensa y pirater√≠a √©tica de aplicaciones web:

## **Preguntas frecuentes**

- **¬øCu√°les son los tipos de inyecci√≥n SQL ciega?**

Hay dos tipos principales de inyecci√≥n SQL ciega:

**Inyecci√≥n SQL ciega basada en booleanos** : en este tipo, los atacantes infieren informaci√≥n de las respuestas de la aplicaci√≥n web, como cambios en el contenido, mensajes de error o c√≥digos de estado HTTP, aunque el resultado de la consulta real no es directamente visible.

**Inyecci√≥n SQL ciega basada en el tiempo** : en este tipo, los atacantes introducen retrasos en sus consultas SQL utilizando funciones sensibles al tiempo (por ejemplo, SLEEP o WAITFOR DELAY) y observan el tiempo de respuesta de la aplicaci√≥n web para inferir informaci√≥n sobre la base de datos. Los diferentes tiempos de respuesta indican si la condici√≥n inyectada era verdadera o falsa.

- **¬øQu√© es la respuesta condicional de inyecci√≥n SQL ciega?**

Una respuesta condicional de inyecci√≥n SQL ciega, tambi√©n conocida como inyecci√≥n SQL ciega basada en contenido o booleana, es una t√©cnica utilizada por los atacantes para extraer informaci√≥n de una aplicaci√≥n web vulnerable sin ver directamente el resultado de sus consultas SQL inyectadas.

En cambio, los atacantes inyectan declaraciones SQL con condiciones verdaderas o falsas y observan cambios en el comportamiento o contenido de la aplicaci√≥n web en funci√≥n de la veracidad de estas condiciones. Al analizar estas respuestas, el atacante puede inferir indirectamente la informaci√≥n que busca en la base de datos.

Piense en esto como un juego malicioso de 20 preguntas.

- **¬øQu√© herramientas se pueden utilizar para explotar la inyecci√≥n SQL ciega?**

Existen varias herramientas que se pueden utilizar para explotar las vulnerabilidades de inyecci√≥n SQL ciega. Algunas de las herramientas m√°s populares y efectivas incluyen:

1. SQLMap: SQLMap, una herramienta de c√≥digo abierto poderosa y ampliamente utilizada, automatiza la detecci√≥n y explotaci√≥n de vulnerabilidades de inyecci√≥n SQL.

2. Burp Suite: Esta es una plataforma integral de prueba de seguridad de aplicaciones web, que incluye una gama de herramientas para detectar y explotar vulnerabilidades de inyecci√≥n SQL ciega, como los m√≥dulos Repetidor e Intruso.

3. Pruebas manuales: si bien las herramientas automatizadas pueden resultar muy √∫tiles, las pruebas manuales siguen desempe√±ando un papel esencial en la detecci√≥n y explotaci√≥n de vulnerabilidades de inyecci√≥n SQL ciega.

- **¬øCu√°les son las se√±ales de que un sitio web es vulnerable a la inyecci√≥n SQL ciega?**

Si bien ning√∫n indicador garantiza la presencia de una vulnerabilidad, los siguientes signos pueden sugerir que una aplicaci√≥n web podr√≠a ser susceptible a una inyecci√≥n SQL ciega:

1. Comportamiento inesperado: si la aplicaci√≥n muestra un comportamiento inusual cuando ciertos caracteres (como comillas simples o dobles) se ingresan en los campos de entrada del usuario, puede indicar que la aplicaci√≥n no est√° manejando o desinfectando adecuadamente la entrada del usuario.

2. Respuestas condicionales: al inyectar consultas SQL que deber√≠an devolver verdadero o falso, si la aplicaci√≥n muestra un comportamiento diferente seg√∫n la veracidad de la condici√≥n inyectada, puede sugerir una vulnerabilidad de inyecci√≥n SQL ciega.

3. Retrasos de tiempo: la aplicaci√≥n experimenta retrasos notables en el tiempo de respuesta cuando se inyectan consultas SQL espec√≠ficas (por ejemplo, al usar la SLEEP()funci√≥n).

4. Mensajes de error: si bien es posible que los mensajes de error no sean directamente visibles en los ataques de inyecci√≥n SQL ciega, se debe evaluar cualquier mensaje de error o respuesta inusual de la aplicaci√≥n.

- **¬øCu√°les son las mejores pr√°cticas para prevenir la inyecci√≥n SQL ciega?**

Las mejores pr√°cticas para prevenir la inyecci√≥n ciega de SQL implican una combinaci√≥n de pr√°cticas de codificaci√≥n segura, medidas de seguridad de bases de datos, defensas de aplicaciones web y estrategias de monitoreo y respuesta a incidentes.

**Advanced SQL Injection**

La inyecci√≥n SQL avanzada es una t√©cnica m√°s sofisticada que la inyecci√≥n SQL b√°sica, que utiliza t√©cnicas m√°s complejas para explotar vulnerabilidades en las aplicaciones web. Esto puede incluir la manipulaci√≥n de los datos de entrada de la aplicaci√≥n, la identificaci√≥n de patrones de filtrado, la explotaci√≥n de errores en la aplicaci√≥n y la utilizaci√≥n de herramientas automatizadas para la inyecci√≥n de c√≥digo malicioso. Este ataque puede tener consecuencias graves, como la exposici√≥n de informaci√≥n confidencial, el robo de datos, la alteraci√≥n de la informaci√≥n almacenada en la base de datos y la p√©rdida de datos importantes. Por lo tanto, es importante que las empresas y desarrolladores de aplicaciones web implementen medidas de seguridad adecuadas para evitar este tipo de ataques.

![SQL 58](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql58.png?raw=true)

## Consecuencias

Las consecuencias de una inyecci√≥n SQL Avanzadas pueden incluir:

- **P√©rdida o alteraci√≥n de datos:** el atacante puede eliminar, modificar o extraer informaci√≥n de la base de datos.
- **Inestabilidad del sistema:** el c√≥digo malicioso puede causar que la base de datos deje de funcionar correctamente, lo que puede resultar en tiempos de inactividad y p√©rdida de disponibilidad.
- **Dificultad para detectar y mitigar el ataque:** debido a que el c√≥digo malicioso se inserta en una consulta SQL leg√≠tima.
- **Posibilidad de propagaci√≥n del ataque:** si el atacante tiene acceso a datos sensibles, como contrase√±as de usuario, puede utilizarlos para propagar el ataque a otros sistemas.
- **Acceso no autorizado:** un atacante podr√≠a obtener acceso no autorizado al sistema o a la aplicaci√≥n web, lo que le permitir√≠a acceder a informaci√≥n confidencial o realizar acciones maliciosas en el sistema.
- **Modificaci√≥n de datos:** un atacante podr√≠a modificar, eliminar o agregar datos al sistema, lo que podr√≠a tener graves consecuencias en la integridad y exactitud de los datos.
- **Ejecuci√≥n de c√≥digo malicioso:** un atacante podr√≠a ejecutar c√≥digo malicioso en el sistema, lo que podr√≠a resultar en la toma de control del sistema o en el robo de informaci√≥n confidencial.
- **Denegaci√≥n de servicio:** un atacante podr√≠a utilizar la inyecci√≥n de comando para sobrecargar el sistema y hacer que se vuelva inoperable.

**La no correcci√≥n de esta falla puede causar divulgaci√≥n no autorizada de su informaci√≥n y la de sus clientes que podr√≠a dar lugar a fraude, usurpaci√≥n de identidad y a sanciones reglamentarias.** Para evitar la inyecci√≥n de comandos, es importante validar y filtrar todas las entradas de usuario en las aplicaciones web, y evitar el uso de comandos de shell en aplicaciones web.¬† Adem√°s, es importante mantener todas las aplicaciones y sistemas actualizados y parcheados para evitar que se exploten vulnerabilidades conocidas.

## Soluci√≥n

Para prevenir y solucionar la inyecci√≥n SQL avanzada, se pueden tomar las siguientes medidas:

- **Validar y sanitizar todas las entradas de datos**: Aseg√∫rese de que todas las entradas de datos, ya sean proporcionadas por los usuarios o por otras fuentes, sean validadas y sanitizadas adecuadamente antes de ser utilizadas en una consulta SQL.
- **Utilizar consultas parametrizadas:** En lugar de construir una consulta SQL din√°micamente utilizando cadenas de texto, utilice consultas parametrizadas que permitan que los par√°metros sean pasados como argumentos separados. Esto reducir√° la posibilidad de inyecci√≥n SQL, ya que los valores de los par√°metros son tratados como datos, no como parte de la consulta SQL.
- **Limitar los permisos de la base de datos:** Aseg√∫rese de que los usuarios de la base de datos tengan solo los permisos necesarios para realizar sus funciones y nada m√°s. Esto limitar√° el alcance de cualquier posible ataque.
- **Utilizar herramientas de seguridad y pruebas de penetraci√≥n:** Realice pruebas regulares de seguridad y pruebas de penetraci√≥n en la aplicaci√≥n para identificar posibles vulnerabilidades y errores de seguridad. Tambi√©n puede utilizar herramientas de seguridad de terceros para proteger la aplicaci√≥n contra la inyecci√≥n SQL.
- **Actualizaci√≥n y parcheo del software de la base de datos y uso de firewalls de aplicaci√≥n web (WAF)**

Es una tarea dif√≠cil determinar si una cadena de usuario es maliciosa o no. Por lo tanto, la mejor manera de hacerlo es ‚Äúescapar‚Äù de los caracteres especiales en la entrada del usuario. Puede escapar una cadena antes de construir la consulta en PHP usando la funci√≥n `mysql_escape_string()`. O en MySQL usando la funci√≥n `mysqli_real_escape_string()`.

Mientras se muestra la salida como HTML, tambi√©n tendr√° que convertir la cadena para asegurarse de que los caracteres especiales no interfieren con el marcado HTML. Puede convertir caracteres especiales en PHP usando la funci√≥n htmlspecialchars().

<aside>
üëâ Alternativamente, puede usar sentencias preparadas para evitar las inyecciones de SQL. Una sentencia preparada es una plantilla de una consulta SQL, en la que se especifican los par√°metros en una etapa posterior para ejecutarla. Aqu√≠ hay un ejemplo de una declaraci√≥n preparada en PHP y MySQLi.

</aside>

`$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

`$query->execute(array($username, $password));`

<aside>
üìñ En resumen, para solucionar y prevenir la inyecci√≥n SQL avanzada, es necesario validar y sanitizar todas las entradas de datos, utilizar consultas parametrizadas, limitar los permisos de la base de datos y utilizar herramientas de seguridad y pruebas de penetraci√≥n.

</aside>

## Referencias

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)
- [https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)
